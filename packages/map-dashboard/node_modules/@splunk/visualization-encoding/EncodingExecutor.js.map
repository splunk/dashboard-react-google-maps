{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"@babel/runtime/helpers/classCallCheck\"","webpack:///external \"@babel/runtime/helpers/createClass\"","webpack:///./src/DataPoint.ts","webpack:///./src/EncodingExecutor.ts","webpack:///external \"lodash\"","webpack:///external \"@babel/runtime/helpers/inherits\"","webpack:///external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack:///external \"@babel/runtime/helpers/getPrototypeOf\"","webpack:///./src/Formatter.ts","webpack:///./src/DataSeries.ts","webpack:///./src/TypeSafeValue.ts","webpack:///./src/utils/types.ts","webpack:///./src/DataFrame.ts","webpack:///external \"@splunk/visualizations-shared/colorUtils\"","webpack:///external \"@splunk/moment\"","webpack:///external \"@babel/runtime/helpers/toConsumableArray\"","webpack:///external \"@babel/runtime/helpers/slicedToArray\"","webpack:///./src/DataPrimitive.ts","webpack:///./src/DslParser.ts","webpack:///external \"chroma-js\"","webpack:///./src/formatters/Helper.ts","webpack:///./src/FormatterPresets.ts","webpack:///external \"nearley\"","webpack:///./src/nearley/generated/vizparser.js","webpack:///external \"@babel/runtime/helpers/construct\"","webpack:///./src/utils/formatterUtils.ts","webpack:///./src/AST.ts","webpack:///./src/EncodingParser.ts","webpack:///./src/OptionScopes.ts","webpack:///./src/formatters/SetColorChannel.ts","webpack:///./src/formatters/Prefix.ts","webpack:///./src/formatters/MatchValue.ts","webpack:///./src/formatters/RangeValue.ts","webpack:///./src/formatters/Gradient.ts","webpack:///./src/formatters/Pick.ts","webpack:///./src/formatters/Type.ts","webpack:///./src/formatters/FormatByType.ts","webpack:///external \"numbro\"","webpack:///./src/formatters/Frame.ts","webpack:///./src/formatters/Prepend.ts","webpack:///./src/formatters/Objects.ts","webpack:///external \"@babel/runtime/helpers/defineProperty\"","webpack:///./src/formatters/MultiFormat.ts","webpack:///./src/formatters/MaxContrast.ts","webpack:///./src/formatters/RenameSeries.ts","webpack:///external \"@babel/runtime/helpers/get\"","webpack:///./src/formatters/Default.ts"],"names":["x","grammar","Lexer","ParserRules","name","symbols","postprocess","d","id","literal","JSON","parseInt","parseFloat","e","arg0","otherArgs","args","r","type","v","depth","stack","item","flat","ParserStart","module","window"],"mappings":"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","file":"EncodingExecutor.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","import { DataPrimitive, TypedValue, DataType, IDataPoint } from './DataPrimitive';\nimport { TypeSafeValue } from './TypeSafeValue';\n\n/**\n * Base DataPoint class and associated DataPoint selectors\n * @implements {DataPrimitive}\n * @implements {IDataPoint}\n */\nexport class DataPoint<T extends DataType = DataType> implements DataPrimitive<T>, IDataPoint<T> {\n    private value: TypeSafeValue<T>;\n    public field: string;\n\n    static isDataPoint(o: any): o is DataPoint {\n        return o instanceof DataPoint;\n    }\n\n    static fromRaw(value): DataPoint {\n        return new DataPoint('', TypeSafeValue.fromRaw(value));\n    }\n\n    /**\n     *\n     * @param {string} field data field\n     * @param {object} value data value + it's type (number, string, time or color)\n     * @param {object} meta meta data (value + type) associated with the data point\n     */\n    public constructor(field: string, value: TypedValue<T>) {\n        this.field = field;\n        this.setValue(value);\n    }\n\n    getValue(): TypeSafeValue<T> {\n        return this.value;\n    }\n\n    /**\n     * sets the data point's value to a static TypedValue\n     * @param {TypedValue} v\n     */\n    setValue(v: TypedValue<T>): void {\n        this.value = TypeSafeValue.from(v);\n    }\n\n    /**\n     * get only value of the data point\n     * @returns {string|number|null}\n     */\n    getRawValue(): string | number | null {\n        return this.value.toRawValue();\n    }\n\n    /**\n     * Returns the datatype of the point\n     * @public\n     * @returns {DataPoint<'string'>}\n     */\n    getField(): DataPoint<'string'> {\n        return DataPoint.fromRaw(this.field) as DataPoint<'string'>;\n    }\n}\n","import { cloneDeep, isPlainObject } from 'lodash';\nimport { DataFrame } from './DataFrame';\nimport { Expr, LITERAL_TYPES, LiteralSymbol, Method, Option, ParserSymbol, OptionsStanza } from './AST';\nimport { formatterClasses } from './FormatterPresets';\nimport { DataPrimitive, DataType, isDataPrimitive } from './DataPrimitive';\nimport { IDimension } from './Dimensions';\nimport { TypeSafeValue } from './TypeSafeValue';\nimport { DataPoint } from './DataPoint';\nimport { OptionScopes, Scopes } from './OptionScopes';\nimport { DslParser } from './DslParser';\nimport EncodingParser from './EncodingParser';\nimport { Helper } from './formatters/Helper';\n\n/**\n * An interface for abstracting data sources as map of DataFrames\n */\nexport interface Frames {\n    [dataSourceType: string]: DataFrame<DataType>;\n}\n/**\n * Class with static methods used to execute DSL expressions\n */\nexport default class EncodingExecutor {\n    executeOptions(\n        optionsStanza: OptionsStanza,\n        frames: Frames,\n        themeFunc: (themeKey) => any\n    ): Record<string, any> {\n        const ret = cloneDeep(optionsStanza); // evaluate DSL expressions, in place, in ret object\n        const scopes: OptionScopes = new OptionScopes(ret, frames, themeFunc);\n        this.eval(ret, scopes);\n        return EncodingExecutor.rawTree(ret.options);\n    }\n    /**\n     * o is what we are evaluating. If it is an array or an object that its parts are recursively\n     * evaluated. Any DSL expressions encountered are evaluated. The scopes object is uses by the\n     * DSL expression to resolve any identifiers. The scope object's 'local' scope is updated by\n     * pushLocalScope as the eval method moves through the tree. The path array for a path \"context.a.b.c\"\n     * will be ['context', 'a', 'b','c']. As eval moves through the tree, the scopes add the current\n     * path its visited list. If the current path is found in the visited list, then a circular reference\n     * error is thrown.\n     * current 'path' in the\n     * @param o\n     * @param {OptionScopes} scopes\n     * @param {string[]} path\n     * @returns {any}\n     */\n    public eval(o: any, scopes: OptionScopes, path: string[] = []): any {\n        scopes.pushLocalScope(o);\n        scopes.addToVisitedList(path);\n        // evaluate array or option fields, and write the resulting value back into object o\n        if (Array.isArray(o)) {\n            //evaluate each array element\n            o.forEach((v, i) => {\n                path.push(i.toString());\n                o[i] = this.eval(o[i], scopes, path);\n                path.pop();\n            });\n        } else if (isPlainObject(o)) {\n            //evaluate each object field\n            Object.keys(o).forEach(k => {\n                path.push(k);\n                o[k] = this.eval(o[k], scopes, path);\n                path.pop();\n            });\n        } else if (EncodingParser.isDslString(o)) {\n            scopes.popLocalScope();\n            const tmp = this.evalDsl(o, scopes);\n            scopes.removeFromVisitedList(path);\n            return tmp;\n        }\n        //if here then o is js primitive value or DataPrimitive.\n        scopes.popLocalScope();\n        scopes.removeFromVisitedList(path);\n        return o;\n    }\n\n    evalDsl(dsl: string, scopes: OptionScopes): IDimension {\n        try {\n            const parsedDsl: Expr[] = DslParser.parse(EncodingParser.withoutArrow(dsl));\n            return this.execOptionsPipeline(parsedDsl, scopes, scopes.frames['primary']);\n        } catch (e) {\n            console.log(`dsl error: ${e.message}`);\n            return undefined;\n        }\n    }\n\n    /**\n     * Takes anything that can have DSL embedded in it, such as tree or array, and insures\n     * that all DataPrimitive have been converted to their 'raw' equivalents\n     * @param {object} o\n     * @returns {any}\n     */\n    static rawTree(o: Record<string, any>): any {\n        // evaluate array or option fields, and write the resulting value back into object o\n        if (Array.isArray(o)) {\n            //evaluate each array element\n            o.forEach((v, i) => {\n                o[i] = EncodingExecutor.rawTree(o[i]);\n            });\n            return o;\n        } else if (isPlainObject(o)) {\n            // use isPlainObject to avoid traversing fields of funky options like IconComponent that have methods and circular reference graph\n            //evaluate each object field. Such objects would never expect to have DSL embedded in them and will cause a stack overflow due to cycles\n            Object.keys(o).forEach(k => {\n                o[k] = EncodingExecutor.rawTree(o[k]);\n            });\n            return o;\n        } else {\n            const tmp = isDataPrimitive(o) ? o.getRawValue() : o;\n            return tmp;\n        }\n    }\n\n    /**\n     * Executes sequence of pipe delimited expressions that constitute a DSL\n     * @param {Expr[]} pipeline\n     * @param {OptionScopes} scopes\n     * @param {DataPrimitive<DataType>} origin\n     * @param {ExecutedOptions} executedOptions\n     * @returns {{location: string; val: Option | DataPrimitive}}\n     */\n    execOptionsPipeline(\n        pipeline: Expr[],\n        scopes: OptionScopes,\n        origin: DataPrimitive<DataType> // meta fields default to the value DataPrimitve as origin. Value field default to frames.primary as their origin\n    ): IDimension {\n        let subject = origin;\n        //process each expression in pipeline expr|expr|expr...\n        pipeline.forEach((expr: Expr, i) => {\n            if (expr.type === 'method') {\n                subject = this.executeMethod(expr, subject, scopes.context);\n            } else if (expr.type === 'identifier') {\n                //When an identifier exists in the pipeline line like delta in 'delta|foo(bar)' it can refer to\n                //either a DataPrimitive or a SimpleOption.\n                subject = scopes.resolve(expr.v.toString()).val;\n            } else if (LITERAL_TYPES.includes(expr.type)) {\n                const tsv = TypeSafeValue.from({ type: expr.type, value: expr.v });\n                subject = new DataPoint('', tsv);\n            }\n            const isLastInPipeline = i === pipeline.length - 1;\n            //if the subject will pass forward through another pipe, we must convert it to a DataPrimtive\n            if (!isLastInPipeline && !isDataPrimitive(subject)) {\n                try {\n                    subject = Helper.dataPrimitiveFromRaw(subject);\n                } catch (e) {\n                    const exprStr = expr['v'] ? expr['v'] : expr['name'];\n                    throw new Error(\n                        `Output of '${exprStr}' cannot be piped because it is not a DataFrame, DataPoint, or DataSeries`\n                    );\n                }\n            }\n        });\n\n        return subject as IDimension;\n    }\n\n    /**\n     * Methods are either selector methods that built-ins such as\n     * 'selectSeriesByPosition(...)\",or they are formatter calls like 'rangeValue(...)'\n     * @param {Method} expr\n     * @param {DataPrimitive} subject\n     * @param {Scopes} scopes\n     * @param {string} metaName\n     * @returns {DataPrimitive}\n     */\n    private executeMethod(\n        expr: Method,\n        subject: DataPrimitive<DataType>,\n        context: Record<string, any>\n    ): DataPrimitive<DataType> {\n        const m = expr as Method;\n        if (!subject) {\n            throw new Error(`Pipeline composition error: method ${m.name} has no subject`);\n        }\n        const args = this.args(m.args, context);\n        const method = subject[m.name];\n        if (method) {\n            subject = method.apply(subject, args); //'built in' DataPrimitive selectors like selectSeriesByPosition\n        } else {\n            subject = this.applyFormatter(subject, m.name, args);\n        }\n        return subject;\n    }\n\n    /**\n     * Applies the Formatter to either metaData or value\n     * @param {DataPrimitive} subject\n     * @param {string} funcName\n     * @param {ResolvedValue[]} args\n     * @param {string} metaName\n     */\n    private applyFormatter(\n        subject: DataPrimitive<DataType>,\n        funcName: string,\n        args: any[]\n    ): DataPrimitive<DataType> {\n        const formatterClass = formatterClasses[funcName];\n        if (formatterClass) {\n            return new formatterClass(...args).format(subject as IDimension);\n        } else {\n            throw Error(`No such method or formatter function: '${funcName}'`);\n        }\n    }\n\n    /**\n     * Sometimes when invoking a pipeline we may find degenerate pipelines like\n     * '42' that simply set the metadata to a literal. Or, we may perhaps in\n     * a value pipeline, we set the value to 'hello' after w perform selection\n     * like \"selectByPosition(0)|'hello'\"\n     * @param {DataPrimitive} subject\n     * @param {LiteralSymbol} symbol\n     */\n    applyLiteral(subject: DataPrimitive<DataType>, symbol: LiteralSymbol): void {\n        const { type, v: value } = symbol;\n        subject.setValue({ type, value });\n    }\n\n    /**\n     * reduces method call arguments (ParserSymbols) to actual values\n     * @param {ParserSymbol[]} args\n     * @param {Scopes} scopes\n     * @returns {any[]}\n     */\n    private args(args: ParserSymbol[], context: Record<string, any>): any[] {\n        return args.reduce((acc, cur) => {\n            const v = this.getArg(cur, context);\n            acc.push(v);\n            return acc;\n        }, []);\n    }\n\n    /**\n     * Returns either the literal value from the symbol, or a value from context.\n     * Throws error if identifier not found in context.\n     * @param {ParserSymbol} s\n     * @param {object} context\n     * @returns {any}\n     */\n    private getArg(s: ParserSymbol, context: Record<string, any>): any {\n        if (s.type === 'identifier') {\n            //fixme todo this should use a proper 'resolve' not just look into context\n            const val = context[s.v];\n            if (!val) {\n                throw Error(\n                    `Could not resolve ${s.v} in context. Did you mean one of '[${Object.keys(\n                        context\n                    ).toString()}]'`\n                );\n            }\n            return val;\n        } else {\n            return s.v;\n        }\n    }\n\n    /**\n     * Simple method to tell if the argument is an object or primitive.\n     * @param opt\n     * @returns {boolean}\n     */\n    static isObject(opt: any): boolean {\n        return Object(opt) === opt;\n    }\n}\n","module.exports = require(\"lodash\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","import { DataType, TypedValue, DataPrimitive } from './DataPrimitive';\nimport { IDimension } from './Dimensions';\nimport { DataFrame } from './DataFrame';\nimport { DataSeries } from './DataSeries';\nimport { DataPoint } from './DataPoint';\n\nexport interface DataPrimitiveFormatter<IN extends DataType, OUT extends DataType> {\n    format(dataPrimitive: IDimension<IN>): IDimension<OUT> | Record<string, unknown>;\n}\n\nexport abstract class AbstractFormatter<IN extends DataType = DataType, OUT extends DataType = DataType>\n    implements DataPrimitiveFormatter<IN, OUT> {\n    // use method overload signatures to tell compiler that if we format a DataPoint, we return a DataPoint, etc\n    format(p: DataPoint<IN>): DataPoint<OUT>;\n    format(s: DataSeries<IN>): DataSeries<OUT>;\n    format(f: DataFrame<IN>): DataFrame<OUT>;\n    format(dataPrimitive: IDimension<IN>): IDimension<OUT> {\n        if (dataPrimitive instanceof DataFrame) {\n            const newSeries: DataSeries<OUT>[] = [];\n            dataPrimitive.series.forEach((dataSeries: DataSeries<IN>, i: number) => {\n                newSeries.push(this.formatSeries(dataSeries, i));\n            });\n            return new DataFrame<OUT>(newSeries);\n        } else if (dataPrimitive instanceof DataSeries) {\n            return this.formatSeries(dataPrimitive);\n        } else {\n            return this.formatPoint(dataPrimitive);\n        }\n    }\n\n    protected formatSeries(s: DataSeries<IN>, i = 0): DataSeries<OUT> {\n        const newPoints: DataPoint<OUT>[] = [];\n        s.points.forEach((dataPoint, j) => {\n            newPoints.push(this.formatPoint(dataPoint, s, i, j));\n        });\n        return new DataSeries<OUT>(newPoints); // new DataSeries must have the type of the formatter's output\n    }\n\n    protected formatPoint(p: DataPoint<IN>, s?: DataSeries<IN>, i = 0, j = 0): DataPoint<OUT> {\n        const { field } = p;\n        const tmp = this.formatTypedValue(p, s, i, j);\n        return new DataPoint<OUT>(field, tmp);\n    }\n\n    protected abstract formatTypedValue(\n        p: DataPoint<IN>,\n        s?: DataSeries<IN>,\n        i?: number,\n        j?: number\n    ): TypedValue<OUT>;\n\n    protected makeArrays2D(a: any): any[][] {\n        if (Array.isArray(a)) {\n            if (Array.isArray(a[0])) {\n                return a;\n            } else {\n                return [a];\n            }\n        }\n        throw new Error(\"argument wasn't array\");\n    }\n}\n","import { DataPoint } from './DataPoint';\nimport { DataPrimitive, DataType, IDataSeries, TypedValue } from './DataPrimitive';\n\n/**\n * DataSeries class and associated DataSeries selectors\n * @implements {DataPrimitive}\n */\nexport class DataSeries<T extends DataType = DataType> implements DataPrimitive<T>, IDataSeries<T> {\n    public readonly points: DataPoint<T>[];\n    public readonly field: string;\n\n    static isDataSeries(o: any): o is DataSeries {\n        return o instanceof DataSeries;\n    }\n\n    static fromRaw(pts: any[]): DataSeries {\n        return new DataSeries(pts.map(p => DataPoint.fromRaw(p)));\n    }\n    /**\n     *\n     * @param {array} points list of data points\n     */\n    constructor(points: DataPoint<T>[] = []) {\n        this.points = points;\n        if (points.length > 0) {\n            this.field = points[0].field; // the field is an immutable property of the series\n        }\n    }\n\n    /**\n     * return first dataPoint in series\n     * @public\n     * @returns {DataPoint}\n     */\n    firstPoint(): DataPoint<T> {\n        return this.points[0];\n    }\n\n    /**\n     * return last dataPoint in series\n     * @public\n     * @returns {DataPoint}\n     */\n    lastPoint(): DataPoint<T> {\n        return this.points.slice(-1)[0];\n    }\n\n    /**\n     * finds dataPoint(s) in DataSeries by index(es)\n     * @public\n     * @param {...number} indexes\n     * @returns {DataSeries}\n     */\n    pointsByIndexes(...indexes: number[]): DataSeries<T> {\n        const indexedPoints: DataPoint<T>[] = [];\n        indexes.forEach(index => {\n            const dp = this.points[index]; // should we allow negative indexes?\n            if (dp != null) {\n                indexedPoints.push(dp);\n            }\n        });\n        return new DataSeries(indexedPoints);\n    }\n\n    /**\n     * finds and returns the individual dataPoint at the given index\n     * @public\n     * @param {number} index\n     * @returns {DataPoint}\n     */\n    pointByIndex(index: number): DataPoint<T> {\n        if (index < 0 || index >= this.points.length) {\n            // will handle negative and out-of-range indexes for the time being by returning null\n            return null;\n        }\n        const dp = this.points[index];\n        const field = dp.field;\n        const { type, value } = dp.getValue();\n        return new DataPoint(field, { type, value });\n    }\n\n    /**\n     * finds the delta between the last point and point at the given index.\n     * a negative index can be used, indicating an offset from the end of the sequence\n     * @public\n     * @param {number} index\n     * @returns {DataPoint}\n     */\n    delta(index: number): DataPoint<T> {\n        const dp1 = this.lastPoint();\n        if (dp1 === undefined) {\n            return undefined;\n        }\n        const field = dp1.field;\n\n        const { type, value: val1 } = dp1.getValue();\n        if (type !== 'number') {\n            console.warn(`delta cannot be computed for non-numerical data series of type ${type}`); // Throw an error and catch in pipeline executor?\n        }\n\n        let dp2 = null;\n        // use undefined as default, because null values will be coerced to 0 (thus invalid indexes return a delta of 0)\n        // for aggregate SPL queries like `stats count`, we want no trend value rather than 0 as the trend value\n        let delta;\n        if (index >= 0) {\n            dp2 = this.points[index];\n        } else {\n            dp2 = this.points.slice().reverse()[Math.abs(index) - 1];\n        }\n        if (dp2 == null) {\n            console.warn('invalid index'); // Throw an error and catch in pipeline executor?\n        } else {\n            const { value: val2 } = dp2.getValue();\n            delta = val1 - val2;\n        }\n        return new DataPoint(field, { type, value: delta }); // create a new data point since we don't want meta data to carry over\n    }\n\n    /**\n     * sets all the values in the Data Series to a static TypedValue\n     * @param {TypedValue} v\n     */\n    setValue(v: TypedValue<T>) {\n        this.points.forEach(p => {\n            p.setValue(v);\n        });\n    }\n\n    /**\n     * gets all the values + their type in the Data Series\n     * @returns {TypedValue[]}\n     */\n    getValue(): TypedValue<T>[] {\n        const values: TypedValue<T>[] = [];\n        this.points.forEach(p => {\n            values.push(p.getValue());\n        });\n        return values;\n    }\n\n    /**\n     * gets all the values (only) in the Data Series\n     * @returns {array}\n     */\n    getRawValue(): (string | number)[] {\n        const values: (string | number)[] = [];\n        this.points.forEach(p => {\n            values.push(p.getRawValue());\n        });\n        return values;\n    }\n\n    /**\n     * Returns the uniform type of the series\n     * @public\n     * @returns {DataPoint<'string'>}\n     */\n    getField(): DataPoint<'string'> {\n        const dp1 = this.lastPoint();\n        return dp1.getField();\n    }\n\n    /**\n     * returns the minimum DataPoint in the series or undefined if no numbers in series\n     * @public\n     * @returns {DataPoint<T>}\n     */\n    min(): DataPoint<T> {\n        return this.reduce((v1, v2) => v1 < v2);\n    }\n\n    /**\n     * returns the maximum DataPoint in the series\n     * @public\n     * @returns {DataPoint<T>}\n     */\n    max(): DataPoint<T> {\n        return this.reduce((v1, v2) => v1 > v2);\n    }\n\n    private reduce(comparator: (v1: T, v2: T) => boolean): DataPoint<T> {\n        return this.points.reduce((agg: DataPoint<T>, cur: DataPoint<T>) => {\n            // note: cannot use agg.getRawValue here instead of agg.value.value as that limits returned value to string|number\n            return !agg || comparator(cur.getValue().value, agg.getValue().value) ? cur : agg;\n        }, undefined);\n    }\n}\n","import { isColor } from '@splunk/visualizations-shared/colorUtils';\nimport { DataType, TypedValue } from './DataPrimitive';\nimport { isNumber, isString, isTime, getDataTypeForPoint } from '../src/utils/types';\nimport moment from '@splunk/moment';\n\n/**\n * @implements {TypedValue}\n * TypeSafeValue implements the TypedValue interface, and adds additional methods 'isOk' which can be used to determine\n * if the value was properly coerced into the expected type. When isOk is false, it means that coerced value cannot\n * be relied upon. For example, if the type is 'time' but isOk is false, it is possible that the coerced value could be NaN.\n * A field named originalValue can be used for user-facing error messages in situations where isOk is false. For example:\n * \"'cat' was not an OK value for a 'time' field\". This class's fields are all immutable.\n */\nexport class TypeSafeValue<T extends DataType> implements TypedValue<T> {\n    /**\n     * isTypeSafe. This is a marker field. The presence of this field can be used at runtime to determine if TypedValue is rigorous,\n     * loose. Loose TypedValue such as {type:'number', value:'cat'} are handy for testing, but can lie. Obviously 'cat'\n     * is not a number. If the isTypeSafe field is present then the instance is a TypeSafeValue\n     * @type {boolean}\n     */\n    readonly isTypeSafe: boolean = true;\n    /**\n     * isOk. This field tells if the original value passed into this's constructor honored its type contract.\n     * @type {boolean}\n     */\n    readonly isOk: boolean = true;\n    /**\n     * originalValue. This field retains the original value prior to coercion. It can be used to show a user which values\n     * failed to comply with the expected type.\n     */\n    readonly originalValue: any;\n\n    readonly type: T;\n    readonly value: any;\n\n    constructor(type: T, value: any, isOk: boolean, originalValue: any) {\n        this.type = type;\n        this.value = value;\n        this.isOk = isOk;\n        this.originalValue = originalValue;\n    }\n\n    /**\n     * returns a TypeSafeValue, either by converting the non TypeSafeValue to\n     * a TypeSafeValue, or by simply returning the passed-in TypeSafeValue\n     * @param {TypedValue<T>} typedValue\n     * @returns {TypeSafeValue<T>}\n     */\n    public static from<T extends DataType = DataType>(typedValue: TypedValue<T>): TypeSafeValue<T> {\n        if ((typedValue as any).isTypeSafe) {\n            return typedValue as TypeSafeValue<T>; // just return what was passed in since it is already TypeSafeValue\n        } else {\n            const { value: originalValue, type } = typedValue;\n            const [value, isOk] = TypeSafeValue.coerceValue<T>(typedValue);\n            return new TypeSafeValue<T>(type, value, isOk, originalValue);\n        }\n    }\n\n    /**\n     * Creates a TypeSafeValue from a raw value\n     * @param value\n     * @returns {TypeSafeValue<DataType>}\n     */\n    public static fromRaw(value): TypeSafeValue<DataType> {\n        const type: DataType = getDataTypeForPoint(value);\n        return new TypeSafeValue(type, value, true, value);\n    }\n\n    /**\n     * attempts to coerce the provided value to the provided type. Returns tuple\n     * of the coerced value and a boolean telling if the coercion was clean (true)\n     * or if the coercion was likely produced an unusable result, such as NaN for\n     * a number, or '' for a color.\n     * @param {TypedValue<T>} typedValue\n     * @returns {[any, boolean]}\n     */\n    private static coerceValue<T extends DataType = DataType>(typedValue: TypedValue<T>): [any, boolean] {\n        const { type, value } = typedValue;\n        let coercedVal = null;\n        let isOk: boolean;\n        let acceptableType = true;\n        try {\n            switch (type) {\n                case 'number': {\n                    isOk = isNumber(value);\n                    coercedVal = Number(value);\n                    break;\n                }\n                case 'time': {\n                    isOk = isTime(value);\n                    if (value instanceof Date) {\n                        coercedVal = value;\n                    } else {\n                        // for case like `VM-203`, It will be convereted to a Date.\n                        coercedVal = isOk ? new Date(value) : 'Invalid Date';\n                    }\n\n                    break;\n                }\n                case 'string': {\n                    isOk = isString(value);\n                    coercedVal = value.toString();\n                    break;\n                }\n                case 'color': {\n                    isOk = isColor(value);\n                    coercedVal = value;\n                    break;\n                }\n                case 'sparkline': {\n                    isOk = Array.isArray(value) && value[0] === '##__SPARKLINE__##';\n                    coercedVal = value;\n                    break;\n                }\n                case 'array': {\n                    isOk = Array.isArray(value);\n                    coercedVal = value;\n                    break;\n                }\n                case 'null': {\n                    isOk = value === null;\n                    coercedVal = value;\n                    break;\n                }\n                default: {\n                    acceptableType = false;\n                }\n            }\n        } catch (e) {\n            isOk = false;\n        }\n        if (!acceptableType) {\n            throw new Error(`unknown type: '${type}'`);\n        }\n        return [coercedVal, isOk];\n    }\n\n    toRawValue(): string | number | null {\n        switch (this.type) {\n            case 'time':\n                return moment(this.value).format();\n            case 'sparkline':\n            case 'array':\n            case 'number':\n            case 'string':\n            case 'color':\n            default:\n                return this.value;\n        }\n    }\n}\n","import moment from '@splunk/moment';\nimport { isNumber as lodashIsNumber, isBoolean, isFinite, isObject, isEmpty, memoize } from 'lodash';\nimport { isColor } from '@splunk/visualizations-shared/colorUtils';\nimport { DataType } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\n\n/**\n * returns true if this dataPoint is a finite number\n * @param dataPoint\n * @returns {*}\n */\nexport function isNumber(dataPoint): boolean {\n    return (\n        dataPoint !== null &&\n        !isBoolean(dataPoint) &&\n        dataPoint !== '' &&\n        isFinite(+dataPoint) &&\n        lodashIsNumber(+dataPoint)\n    );\n}\n\n/**\n *returns OK if data is time\n * @param dataPoint\n * @returns {boolean}\n */\nexport function isTime(dataPoint): boolean {\n    if (!dataPoint) {\n        return false;\n    }\n\n    // only support time string in following format: https://www.w3.org/TR/NOTE-datetime\n    const supportedDateFormats = [\n        'YYYY-MM-DD', // HTML5 date\n        moment.ISO_8601,\n        'YYYY-MM-DDTHH:mm', // HTML5 date local\n        'YYYY-MM-DDTHH:mm:ss.SSS', // HTML5 date local milliseconds\n        'YYYY-MM-DDTHH:mm:ss', // HTML5 date local seconds\n        'YYYY-MM-DD HH:MM',\n        'YYYY-MM-DD HH:MM:SS',\n        'YYYY-MM-DD HH:MM:SS.SSS',\n    ];\n    return typeof dataPoint === 'string'\n        ? moment(dataPoint, supportedDateFormats, true).isValid()\n        : moment(dataPoint).isValid();\n}\n\n/**\n * returns OK if data is string\n * @param dataPoint\n * @returns {boolean}\n */\nexport function isString(dataPoint): boolean {\n    return typeof dataPoint === 'string';\n}\n\n/**\n * getDataTypeForPoint\n * naive implementation of checking for the data type of a single data point\n * number > time > string > unknown\n * starting with number because a Date.parse(number) is a valid date\n *\n * @param {any} dataPoint\n * @param {object} metaData meta data about the data field\n * @return {string} type\n */\nexport const getDataTypeForPoint = <T>(dataPoint?: T, metaData?: { fieldName: string }): DataType => {\n    if (canInferTypeFromMeta(metaData)) {\n        return getDataTypeForMeta(metaData);\n    }\n    return memoizedGetDataTypeForValue(dataPoint);\n};\n\nconst getDataTypeForValue = <T>(dataPoint?: T): DataType => {\n    if (Array.isArray(dataPoint)) {\n        if (dataPoint.length > 1 && dataPoint[0] === '##__SPARKLINE__##') {\n            return 'sparkline';\n        }\n        return 'array';\n    } else if (isObject(dataPoint)) {\n        return 'unknown';\n    } else if (isNumber(dataPoint)) {\n        return 'number';\n    } else if (isColor(dataPoint)) {\n        return 'color';\n    } else if (isTime(dataPoint)) {\n        return 'time';\n    } else if (isString(dataPoint)) {\n        return 'string';\n    } else if (dataPoint === null) {\n        return 'null';\n    }\n    // objects, etc\n    return 'unknown';\n};\nconst memoizedGetDataTypeForValue = memoize(getDataTypeForValue);\n\nexport interface MetaData {\n    fieldName?: string;\n}\n/**\n * canInferTypeFromMeta\n * verifies whether a data type can be inferred from meta data\n * @param {object} metaData\n * @return {boolean} whether the data type can be inferred from meta\n */\nexport const canInferTypeFromMeta = (metaData: MetaData = {}): boolean => {\n    const { fieldName } = metaData;\n    return fieldName === '_time';\n};\n/**\n * getDataTypeForMeta\n * returns a data type based on meta data\n * @param {object} metaData\n * @return {string} type\n */\nexport const getDataTypeForMeta = (metaData: MetaData = {}): DataType => {\n    const { fieldName } = metaData;\n    if (fieldName === '_time') {\n        return 'time';\n    }\n    // this case should never be reached\n    return 'unknown';\n};\n\n/**\n * inferDataTypeFromSample\n * based on a number of data points this function determines the data type for all of them\n * and returns the most common data type (naive type inference)\n *\n * @param {Array} dataSample an array of arbitrary size containing data points of any data type\n * @return {string} type the most common type in the sample\n */\nexport const inferDataTypeFromSample = <T>(dataSample: T[]): DataType => {\n    const typeMatches: { [k in DataType]: number } = {\n        time: 0,\n        number: 0,\n        string: 0,\n        color: 0,\n        unknown: 0,\n        array: 0,\n        sparkline: 0,\n        null: 0,\n    };\n    dataSample.forEach((point): void => {\n        typeMatches[getDataTypeForPoint(point)] += 1;\n    });\n    let typeCount = 0;\n    let returnType = 'unknown';\n    Object.keys(typeMatches).forEach((key: DataType): void => {\n        if (typeMatches[key] > typeCount) {\n            typeCount = typeMatches[key];\n            returnType = key;\n        }\n    });\n    return returnType as DataType;\n};\n\n/**\n * based on a data array (e.g. one data column) this function returns a tiny sample of it\n * @TODO: very naive approach. there's papers with more advanced techniques but for now this should be very fast\n *\n * @param {Array} data to draw a sample from\n * @return {Array} a sample of the passed data\n */\nexport const drawSample = <T>(data: T[]): T[] => {\n    let sampleData: T[] = [];\n    if (data.length > 2) {\n        sampleData = [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];\n    } else {\n        sampleData = data;\n    }\n    return sampleData.map((point: T) =>\n        DataPoint.isDataPoint(point) ? point.getValue().originalValue : point\n    );\n};\n\n/**\n *\n * @param {*} data\n */\nexport const inferDataTypeFromData = <T>(data: T[]): DataType => inferDataTypeFromSample(drawSample(data));\n","import { DataPoint } from './DataPoint';\nimport { DataSeries } from './DataSeries';\nimport { inferDataTypeFromData, getDataTypeForPoint } from './utils/types';\nimport { DataPrimitive, TypedValue, DataType, IDataFrame } from './DataPrimitive';\nimport { IDimension } from './Dimensions';\n\nexport type ColumnVal = number | string | string[];\nexport interface ColumnarData {\n    data: {\n        fields: { name: string }[] | string[];\n        columns: ColumnVal[][];\n    };\n}\n\n/**\n * Base DataFrame class and associated DataFrame selectors\n * @implements {DataPrimitive}\n */\nexport class DataFrame<T extends DataType = DataType> implements IDataFrame<DataType>, DataPrimitive<T> {\n    /**\n     * List of series comprising the DataFrame\n     * @public\n     * @instance\n     */\n    public series: DataSeries<T>[];\n\n    /**\n     * @param {any} o\n     * @returns {boolean}\n     */\n    static isDataFrame(o: any): o is DataFrame {\n        return o instanceof DataFrame;\n    }\n\n    /**\n     * @param {array} series list of data series\n     */\n    constructor(series: DataSeries<T>[]) {\n        this.series = Array.isArray(series) ? series : [series];\n    }\n\n    /**\n     * Loads ColumnarData into a DataFrame\n     * @param {ColumnarData} columnarData\n     * @returns {DataFrame<T>}\n     */\n    static fromJsonCols<T extends DataType = DataType>(columnarData: ColumnarData): DataFrame<T> {\n        if (!columnarData || columnarData.data === null) {\n            return new DataFrame<T>([]);\n        }\n        // fixme todo why do we expect an object like {data:{fields, columns}}? Why don't we just expect something like {fields, columns}? The nesting inside 'data' feels useless\n        const {\n            data: { fields: fields = [], columns: columns = [] },\n        } = columnarData;\n        if (columns.length !== fields.length) {\n            throw new Error(\n                `number of columns (${columns.length}) does not match number of fields (${fields.length})`\n            );\n        }\n        const dataSeries = [];\n        columns.forEach((data: ColumnVal[], idx): void => {\n            const dataPoints = [];\n            const fieldInfo: any = fields[idx];\n            const fieldName: string = fieldInfo.name || fieldInfo;\n            data.forEach((value): void => {\n                const dataType: DataType = getDataTypeForPoint(value, { fieldName });\n                dataPoints.push(new DataPoint(fieldName, { value: value, type: dataType }));\n            });\n            dataSeries.push(new DataSeries(dataPoints));\n        });\n        return new DataFrame<T>(dataSeries);\n    }\n\n    static fromRaw(f: any[][]): DataFrame {\n        const series: DataSeries[] = [];\n        f.forEach((s: any[]): void => {\n            series.push(DataSeries.fromRaw(s));\n        });\n        return new DataFrame(series);\n    }\n\n    static fromDataPrimitive(dp: IDimension): DataFrame {\n        if (DataFrame.isDataFrame(dp)) {\n            return dp;\n        } else if (DataSeries.isDataSeries(dp)) {\n            return new DataFrame([dp]);\n        } else if (DataPoint.isDataPoint(dp)) {\n            return new DataFrame([new DataSeries([dp])]);\n        }\n    }\n\n    /**\n     * finds series in DataFrame by index(es)\n     * @public\n     * @param {number[]} indexes\n     * @returns {DataFrame}\n     */\n    frameBySeriesIndexes(...indexes: number[]): DataFrame<T> {\n        const indexedSeries: DataSeries<T>[] = [];\n        indexes.forEach((index): void => {\n            const ds = this.series[index]; // should we allow negative indexes?\n            if (ds != null) {\n                indexedSeries.push(ds);\n            }\n        });\n        return new DataFrame<T>(indexedSeries);\n    }\n\n    /**\n     *  Returns the data series at the given index\n     * @public\n     * @param {number} index\n     * @returns {DataSeries<T>}\n     */\n    seriesByIndex(index: number): DataSeries<T> {\n        return this.series[index];\n    }\n\n    /**\n     * Returns a DataFrame that is a slice of this DataFrame's series from  [start, end)\n     * @public\n     * @param {int} start (inclusive)\n     * @param {int} end (optional, exclusive)\n     * @returns {DataFrame<T>}\n     */\n    frameBySeriesIndexRange(start: number, end?: number): DataFrame<T> {\n        return new DataFrame<T>(this.series.slice(start, end));\n    }\n\n    /**\n     * Returns a DataFrame having only the DataSeries matching the provided names\n     * @public\n     * @param {string[]} names\n     * @returns {DataFrame<T>}\n     */\n    frameBySeriesNames(...names: string[]): DataFrame<T> {\n        const namedSeries: DataSeries<T>[] = [];\n        names.forEach((name): void => {\n            const found = this.seriesByName(name);\n            found && namedSeries.push(found);\n        });\n        return new DataFrame<T>(namedSeries);\n    }\n\n    /**\n     * Returns a DataFrame having the DataSeries matching provided names or indexes\n     * @public\n     * @param {...(string|number)} namesOrIndexes\n     * @returns {DataFrame<T>}\n     */\n    frameBySeriesNamesOrIndexes(...mixed: (string | number)[]): DataFrame<T> {\n        const mixedSeries: DataSeries<T>[] = [];\n        mixed.forEach((nameOrIndex: string | number): void => {\n            const asNumber = Number(nameOrIndex);\n            if (Number.isNaN(asNumber)) {\n                const found = this.seriesByName(nameOrIndex as string);\n                found && mixedSeries.push(found);\n            } else {\n                const found = this.series[asNumber];\n                found && mixedSeries.push(found);\n            }\n        });\n        return new DataFrame<T>(mixedSeries);\n    }\n\n    /**\n     * Returns a DataFrame containing DataSeries that match only the provided types\n     * @public\n     * @param {T[]} types\n     * @returns {DataFrame<T>}\n     */\n    frameBySeriesTypes(...types: T[]): DataFrame<T> {\n        return (new DataFrame<T>(\n            this.series.filter((s: DataSeries<T>): boolean => types.includes(s.firstPoint().getValue().type)) //fixme todo we should have a getType() method on a series. SHould not make 'decision' about what type the series is from outside the series\n        ) as unknown) as DataFrame<T>;\n    }\n\n    /**\n     * finds series in DataFrame by field name\n     * @public\n     * @param {string} field\n     * @returns {DataSeries<T>}\n     */\n    seriesByName(field: string): DataSeries<T> {\n        return this.series.find((dataSeries): boolean => field === dataSeries.field);\n    }\n\n    /**\n     * finds series in DataFrame by first data type match\n     * @public\n     * @param {T} type\n     * @returns {DataSeries<T>}\n     */\n    seriesByType(type: T): DataSeries<T> {\n        return this.series.find(dataSeries => {\n            const dataType: DataType = inferDataTypeFromData(dataSeries.points);\n            return dataType === type;\n        });\n    }\n\n    /**\n     * finds series in DataFrame with the providing prioritized types\n     * @public\n     * @param {T[]} types T extends from DataType, which is 'number' | 'string' | 'color' | 'time' | 'unknown' | 'sparkline' | 'array' | 'null'\n     * @returns {DataSeries<T>}\n     */\n    seriesByPrioritizedTypes(...types: T[]): DataSeries<T> {\n        for (const type of types) {\n            const matchedSeries: DataSeries<T> = this.seriesByType(type);\n            if (Array.isArray(matchedSeries?.points) && matchedSeries?.points?.length) {\n                return matchedSeries;\n            }\n        }\n        return this.series[0];\n    }\n\n    /**\n     * sets all the values in the DataFrame to a static TypedValue\n     * @public\n     * @param {TypedValue} v\n     */\n    setValue(v: TypedValue<T>): void {\n        this.series.forEach((s): void => s.setValue(v));\n    }\n\n    /**\n     * gets all the values (only) in the Data Frame\n     * @public\n     * @returns {array}\n     */\n    getRawValue(): (string | number)[][] {\n        const values: (string | number)[][] = [];\n        this.series.forEach((s): void => {\n            values.push(s.getRawValue());\n        });\n        return values;\n    }\n\n    /**\n     * gets all the values + their types in the Data Frame\n     * @public\n     * @returns {TypedValue[][]}\n     */\n    getValue(): TypedValue<T>[][] {\n        const values: TypedValue<T>[][] = [];\n        this.series.forEach((s): void => {\n            values.push(s.getValue());\n        });\n        return values;\n    }\n\n    /**\n     * Get the field names of each series in frame\n     * @public\n     * @returns {DataSeries<'string'>}\n     */\n    getField(): DataSeries<'string'> {\n        const points = this.series.map((s): DataPoint<'string'> => s.getField());\n        return new DataSeries<'string'>(points);\n    }\n\n    /**\n     * finds the global minimum value (from all numerical series) in the Data Frame\n     * @public\n     * @returns {number}\n     */\n    min(): DataPoint<T> {\n        return this.minOrMax('min');\n    }\n\n    /**\n     * finds the global maximum value (from all numerical series) in the Data Frame\n     * @public\n     * @returns {number}\n     */\n    max(): DataPoint<T> {\n        return this.minOrMax('max');\n    }\n\n    /**\n     * runs result of min or max function over all the series and returns the data point\n     * points\n     * @param {string} aggName\n     * @returns {DataPoint<T>}\n     */\n    private minOrMax(funcName: 'min' | 'max'): DataPoint<T> {\n        const overallSeries = new DataSeries<T>();\n        this.series.forEach((s): void => {\n            const m = s[funcName]();\n            m && overallSeries.points.push(m);\n        });\n        return overallSeries[funcName]();\n    }\n}\n","module.exports = require(\"@splunk/visualizations-shared/colorUtils\");","module.exports = require(\"@splunk/moment\");","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","import { TypeSafeValue } from './TypeSafeValue';\nimport { DataFrame } from './DataFrame';\nimport { DataPoint } from './DataPoint';\nimport { DataSeries } from './DataSeries';\nimport { IDimension } from './Dimensions';\n\nexport interface IDataPoint<T extends DataType> {\n    getValue(): TypeSafeValue<T>;\n}\n\nexport interface IDataSeries<T extends DataType> {\n    points: IDataPoint<T>[];\n}\n\nexport interface IDataFrame<T extends DataType> {\n    series: IDataSeries<DataType>[];\n}\n\nexport interface DataPrimitive<T extends DataType = DataType> {\n    /**\n     * set the value\n     * @param {TypedValue<T>} v\n     */\n    setValue(v: TypedValue<T>): void;\n}\n\nexport interface TypedValue<T extends DataType = DataType> {\n    type: T;\n    value: any;\n}\n\nexport type DataType = 'number' | 'string' | 'color' | 'time' | 'unknown' | 'sparkline' | 'array' | 'null';\n\nexport function isDataPrimitive(o: any): o is IDimension {\n    return DataFrame.isDataFrame(o) || DataSeries.isDataSeries(o) || DataPoint.isDataPoint(o);\n}\n","import { Expr } from './AST';\nimport { Parser } from 'nearley';\nimport grammar = require('./nearley/generated/vizparser.js');\n\nexport class DslParser {\n    public static parse(dsl: string): Expr[] {\n        const parser = new Parser(grammar);\n        parser.feed(dsl);\n        if (parser.results.length > 1) {\n            console.warn(`Ambiguous parse of '${dsl}'`);\n        }\n        if (parser.results.length == 0) {\n            console.warn(`No parsed results for '${dsl}'`);\n        }\n        return parser.results[0];\n    }\n}\n","module.exports = require(\"chroma-js\");","import { DataPrimitive } from '../DataPrimitive';\nimport { DataFrame } from '../DataFrame';\nimport { DataSeries } from '../DataSeries';\nimport { DataPoint } from '../DataPoint';\nimport { IDimension } from '../Dimensions';\nimport EncodingExecutor from '../EncodingExecutor';\n\nexport class Helper {\n    static isRawDataFrame(d: any): boolean {\n        return Array.isArray(d) && Helper.isRawDataSeries(d[0]);\n    }\n\n    static isRawDataSeries(d: any): boolean {\n        return Array.isArray(d) && !EncodingExecutor.isObject(d[0]);\n    }\n\n    static isRawDataPoint(d: any): boolean {\n        return !EncodingExecutor.isObject(d);\n    }\n\n    static dataPrimitiveFromRaw(d: any): IDimension {\n        if (Helper.isRawDataFrame(d)) {\n            return DataFrame.fromRaw(d);\n        } else if (Helper.isRawDataSeries(d)) {\n            return DataSeries.fromRaw(d);\n        } else if (Helper.isRawDataPoint(d)) {\n            return DataPoint.fromRaw(d);\n        } else {\n            throw new Error(`raw value does not resemble DataFrame, DataSeries, or DataPoint`);\n        }\n    }\n}\n","import { SetColorChannel } from './formatters/SetColorChannel';\nimport { Prefix } from './formatters/Prefix';\nimport { MatchValue } from './formatters/MatchValue';\nimport { RangeValue } from './formatters/RangeValue';\nimport { Gradient } from './formatters/Gradient';\nimport { Pick } from './formatters/Pick';\nimport { Type } from './formatters/Type';\nimport { FormatByType } from './formatters/FormatByType';\nimport { Frame } from './formatters/Frame';\nimport { Prepend } from './formatters/Prepend';\nimport { Objects } from './formatters/Objects';\nimport { MultiFormat } from './formatters/MultiFormat';\nimport { MaxContrast } from './formatters/MaxContrast';\nimport { RenameSeries } from './formatters/RenameSeries';\n\nexport const formatterClasses: { [key: string]: any } = {\n    gradient: Gradient,\n    matchValue: MatchValue,\n    prefix: Prefix,\n    rangeValue: RangeValue,\n    pick: Pick,\n    multiFormat: MultiFormat,\n    type: Type,\n    formatByType: FormatByType,\n    frame: Frame,\n    prepend: Prepend,\n    objects: Objects,\n    setColorChannel: SetColorChannel,\n    maxContrast: MaxContrast,\n    renameSeries: RenameSeries,\n};\n","module.exports = require(\"nearley\");","// Generated automatically by nearley, version 2.19.5\n// http://github.com/Hardmath123/nearley\n(function () {\n    function id(x) {\n        return x[0];\n    }\n    var grammar = {\n        Lexer: undefined,\n        ParserRules: [\n            { name: '_$ebnf$1', symbols: [] },\n            {\n                name: '_$ebnf$1',\n                symbols: ['_$ebnf$1', 'wschar'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: '_',\n                symbols: ['_$ebnf$1'],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            { name: '__$ebnf$1', symbols: ['wschar'] },\n            {\n                name: '__$ebnf$1',\n                symbols: ['__$ebnf$1', 'wschar'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: '__',\n                symbols: ['__$ebnf$1'],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            { name: 'wschar', symbols: [/[ \\t\\n\\v\\f]/], postprocess: id },\n            { name: 'dqstring$ebnf$1', symbols: [] },\n            {\n                name: 'dqstring$ebnf$1',\n                symbols: ['dqstring$ebnf$1', 'dstrchar'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'dqstring',\n                symbols: [{ literal: '\"' }, 'dqstring$ebnf$1', { literal: '\"' }],\n                postprocess: function (d) {\n                    return d[1].join('');\n                },\n            },\n            { name: 'sqstring$ebnf$1', symbols: [] },\n            {\n                name: 'sqstring$ebnf$1',\n                symbols: ['sqstring$ebnf$1', 'sstrchar'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'sqstring',\n                symbols: [{ literal: \"'\" }, 'sqstring$ebnf$1', { literal: \"'\" }],\n                postprocess: function (d) {\n                    return d[1].join('');\n                },\n            },\n            { name: 'btstring$ebnf$1', symbols: [] },\n            {\n                name: 'btstring$ebnf$1',\n                symbols: ['btstring$ebnf$1', /[^`]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'btstring',\n                symbols: [{ literal: '`' }, 'btstring$ebnf$1', { literal: '`' }],\n                postprocess: function (d) {\n                    return d[1].join('');\n                },\n            },\n            { name: 'dstrchar', symbols: [/[^\\\\\"\\n]/], postprocess: id },\n            {\n                name: 'dstrchar',\n                symbols: [{ literal: '\\\\' }, 'strescape'],\n                postprocess: function (d) {\n                    return JSON.parse('\"' + d.join('') + '\"');\n                },\n            },\n            { name: 'sstrchar', symbols: [/[^\\\\'\\n]/], postprocess: id },\n            {\n                name: 'sstrchar',\n                symbols: [{ literal: '\\\\' }, 'strescape'],\n                postprocess: function (d) {\n                    return JSON.parse('\"' + d.join('') + '\"');\n                },\n            },\n            {\n                name: 'sstrchar$string$1',\n                symbols: [{ literal: '\\\\' }, { literal: \"'\" }],\n                postprocess: function joiner(d) {\n                    return d.join('');\n                },\n            },\n            {\n                name: 'sstrchar',\n                symbols: ['sstrchar$string$1'],\n                postprocess: function (d) {\n                    return \"'\";\n                },\n            },\n            { name: 'strescape', symbols: [/[\"\\\\\\/bfnrt]/], postprocess: id },\n            {\n                name: 'strescape',\n                symbols: [{ literal: 'u' }, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/],\n                postprocess: function (d) {\n                    return d.join('');\n                },\n            },\n            { name: 'unsigned_int$ebnf$1', symbols: [/[0-9]/] },\n            {\n                name: 'unsigned_int$ebnf$1',\n                symbols: ['unsigned_int$ebnf$1', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'unsigned_int',\n                symbols: ['unsigned_int$ebnf$1'],\n                postprocess: function (d) {\n                    return parseInt(d[0].join(''));\n                },\n            },\n            { name: 'int$ebnf$1$subexpression$1', symbols: [{ literal: '-' }] },\n            { name: 'int$ebnf$1$subexpression$1', symbols: [{ literal: '+' }] },\n            { name: 'int$ebnf$1', symbols: ['int$ebnf$1$subexpression$1'], postprocess: id },\n            {\n                name: 'int$ebnf$1',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            { name: 'int$ebnf$2', symbols: [/[0-9]/] },\n            {\n                name: 'int$ebnf$2',\n                symbols: ['int$ebnf$2', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'int',\n                symbols: ['int$ebnf$1', 'int$ebnf$2'],\n                postprocess: function (d) {\n                    if (d[0]) {\n                        return parseInt(d[0][0] + d[1].join(''));\n                    } else {\n                        return parseInt(d[1].join(''));\n                    }\n                },\n            },\n            { name: 'unsigned_decimal$ebnf$1', symbols: [/[0-9]/] },\n            {\n                name: 'unsigned_decimal$ebnf$1',\n                symbols: ['unsigned_decimal$ebnf$1', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            { name: 'unsigned_decimal$ebnf$2$subexpression$1$ebnf$1', symbols: [/[0-9]/] },\n            {\n                name: 'unsigned_decimal$ebnf$2$subexpression$1$ebnf$1',\n                symbols: ['unsigned_decimal$ebnf$2$subexpression$1$ebnf$1', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'unsigned_decimal$ebnf$2$subexpression$1',\n                symbols: [{ literal: '.' }, 'unsigned_decimal$ebnf$2$subexpression$1$ebnf$1'],\n            },\n            {\n                name: 'unsigned_decimal$ebnf$2',\n                symbols: ['unsigned_decimal$ebnf$2$subexpression$1'],\n                postprocess: id,\n            },\n            {\n                name: 'unsigned_decimal$ebnf$2',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            {\n                name: 'unsigned_decimal',\n                symbols: ['unsigned_decimal$ebnf$1', 'unsigned_decimal$ebnf$2'],\n                postprocess: function (d) {\n                    return parseFloat(d[0].join('') + (d[1] ? '.' + d[1][1].join('') : ''));\n                },\n            },\n            { name: 'decimal$ebnf$1', symbols: [{ literal: '-' }], postprocess: id },\n            {\n                name: 'decimal$ebnf$1',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            { name: 'decimal$ebnf$2', symbols: [/[0-9]/] },\n            {\n                name: 'decimal$ebnf$2',\n                symbols: ['decimal$ebnf$2', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            { name: 'decimal$ebnf$3$subexpression$1$ebnf$1', symbols: [/[0-9]/] },\n            {\n                name: 'decimal$ebnf$3$subexpression$1$ebnf$1',\n                symbols: ['decimal$ebnf$3$subexpression$1$ebnf$1', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'decimal$ebnf$3$subexpression$1',\n                symbols: [{ literal: '.' }, 'decimal$ebnf$3$subexpression$1$ebnf$1'],\n            },\n            { name: 'decimal$ebnf$3', symbols: ['decimal$ebnf$3$subexpression$1'], postprocess: id },\n            {\n                name: 'decimal$ebnf$3',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            {\n                name: 'decimal',\n                symbols: ['decimal$ebnf$1', 'decimal$ebnf$2', 'decimal$ebnf$3'],\n                postprocess: function (d) {\n                    return parseFloat((d[0] || '') + d[1].join('') + (d[2] ? '.' + d[2][1].join('') : ''));\n                },\n            },\n            {\n                name: 'percentage',\n                symbols: ['decimal', { literal: '%' }],\n                postprocess: function (d) {\n                    return d[0] / 100;\n                },\n            },\n            { name: 'jsonfloat$ebnf$1', symbols: [{ literal: '-' }], postprocess: id },\n            {\n                name: 'jsonfloat$ebnf$1',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            { name: 'jsonfloat$ebnf$2', symbols: [/[0-9]/] },\n            {\n                name: 'jsonfloat$ebnf$2',\n                symbols: ['jsonfloat$ebnf$2', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            { name: 'jsonfloat$ebnf$3$subexpression$1$ebnf$1', symbols: [/[0-9]/] },\n            {\n                name: 'jsonfloat$ebnf$3$subexpression$1$ebnf$1',\n                symbols: ['jsonfloat$ebnf$3$subexpression$1$ebnf$1', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'jsonfloat$ebnf$3$subexpression$1',\n                symbols: [{ literal: '.' }, 'jsonfloat$ebnf$3$subexpression$1$ebnf$1'],\n            },\n            { name: 'jsonfloat$ebnf$3', symbols: ['jsonfloat$ebnf$3$subexpression$1'], postprocess: id },\n            {\n                name: 'jsonfloat$ebnf$3',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            { name: 'jsonfloat$ebnf$4$subexpression$1$ebnf$1', symbols: [/[+-]/], postprocess: id },\n            {\n                name: 'jsonfloat$ebnf$4$subexpression$1$ebnf$1',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            { name: 'jsonfloat$ebnf$4$subexpression$1$ebnf$2', symbols: [/[0-9]/] },\n            {\n                name: 'jsonfloat$ebnf$4$subexpression$1$ebnf$2',\n                symbols: ['jsonfloat$ebnf$4$subexpression$1$ebnf$2', /[0-9]/],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'jsonfloat$ebnf$4$subexpression$1',\n                symbols: [\n                    /[eE]/,\n                    'jsonfloat$ebnf$4$subexpression$1$ebnf$1',\n                    'jsonfloat$ebnf$4$subexpression$1$ebnf$2',\n                ],\n            },\n            { name: 'jsonfloat$ebnf$4', symbols: ['jsonfloat$ebnf$4$subexpression$1'], postprocess: id },\n            {\n                name: 'jsonfloat$ebnf$4',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            {\n                name: 'jsonfloat',\n                symbols: ['jsonfloat$ebnf$1', 'jsonfloat$ebnf$2', 'jsonfloat$ebnf$3', 'jsonfloat$ebnf$4'],\n                postprocess: function (d) {\n                    return parseFloat(\n                        (d[0] || '') +\n                            d[1].join('') +\n                            (d[2] ? '.' + d[2][1].join('') : '') +\n                            (d[3] ? 'e' + (d[3][1] || '+') + d[3][2].join('') : '')\n                    );\n                },\n            },\n            { name: 'Pipeline$ebnf$1', symbols: [] },\n            { name: 'Pipeline$ebnf$1$subexpression$1', symbols: [{ literal: '|' }, 'Expr'] },\n            {\n                name: 'Pipeline$ebnf$1',\n                symbols: ['Pipeline$ebnf$1', 'Pipeline$ebnf$1$subexpression$1'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'Pipeline',\n                symbols: ['Expr', 'Pipeline$ebnf$1'],\n                postprocess: d => {\n                    return [d[0], ...d[1].map(e => e[1])];\n                },\n            },\n            { name: 'Expr', symbols: ['_', 'Identifier', '_'], postprocess: d => d[1] },\n            { name: 'Expr', symbols: ['_', 'Method', '_'], postprocess: d => d[1] },\n            { name: 'Expr', symbols: ['_', 'Literal', '_'], postprocess: d => d[1] },\n            { name: 'Method$ebnf$1', symbols: ['Arg'], postprocess: id },\n            {\n                name: 'Method$ebnf$1',\n                symbols: [],\n                postprocess: function (d) {\n                    return null;\n                },\n            },\n            { name: 'Method$ebnf$2', symbols: [] },\n            { name: 'Method$ebnf$2$subexpression$1', symbols: ['_', { literal: ',' }, '_', 'Arg'] },\n            {\n                name: 'Method$ebnf$2',\n                symbols: ['Method$ebnf$2', 'Method$ebnf$2$subexpression$1'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'Method',\n                symbols: [\n                    'Identifier',\n                    { literal: '(' },\n                    '_',\n                    'Method$ebnf$1',\n                    'Method$ebnf$2',\n                    '_',\n                    { literal: ')' },\n                ],\n                postprocess: d => {\n                    let arg0 = d[3];\n                    let otherArgs = d[4];\n                    let args = [];\n                    arg0 && args.push(arg0);\n                    if (otherArgs) {\n                        args = args.concat(otherArgs.map(e => e[3]));\n                    }\n                    let r = { type: 'method', name: d[0].v, args };\n                    return r;\n                },\n            },\n            { name: 'Arg', symbols: ['Identifier'], postprocess: d => d[0] },\n            { name: 'Arg', symbols: ['Literal'], postprocess: d => d[0] },\n            { name: 'Identifier$ebnf$1', symbols: [] },\n            { name: 'Identifier$ebnf$1$subexpression$1', symbols: ['Letter'] },\n            { name: 'Identifier$ebnf$1$subexpression$1', symbols: ['Digit'] },\n            {\n                name: 'Identifier$ebnf$1',\n                symbols: ['Identifier$ebnf$1', 'Identifier$ebnf$1$subexpression$1'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'Identifier',\n                symbols: ['Letter', 'Identifier$ebnf$1'],\n                postprocess: d => {\n                    return { type: 'identifier', v: d[0] + d[1].join('') };\n                },\n            },\n            { name: 'Identifier$ebnf$2', symbols: [] },\n            { name: 'Identifier$ebnf$2$subexpression$1', symbols: ['Letter'] },\n            { name: 'Identifier$ebnf$2$subexpression$1', symbols: ['Digit'] },\n            {\n                name: 'Identifier$ebnf$2',\n                symbols: ['Identifier$ebnf$2', 'Identifier$ebnf$2$subexpression$1'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            { name: 'Identifier$ebnf$3$subexpression$1$ebnf$1', symbols: [] },\n            { name: 'Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1', symbols: ['Letter'] },\n            { name: 'Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1', symbols: ['Digit'] },\n            {\n                name: 'Identifier$ebnf$3$subexpression$1$ebnf$1',\n                symbols: [\n                    'Identifier$ebnf$3$subexpression$1$ebnf$1',\n                    'Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1',\n                ],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'Identifier$ebnf$3$subexpression$1',\n                symbols: ['Dot', 'Letter', 'Identifier$ebnf$3$subexpression$1$ebnf$1'],\n            },\n            { name: 'Identifier$ebnf$3', symbols: ['Identifier$ebnf$3$subexpression$1'] },\n            { name: 'Identifier$ebnf$3$subexpression$2$ebnf$1', symbols: [] },\n            { name: 'Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1', symbols: ['Letter'] },\n            { name: 'Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1', symbols: ['Digit'] },\n            {\n                name: 'Identifier$ebnf$3$subexpression$2$ebnf$1',\n                symbols: [\n                    'Identifier$ebnf$3$subexpression$2$ebnf$1',\n                    'Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1',\n                ],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'Identifier$ebnf$3$subexpression$2',\n                symbols: ['Dot', 'Letter', 'Identifier$ebnf$3$subexpression$2$ebnf$1'],\n            },\n            {\n                name: 'Identifier$ebnf$3',\n                symbols: ['Identifier$ebnf$3', 'Identifier$ebnf$3$subexpression$2'],\n                postprocess: function arrpush(d) {\n                    return d[0].concat([d[1]]);\n                },\n            },\n            {\n                name: 'Identifier',\n                symbols: ['Letter', 'Identifier$ebnf$2', 'Identifier$ebnf$3'],\n                postprocess: d => {\n                    function flat(input, depth = 1, stack = []) {\n                        for (let item of input) {\n                            if (item instanceof Array && depth > 0) {\n                                flat(item, depth - 1, stack);\n                            } else {\n                                stack.push(item);\n                            }\n                        }\n                        return stack;\n                    }\n                    const r = flat(d, Infinity);\n                    return { type: 'identifier', v: r.join('') };\n                },\n            },\n            {\n                name: 'Literal',\n                symbols: ['jsonfloat'],\n                postprocess: d => {\n                    return { type: 'number', v: d[0] };\n                },\n            },\n            {\n                name: 'Literal',\n                symbols: ['dqstring'],\n                postprocess: d => {\n                    return { type: 'string', v: d[0] };\n                },\n            },\n            {\n                name: 'Literal',\n                symbols: ['sqstring'],\n                postprocess: d => {\n                    return { type: 'string', v: d[0] };\n                },\n            },\n            {\n                name: 'Literal',\n                symbols: ['btstring'],\n                postprocess: d => {\n                    return { type: 'string', v: d[0] };\n                },\n            },\n            { name: 'Letter', symbols: [/[a-zA-Z_]/], postprocess: d => d[0] },\n            { name: 'Digit', symbols: [/[0-9]/], postprocess: d => d[0] },\n            { name: 'Dot', symbols: [/[\\.]/], postprocess: d => d[0] },\n        ],\n        ParserStart: 'Pipeline',\n    };\n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n        module.exports = grammar;\n    } else {\n        window.grammar = grammar;\n    }\n})();\n","module.exports = require(\"@babel/runtime/helpers/construct\");","import { DataType } from '../DataPrimitive';\nimport { isNumber } from './types';\n\n/*\n * @method setDefaultValue\n * @param {DataType} defaultValue\n * @returns {DataType} valid default value\n */\nexport const setDefaultValue = (defaultValue): DataType => {\n    if (isNumber(defaultValue)) {\n        return defaultValue;\n    }\n    return defaultValue || '';\n};\n","import { Context } from './Encoding';\n\nexport type Option = string | number | boolean | Record<string, any>;\nexport interface OptionsStanza {\n    options: { [key: string]: Option };\n    context: { [key: string]: Option };\n}\n\nexport interface OptionsAST {\n    expressions: { [key: string]: Expr[] };\n    simpleOptions: { [key: string]: Option };\n    context: { [key: string]: Option };\n}\n\n/**\n * Notice that the AST has an identical top-level structure to the Encoding. This is because ALL the AST does\n * is parse the DSL expressions, and represent them as Field objects. An AST will look like\n * Example:\n *  {\n *    context:{\n *        gradientContext:[\"red\", \"yellow\", \"green\"]\n *\n *    },\n *\n *    fields:{\n *        field1:{\n *            value:[{op:\"selectByPosition\", args:[\"FIRST\"]},{op:\"expects\", args:[\"NUMERIC\"]}]\n *        },\n *        field2:{\n *            value:[{op:\"selectByPosition\", args:[\"SECOND\"]},{op:\"expects\", args:[\"NUMERIC\"]}],\n *            computed:{\n *                color:[{op:\"gradient\", args:[\"gradientContext\"]},{op:\"toRgb\", args:[]}],\n *                smell: [{op:\"odor\", args:[\"'delicious\"]}]\n *            }\n *        }\n *\n *    }\n *\n *  }\n *\n *  So, ALL that happened is we converted DSL which is pipe-separated method calls into arrays of operations\n *  (ops) and their arguments. Other than that the AST is the same as Encoding. Which of course makes perfect\n *  sense because by definition an AST is simply a way to structure the information in a DSL.\n */\nexport interface AST {\n    dimensions: { [key: string]: Dimension };\n    context: { [key: string]: Context };\n}\n\nexport interface DimensionEncoding {\n    value: ExpressionDSL; // expression for selecting the value\n}\n\nexport type ExpressionDSL = string;\n\nexport interface Dimension {\n    value: Expr[];\n}\n\nexport type Expr = Method | ParserSymbol;\n\nexport interface Method {\n    type: 'method';\n    name: string;\n    args: ParserSymbol[];\n}\n\nexport interface ParserSymbol {\n    type: 'number' | 'string' | 'identifier';\n    v: number | string;\n}\n\nexport interface LiteralSymbol {\n    type: 'number' | 'string';\n    v: number | string;\n}\n\nexport const LITERAL_TYPES = ['number', 'string'];\n","import { Encoding } from './Encoding';\nimport { AST, Dimension, DimensionEncoding, OptionsStanza, OptionsAST } from './AST';\nimport { DslParser } from './DslParser';\n\nexport default class EncodingParser {\n    static parseOptions(optionsStanza: OptionsStanza): OptionsAST {\n        const optionsAST: OptionsAST = { simpleOptions: {}, expressions: {}, context: optionsStanza.context }; // context is just passed along\n        const { options } = optionsStanza;\n        Object.keys(options).forEach(k => {\n            const v = options[k];\n            if (EncodingParser.isDslString(v)) {\n                optionsAST.expressions[k] = DslParser.parse(EncodingParser.withoutArrow(v));\n            } else {\n                optionsAST.simpleOptions[k] = v; // things that are not expressions just pass through\n            }\n        });\n        return optionsAST;\n    }\n\n    static isDslString(s: any): boolean {\n        return s ? s.toString().trim().startsWith('>') : false;\n    }\n\n    static withoutArrow(s: any): string {\n        return s\n            .toString()\n            .match(/\\s*>\\s*(.+$)/)[1]\n            .trim();\n    }\n\n    static parse(encoding: Encoding): AST {\n        const { dimensions: dslFields, context } = encoding;\n        const ast: AST = { dimensions: {}, context }; //this is what we will populate and return\n\n        Object.keys(dslFields).forEach((f: string) => {\n            const astDimension: Dimension = { value: [] };\n            let value = null;\n            if (typeof dslFields[f] === 'string') {\n                value = dslFields[f];\n            } else {\n                const dim = dslFields[f] as DimensionEncoding;\n                value = dim.value;\n            }\n            astDimension.value = DslParser.parse(value);\n            ast.dimensions[f] = astDimension;\n        });\n        return ast;\n    }\n}\n","import { cloneDeep, get } from 'lodash';\nimport { Dimensions } from './Dimensions';\nimport EncodingExecutor, { Frames } from './EncodingExecutor';\nimport { DataPrimitive } from './DataPrimitive';\nimport { OptionsStanza } from './AST';\n\ntype ScopeName = 'literal' | 'context' | 'datasources' | 'themes' | 'options';\n\nexport interface ScopedValue {\n    location: ScopeName;\n    val: DataPrimitive;\n}\n\nexport class OptionScopes {\n    executedOptions: Record<string, unknown>; // gets populated by DSL evaluation\n    context: Record<string, unknown>; // also gets populated by DSL evaluation\n    frames: Frames; // the data sources\n    themeFunc: (themeVar) => any; // a function that must be provided, which resolves theme variables\n\n    private local: Record<string, any>[] = []; // unqualified identifiers can be resolved against local context. This is a stack of scopes.\n    private visitedPaths: Set<string> = new Set(); // Set of object paths we have visited (used for circular reference detection)\n\n    private static SCOPES = ['local', 'context', 'datasources', 'options', 'themes'];\n\n    constructor(optionsStanza: OptionsStanza, frames: Frames, themeFunc: (themeVar) => any) {\n        this.context = optionsStanza.context;\n        this.executedOptions = optionsStanza.options;\n        this.frames = frames;\n        this.themeFunc = themeFunc;\n        this.local.push(this.executedOptions); // Stack. local starts off pointing to top level options\n    }\n\n    resolve(identifier: string): ScopedValue {\n        const scopeParts = identifier.split('.');\n        let scopedValue: ScopedValue = null;\n        if (OptionScopes.isQualified(scopeParts)) {\n            scopedValue = this.resolveQualifiedIdentifier(scopeParts);\n        } else {\n            scopedValue = this.resolveUnqualifiedIdentifier(scopeParts);\n        }\n        return cloneDeep(scopedValue); // return defensive copy. Prevents targets of identifiers from getting mutated\n    }\n\n    private static isQualified(scopeParts: string[]): boolean {\n        const firstPart = scopeParts[0];\n        return OptionScopes.SCOPES.includes(firstPart);\n    }\n\n    private resolveUnqualifiedIdentifier(scopeParts: string[]): any {\n        //no qualifier has been given so we create qualified identifiers from all\n        //that point to all possible scopes\n        const qualifiers = OptionScopes.SCOPES;\n        let scopedValue: ScopedValue;\n        for (let i = 0; i < qualifiers.length; i += 1) {\n            const qualifiedIdentifier = [qualifiers[i], ...scopeParts];\n            scopedValue = this.resolveQualifiedIdentifier(qualifiedIdentifier);\n            if (scopedValue.val) {\n                break; //found it\n            }\n        }\n        return scopedValue;\n    }\n\n    private resolveQualifiedIdentifier(scopeParts: string[]): ScopedValue {\n        const qualifiedTargets = {\n            context: this.context,\n            options: this.executedOptions,\n            datasources: this.frames,\n            local: this.local[this.local.length - 1],\n        };\n        let val = null;\n        const location = scopeParts[0] as ScopeName;\n        if (location === 'themes' && this.themeFunc) {\n            //themes must be looked up in themeRegistry\n            const themeKey = scopeParts[1];\n            val = this.themeFunc(themeKey);\n        } else {\n            val = get(qualifiedTargets, scopeParts);\n            if (val) {\n                val = new EncodingExecutor().eval(val, this, scopeParts);\n            }\n        }\n        return { location, val };\n    }\n\n    public pushLocalScope(o: Record<string, unknown>) {\n        this.local.push(o);\n    }\n\n    public popLocalScope() {\n        this.local.pop();\n    }\n\n    addToVisitedList(path: string[]) {\n        const pathStr = path.join('.');\n        if (this.visitedPaths.has(pathStr)) {\n            throw new Error(\n                `Circular reference ${pathStr}, path history: ${new Array(...this.visitedPaths).toString()}`\n            );\n        }\n        this.visitedPaths.add(pathStr);\n    }\n\n    removeFromVisitedList(path: string[]) {\n        this.visitedPaths.delete(path.join('.'));\n    }\n}\n\nexport interface Scopes {\n    context: Record<string, unknown>;\n    vizDims: Dimensions;\n    frames: Frames;\n}\n","import * as chroma from 'chroma-js';\nimport { get } from 'lodash';\nimport { AbstractFormatter } from '../Formatter';\nimport { TypedValue } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\nimport EncodingExecutor from '../EncodingExecutor';\n\nexport interface SetColorChannelConfig {\n    channel: string;\n    value: string | number;\n}\n\n/**\n * SetColorChannel can be used to modify a given color.\n *\n * ```js\n * <SampleViz\n *     context={{\n *          rowBGConfig: {\n *              channel: 'hsl.l',\n *              value: '*0.2'\n *          },\n *          headerBackgroundColor: {\n *              channel: 'hsv.v',\n *              value: '*0.66'\n *          }\n *     }}\n *     options={{\n *         backgroundColor: 'orangered',\n *         rowBackgroundColor: '> backgroundColor | setColorChannel(rowBGConfig)',   // #330e00\n *         headerColor: '> backgroundColor | setColorChannel(headerColorConfig)',    // #a82e00\n *     }}\n *     dataSources={{\n *         primary: {\n *             data: {\n *                 fields: [{ name: 'foo' }]\n *                 columns: [[100, 200]]\n *             }\n *         }\n *     }}\n * />\n * ```\n * Leverages [Chromajs.set](https://gka.github.io/chroma.js/#color-set) to change the color\n * \n * ## Config Object\n *  * **channel**: 'string' refers to channel of the color. For ex: 'hsl.l' or 'hsl.s' or 'rgb.b'\n *  * **value**: 'string' or 'number'. Can be used to set absolute. For ex: setColorChannel({channel: 'hsl.h', value: 0}). Can be used as relative. For ex: setColorChannel({channel: 'lab.l', value: '*0.5'})\n\n *  \n */\nexport class SetColorChannel extends AbstractFormatter<'color', 'color'> {\n    private config: SetColorChannelConfig;\n    constructor(config: SetColorChannelConfig) {\n        super();\n        this.config = EncodingExecutor.rawTree(config);\n    }\n\n    protected formatTypedValue(p: DataPoint<'color'>): TypedValue<'color'> {\n        const { value, type } = p.getValue();\n        if (type !== 'color') {\n            return { type, value };\n        }\n        const channel = get(this, 'config.channel');\n        const v = get(this, 'config.value');\n        if (!channel || value == null) {\n            console.warn(\n                'SetColorChannel requires channel (ex: hsv.v, rgb.r) and value configuration to be set. It will return the same color when missing.'\n            );\n        }\n        try {\n            return {\n                type: 'color',\n                value: chroma(value.toString()).set(channel, v).hex(),\n            };\n        } catch (error) {\n            console.warn(error);\n            return { type: 'color', value };\n        }\n    }\n}\n","import { AbstractFormatter } from '../Formatter';\nimport { TypedValue } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\nimport EncodingExecutor from '../EncodingExecutor';\n\n/**\n * Prepends the given prefix (passed as a parameter) to the DataPoint.\n *\n * ```js\n * <SampleViz\n *     options={{\n *         textOption: '> primary | seriesByName(\"foo\") | lastPoint() | prefix(\"bar\")' // returns \"bar100\"\n *     }}\n *     dataSources={{\n *         primary: {\n *             data: {\n *                 fields: [{ name: 'foo' }]\n *                 columns: [[100, 200]]\n *             }\n *         }\n *     }}\n * />\n * ```\n */\nexport class Prefix extends AbstractFormatter<'string' | 'number', 'string'> {\n    private prefix: string;\n    constructor(prefix: any) {\n        super();\n        this.prefix = EncodingExecutor.rawTree(prefix);\n    }\n\n    protected formatTypedValue(p: DataPoint<'string' | 'number'>): TypedValue<'string'> {\n        const { value } = p.getValue();\n        const prefixedValue = this.prefix + value.toString();\n        return { value: prefixedValue, type: 'string' };\n    }\n}\n","import { isUndefined } from 'lodash';\nimport { find } from 'lodash';\nimport { getDataTypeForPoint } from '../utils/types';\nimport { setDefaultValue } from '../utils/formatterUtils';\nimport { AbstractFormatter } from '../Formatter';\nimport { TypedValue, DataType } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\nimport EncodingExecutor from '../EncodingExecutor';\n\ninterface MatchesConfig {\n    match: any;\n    value: any;\n}\n\n/**\n * Formatter that accepts a the list of potential matches and a defaultValue (if no match is found) as the config.\n *\n * It maps each element in the DataSeries to find a corresponding match valued and returns the matched value if found, or the defaultValue if present.\n * Otherwise if neither are present, it returns the original value.\n *\n * ```js\n * <SampleViz\n *     context={{\n *         colorMatches: [\n *             {\n *                 match: 500,\n *                 value: '#FF0000',\n *             },\n *             {\n *                 match: 750,\n *                 value: '#00FF00',\n *             },\n *         ],\n *     }}\n *     options={{\n *         colorOption: '> primary | seriesByIndex(0) | lastPoint() | matchValues(colorMatches, \"#0000FF\")' // returns #FF0000\n *         colorOption2: '> primary | seriesByIndex(1) | lastPoint() | matchValues(colorMatches, \"#0000FF\")' // returns #0000FF\n *     }}\n *     dataSources={{\n *         primary: {\n *             data: {\n *                 columns: [[100, 200, 300, 400, 500], [600, 700, 800, 900, 1000]]\n *                 fields: [{ name: 'foo' }, { name: 'bar' }],\n *             }\n *         }\n *     }}\n * />\n *\n *\n * @extends AbstractFormatter<DataType, DataType>\n */\nexport class MatchValue extends AbstractFormatter<DataType, DataType> {\n    private matches: MatchesConfig[];\n    private defaultValue: DataType;\n    constructor(matches: MatchesConfig[], defaultValue: any = undefined) {\n        super();\n        this.matches = EncodingExecutor.rawTree(matches);\n        this.defaultValue = setDefaultValue(defaultValue);\n    }\n    protected formatTypedValue(input: DataPoint): TypedValue<DataType> {\n        const { value } = input.getValue();\n        // if no match present, return defaultValue if present, otherwise return the original value\n        const defaultMatchValue = isUndefined(this.defaultValue) ? value : this.defaultValue;\n        const matchResult = find(this.matches, match => match.match && match.match === value);\n        const updatedValue = isUndefined(matchResult) ? defaultMatchValue : matchResult.value;\n        const updatedType = getDataTypeForPoint(updatedValue);\n        return { value: updatedValue, type: updatedType };\n    }\n}\n","import { isUndefined } from 'lodash';\nimport { AbstractFormatter } from '../Formatter';\nimport { TypedValue, DataType } from '../DataPrimitive';\nimport { getDataTypeForPoint, isNumber } from '../utils/types';\nimport { setDefaultValue } from '../utils/formatterUtils';\nimport { DataPoint } from '../DataPoint';\nimport EncodingExecutor from '../EncodingExecutor';\n\nexport interface RangesConfig {\n    from?: number;\n    value: any;\n    to?: number;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Formatter function that takes the list of ranges and a defaultValue (if no range is found)\n * and returns a function that takes a value and returns the range value if found, or the defaultValue if present.\n *\n * If neither are present, it returns the original value.\n *\n * The range fitting follows this criteria: `range.from <= value < range.to`\n *\n * A range can be defined as either a closed bound range: `{ from: 10, to: 20, value: 'foo' }`\n * or an open bound range:\n * `{ to: 20, value: 'bar' }` (open lower bound)\n * `{ from: 100, value: 'oof' }` (open upper bound)\n *\n * ```js\n *   <SampleViz\n *      context={{\n *          colorThresholds: [\n *              {\n *                  from: 1321,\n *                  value: '#00FFFF',\n *              },\n *              {\n *                  to: 1321,\n *                  value: '#FF00FF',\n *              },\n *          ],\n *      }}\n *      options={{\n *          valueOption: '> primary | seriesByIndex(0) | lastPoint()', // returns 103\n *          colorOption: '> deltaValue | rangeValue(colorThresholds)', // returns '#FF00FF'\n *      }}\n *      dataSources={{\n *          primary: {\n *              data: {\n *                  columns: [\n *                      ['1', '103'], ['2018-08-19T00:00:00.000+00:00', '2018-08-20T00:00:00.000+00:00'],\n *                  ],\n *                  fields: [{ name: 'foo', }, { name: '_time' }],\n *              }\n *          },\n *      }}\n *  />\n * ```\n * @extends AbstractFormatter<DataType, DataType>\n */\nexport class RangeValue extends AbstractFormatter<DataType, DataType> {\n    // although the typical usage is that the input is  number, this formatter DOES accept an DataType\n    private ranges: RangesConfig[];\n    private defaultValue: any;\n    constructor(ranges: RangesConfig[], defaultValue?: any) {\n        super();\n        this.ranges = EncodingExecutor.rawTree(ranges); //insure we can handle ranges that had DSL expressions shoved into them\n        this.defaultValue = setDefaultValue(defaultValue);\n    }\n    protected formatTypedValue(p: DataPoint<'number'>): TypedValue<DataType> {\n        const { type, value } = p.getValue();\n        if (type !== 'number') {\n            console.warn(`type '${type}' with value '${value}' is not a valid input to rangeValue`);\n        }\n        let rangeValueResult;\n        // if no range is found and valid value, return defaultValue if present, otherwise return the original value\n        const defaultRangeValue =\n            isUndefined(this.defaultValue) && !isNumber(value) ? value : this.defaultValue;\n        if (isNumber(value)) {\n            const floatValue = parseFloat(value);\n            for (let i = 0; i < this.ranges.length; i += 1) {\n                if (\n                    // open upper bound: value is bigger than or equal to open upper bound start (from)\n                    // if there are several 'from'-only ranges, we look at the first one that satisfies the mapping criteria\n                    // if there is overlap between a 'from'-only range and an inbetween range, this means that the ranges config is semantically invalid\n                    // TODO: figure out if we want to enforce a semantically valid config by sorting,\n                    // or by throwing an error if there are multiple 'from'/'to'-only ranges\n                    (hasOwnProperty.call(this.ranges[i], 'from') &&\n                        !hasOwnProperty.call(this.ranges[i], 'to') &&\n                        floatValue >= this.ranges[i].from) ||\n                    // inbetween: value falls into from (inclusive) - to (exclusive) range\n                    (floatValue >= this.ranges[i].from && floatValue < this.ranges[i].to) ||\n                    (hasOwnProperty.call(this.ranges[i], 'to') &&\n                        !hasOwnProperty.call(this.ranges[i], 'from') &&\n                        floatValue < this.ranges[i].to)\n                ) {\n                    rangeValueResult = this.ranges[i].value;\n                    break;\n                }\n            }\n        }\n        const updatedValue = isUndefined(rangeValueResult) ? defaultRangeValue : rangeValueResult;\n        const updatedType = getDataTypeForPoint(updatedValue);\n        return { type: updatedType, value: updatedValue };\n    }\n}\n","import * as chroma from 'chroma-js';\n\nimport { AbstractFormatter } from '../Formatter';\nimport { TypedValue } from '../DataPrimitive';\nimport { DataSeries } from '../DataSeries';\nimport { DataPoint } from '../DataPoint';\nimport EncodingExecutor from '../EncodingExecutor';\n\nexport interface GradientConfig {\n    stops?: number[];\n    colors: string[];\n}\n\n/**\n * Based on stops and colors, this formatter maps the value to an interpolated color.\n *\n * The `config` follows this criteria: `{ stops: [0, 100, 230], colors: ['red', 'green', 'blue'] }`\n *\n * If no config is specified, the default `colors` are `['rgba(123,86,219,0.4)', 'rgba(123,86,219,1)']`. The default `stops` are dependent on the DataSeries provided.\n * Given a DataSeries with n values, the stops would consist of [min, ...,  max]. The (n - 2) middle values are linearly interpolated via the minimum and maximum values of the series.\n *\n * For example, if 0 < value < 100, the corresponding interpolated color will be between red and green.\n *\n * ```js\n * <SampleViz\n *     context={{\n *         gradientConfig: { stops: [0, 100, 230], colors: ['red', 'green', 'blue'] }\n *     }}\n *     options={{\n *         colorOption: '> primary | seriesByIndex(0) | gradient(gradientConfig)' // it maps [0, 50, 230] to ['#FF0000', '#808000', '#0000FF']\n *     }}\n *     dataSources={{\n *         data: {\n *             primary: {\n *                 columns: [[0, 50, 230], [100, 50, 230]],\n *                 fields: [{ name: 'foo' }, { name: 'bar' }]\n *             }\n *         }\n *     }}\n * />\n * ```\n *\n * @extends AbstractFormatter<DataType, DataType>\n */\nexport class Gradient extends AbstractFormatter<'number', 'color'> {\n    private config: GradientConfig;\n\n    constructor(config?: GradientConfig) {\n        super();\n        this.config = EncodingExecutor.rawTree(config) || {};\n    }\n\n    protected formatTypedValue(p: DataPoint<'number'>, series: DataSeries): TypedValue<'color'> {\n        const input: TypedValue<'number'> = p.getValue();\n        const { type, value } = input;\n        if (type !== 'number') {\n            throw new Error(`type '${type}' with value '${value}' is not a valid input to gradient`);\n        }\n\n        // set default colors for gradient colors if colors not explicit\n        let colors = this.config.colors || ['rgba(123,86,219,0.4)', 'rgba(123,86,219,1)'];\n        let stops = this.config.stops || [];\n\n        if (colors.length === 1) {\n            colors = ['white', ...colors]; // force color bin to have a lower bound color\n        }\n\n        // auto gradient: set default color stops if stops not explicit\n        if (!stops.length) {\n            // no data values, so just make the range from zero to 1. If we try\n            // to gradient format a data point, it will be the case that it has\n            // no points\n            if (!series || !series.points || !series.points.length) {\n                stops = [0, 1];\n            } else {\n                const min = Number(series.min().getRawValue());\n                const max = Number(series.max().getRawValue());\n                stops.push(min);\n                for (let i = 1; i < colors.length - 1; i += 1) {\n                    stops.push(min + (i * (max - min)) / (colors.length - 1));\n                }\n                stops.push(max);\n            }\n\n            // Could not support auto gradient with more than two colors in gradient config without data.\n            if (stops.length !== colors.length) {\n                throw new Error(\n                    'Could not format gradient color. Please provide data or config stops in gradient formatting.'\n                );\n            }\n        } else if (stops.length === 1) {\n            stops.push(stops[0]); // force stops to be at least two values\n        }\n        stops.sort((a, b) => a - b); // force ascending order of color stops\n\n        if (stops.length !== colors.length) {\n            throw new Error('gradient stops and colors must have the same number of elements.');\n        }\n\n        let interpolateColor;\n        const isBeyondUpperBound = value > stops[stops.length - 1];\n        const isBeyondLowerBound = value < stops[0];\n        if (isBeyondUpperBound || isBeyondLowerBound) {\n            const index = isBeyondUpperBound ? stops.length - 1 : 0;\n            interpolateColor = chroma(colors[index]).hex().toUpperCase();\n            return { type: 'color', value: interpolateColor };\n        }\n\n        for (let i = 1; i < stops.length; i += 1) {\n            if (isNaN(stops[i])) {\n                // eslint-disable-next-line\n                console.warn(\n                    'Could not format gradient color: stops are required to be numbers. Falling back to first color.'\n                );\n                interpolateColor = chroma(colors[0]).hex().toUpperCase() || '#000';\n                return { type: 'color', value: interpolateColor };\n            }\n\n            const upperVal = stops[i];\n            if (value <= upperVal) {\n                const lowerVal = stops[i - 1];\n                let tau = 0;\n                // deal with special case when the upper and lower bounds of the colors are equal\n                if (upperVal === lowerVal) {\n                    // user prolly expects lower end of color stops if value is zero\n                    // otherwise use the upper bound\n                    tau = value === 0 ? 0 : 1;\n                } else {\n                    tau = (value - lowerVal) / (upperVal - lowerVal);\n                }\n                interpolateColor = chroma\n                    .scale([colors[i - 1], colors[i]])(tau)\n                    .hex()\n                    .toUpperCase();\n                return { type: 'color', value: interpolateColor };\n            }\n        }\n\n        // eslint-disable-next-line\n        console.warn(`Could not format value for gradient: ${value}`);\n        interpolateColor = chroma(colors[0]).hex().toUpperCase() || '#000';\n        return { type: 'color', value: interpolateColor };\n    }\n}\n","import { AbstractFormatter } from '../Formatter';\nimport { TypedValue } from '../DataPrimitive';\nimport { DataSeries } from '../DataSeries';\nimport { DataPoint } from '../DataPoint';\nimport { TypeSafeValue } from '../TypeSafeValue';\nimport EncodingExecutor from '../EncodingExecutor';\n\n/**\n * Formatter which can accept a map or array config.\n *\n * If a map is provided, it will use the DataPoint's field name to pick the corresponding entry in the config.\n *\n * If an array is provided, it cycles through the array of values passed in via the config n times (where n = DataSeries.length) and returns this as the output.\n *\n * For example, if the config contains 2 elements and the DataSeries contains 10 elements, it will loop through the config 5 times, alternating between which element is appended to the output.\n *\n * ```js\n * <SampleViz\n *     context={{\n *         mapConfig: {\n *             bar: 'barLabel',\n *             foo: 'fooLabel',\n *         },\n *         rowBackgroundColors: ['#FF0000', '#00FF00', '#0000FF'],\n *         rowTextColors: ['#110000', '#000011'],\n *     }}\n *     options={{\n *         rowBackgroundColor: '> primary | seriesByIndex(0) | pick(rowBackgroundColors)', // returns ['#FF0000', '#00FF00', '#0000FF', '#FF0000', '#0000FF']\n *         rowTextColor: '> primary | seriesByIndex(0) | pick(rowTextColors)', // returns ['#110000', '#000011', '#110000', '#000011', '#110000']\n *         barOption: '> primary | seriesByIndex(1) | lastPoint() | pick(mapConfig)', // returns 'barLabel'\n *         fooOption: '> primary | seriesByIndex(0) | lastPoint() | pick(mapConfig)', // returns 'fooLabel'\n *     }}\n *     dataSources={{\n *         primary: {\n *             data: {\n *                 columns: [[100, 200, 300, 400, 500], [600, 700, 800, 900, 1000]]\n *                 fields: [{ name: 'foo' }, { name: 'bar' }],\n *             }\n *         }\n *     }}\n * />\n * ```\n */\nexport class Pick extends AbstractFormatter {\n    private config: Record<string, unknown>;\n\n    constructor(formatConfig: any[] | { [key: string]: any }) {\n        super();\n        //insure that the config is plain old JS objects (does not have DataPrimitives inside it)\n        this.config = EncodingExecutor.rawTree(formatConfig);\n    }\n\n    protected formatTypedValue(p: DataPoint, s?: DataSeries, i = 0, j = 0): TypedValue {\n        let val;\n        if (Array.isArray(this.config)) {\n            val = this.config[j % this.config.length];\n        } else {\n            val = this.config[s.field];\n        }\n        return TypeSafeValue.fromRaw(val);\n    }\n}\n","import { AbstractFormatter } from '../Formatter';\nimport { DataType, TypedValue } from '../DataPrimitive';\nimport { DataSeries } from '../DataSeries';\nimport { TypeSafeValue } from '../TypeSafeValue';\nimport { DataPoint } from '../DataPoint';\n\n/**\n * Formatter that returns the DataType for each element within the given DataSeries.\n *\n * ```js\n * <SampleViz\n *     options={{\n *         option1: '> primary | seriesByIndex(0) | type()' // returns ['number', 'number', 'number']\n *         option2: '> primary | seriesByIndex(1) | type()' // returns ['string', 'string', 'string']\n *     }}\n *     dataSources={{\n *         data: {\n *             primary: {\n *                 columns: [[100, 200, 300], ['string1', 'string2', 'string3']]\n *                 fields: [{ name: 'foo' }, { name: 'bar' }]\n *             }\n *         }\n *     }}\n * />\n * ```\n */\nexport class Type extends AbstractFormatter {\n    protected formatTypedValue(p: DataPoint<'number' | 'string'>): TypedValue<DataType> {\n        return TypeSafeValue.fromRaw(TypeSafeValue.fromRaw(p.getRawValue()).type);\n    }\n}\n","import { isEmpty, defaultsDeep, omit, omitBy, isUndefined } from 'lodash';\nimport numbro from 'numbro';\n// There is a mismatch between typedefinition of numbro and numbro export.\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst numbrofn = require('numbro');\nimport moment from '@splunk/moment';\n\nimport { AbstractFormatter } from '../Formatter';\nimport { DataType, TypedValue } from '../DataPrimitive';\nimport { TypeSafeValue } from '../TypeSafeValue';\nimport { DataPoint } from '../DataPoint';\n\nconst validUnitPositions = ['before', 'after'] as const;\ninterface NumberConfig extends numbro.Format {\n    unit?: string;\n    unitPosition?: typeof validUnitPositions[number];\n    precision?: number;\n}\n\ninterface StringConfig {\n    unit?: string;\n    unitPosition?: typeof validUnitPositions[number];\n}\n\ninterface TimeConfig {\n    format?: string;\n}\ninterface FormatByTypeConfig {\n    number: Partial<NumberConfig>;\n    string: Partial<StringConfig>;\n    time: Partial<TimeConfig>;\n}\n\nconst formatNumber = (number: number | string, config: NumberConfig): string => {\n    const mappedConfig = {\n        prefix: !isEmpty(config.unit) && config.unitPosition === 'before' ? `${config.unit} ` : undefined,\n        postfix: !isEmpty(config.unit) && config.unitPosition !== 'before' ? ` ${config.unit}` : undefined,\n        mantissa: typeof config.precision === 'number' ? config.precision : undefined,\n    };\n    const c: numbro.Format = defaultsDeep(\n        {},\n        omitBy(mappedConfig, isUndefined),\n        omit(config, ['unit', 'unitPosition', 'precision'])\n    );\n    return numbrofn(number).format(c);\n};\n\nconst formatString = (string: number | string, config: StringConfig): string => {\n    if (!isEmpty(config.unit)) {\n        return config.unitPosition === 'before' ? `${config.unit} ${string}` : `${string} ${config.unit}`;\n    }\n    return `${string}`;\n};\n\nconst timeToMoment = (time: any): typeof moment => {\n    // if splunk time zone is set, create time in splunk timezone and locale\n    if (moment.getDefaultSplunkTimezone()) {\n        return moment.newSplunkTime({ time: time.toString() });\n    }\n    // fallback to moment default\n    return moment(time);\n};\n\nconst formatTime = (dateObject: Date, defaultValue: number | string, config: TimeConfig): string => {\n    if (typeof config.format === 'string' && !isEmpty(config.format)) {\n        return timeToMoment(dateObject).format(config.format);\n    }\n    return defaultValue.toString();\n};\n\n/**\n * @class FormatByType\n * \n * Formats the value based on the value type and the provided config. For example \n * \n * ```js\n <Table\n    context = {{\n        formattedConfig: {\n            number: {\n                unit: '$',\n                unitPosition: 'before',\n                precision: 2,\n                thousandSeparated: true,\n            },\n        },\n    }}\n\n    options = {{\n        columnFormat: {\n            formatted: {\n                data: '> table | seriesByName(\"formatted\") | formatByType(formattedConfig)',\n            },\n        },\n    }}\n\n    dataSources = {{\n        primary: {\n            requestParams: { offset: 0, count: 20 },\n            data: {\n                fields: [\n                    { name: 'number' },\n                    { name: 'formatted' },\n                ],\n                columns: [\n                    [-927916.96, -924916.9, -654089.75],\n                    [-927916.96, -924916.9, -654089.75],\n                ],\n            },\n            meta: { totalCount: 100 },\n        },\n    }}\n />\n * ```\n *  \n *  ## Config Object\n * \n *  ### number\n * \n *  * **unit?**: `string` to be appended or prepended to the value\n *  * **unitPosition?**: `{\"before\" | \"after\"}` where should the `unit` be placed. Maps to numbro `prefix` or `postfix`\n *  * **numberPrecision?**: `number` maps to numbro `mantissa`\n *  * **mantissa?**: `number` number of decimal points to show\n *  * **trimMantissa?**: `boolean` ending 0s in decimal points will be trimmed\n *  * **thousandSeparated?**: `boolean` should show `,` for thousands\n *  * **output?**: `\"currency\" | \"percent\" | \"byte\" | \"time\" | \"ordinal\" | \"number\"` value will be converted to one of thse formats\n *  * **base?**: `\"decimal\" | \"binary\" | \"general\"` used for converting value to bytes\n *  * **prefix?**: `string` string to be added in front of the value\n *  * **postfix?**: `string` string to be appended to the value\n *  * **forceAverage?**: `\"trillion\" | \"billion\" | \"million\" | \"thousand\"` can be used to force one the selected average\n *  * **average?**: `boolean` rounds up the value to the closed average\n *  * **totalLength?**: `number` used only for `average`. The number length to format data in\n *  * **spaceSeparated?**: `boolean` used with `average` to introduce space between number and average\n *  * **abbreviations?**: `{\n        thousand?: string;\n        million?: string;\n        billion?: string;\n        trillion?: string;\n    }` abbreviation values for averages.\n *  * **negative?**: `\"sign\" | \"parenthesis\"` display sign or parenthesis for negative numbers\n *  * **forceSign?**: `boolean` always show + or - sign\n * \n * \n *  * For examples, refer [Numbro](https://numbrojs.com/format.html#format) or [tests](https://cd.splunkdev.com/devplat/vision/-/blob/main/packages/visualization-encoding/src/formatters/FormatByType.test.ts)\n * \n * #### time\n * \n *  * **format**: valid moment format string.  Refer - [moment display](https://momentjs.com/docs/#/displaying/)\n * \n * \n * \n \n */\nexport class FormatByType extends AbstractFormatter {\n    private config: FormatByTypeConfig = { number: {}, string: {}, time: { format: '' } };\n\n    constructor(config: Record<string, unknown>) {\n        super();\n        this.config = defaultsDeep({}, config, this.config);\n    }\n\n    protected formatTypedValue(p: DataPoint): TypedValue<DataType> {\n        const { number: numberConfig, string: stringConfig, time: timeConfig } = this.config;\n        const value = p.getValue();\n        switch (value.type) {\n            case 'number':\n                return new TypeSafeValue(\n                    'string',\n                    formatNumber(p.getRawValue(), numberConfig),\n                    true,\n                    value.originalValue\n                );\n            case 'string':\n                return new TypeSafeValue(\n                    'string',\n                    formatString(value.value, stringConfig),\n                    true,\n                    value.originalValue\n                );\n            case 'time':\n                return new TypeSafeValue(\n                    'string',\n                    formatTime(value.value, value.originalValue, timeConfig),\n                    true,\n                    value.originalValue\n                );\n            default:\n                return p.getValue();\n        }\n    }\n}\n","module.exports = require(\"numbro\");","import { AbstractFormatter, DataPrimitiveFormatter } from '../Formatter';\nimport { IDimension } from '../Dimensions';\nimport { DataFrame } from '../DataFrame';\nimport { DataSeries } from '../DataSeries';\nimport { DataType, isDataPrimitive, TypedValue } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\nimport { Helper } from './Helper';\nimport EncodingExecutor from '../EncodingExecutor';\n\n/**\n * This formatter returns a new DataFrame made by combining its arguments.\n *\n * Example: frame(series1, series2, frame1). It is also possible to pass\n * DataPoint as argument, in which case the DataPoint is wrapped in DataSeries.\n *\n * ```js\n * <SampleViz\n *     context={{\n *         users: '> primary | seriesByName(\"users\")',\n *         ids: '> primary | seriesByName(\"ids\")'\n *     }}\n *     options={{\n *         frameOption1: '> frame(users, ids)' // returns [['Maurine', 'Jennings', 'Giuseppe'], ['1', '2', '3']]\n *         frameOption2: '> frame(frameOption1, ids)' // returns [['Maurine', 'Jennings', 'Giuseppe'], ['1', '2', '3'], ['1', '2', '3']]\n *     }}\n *     dataSources={{\n *         primary: {\n *             data: {\n *                 columns: [['Maurine', 'Jennings', 'Giuseppe'], ['1', '2', '3']],\n *                 fields: [{ name: 'users' }, { name: 'ids' }]\n *             }\n *         }\n *     }}\n * />\n * ```\n */\nexport class Frame implements DataPrimitiveFormatter<DataType, DataType> {\n    private args: IDimension[] = [];\n\n    constructor(...args: any[]) {\n        //frame formatter must also support 'raw' coming form context so we rawTree as needed\n        this.args = args.map(a =>\n            isDataPrimitive(a) ? a : Helper.dataPrimitiveFromRaw(EncodingExecutor.rawTree(a))\n        );\n    }\n\n    format(p: DataPoint): DataPoint;\n    format(s: DataSeries): DataSeries;\n    format(f: DataFrame): DataFrame;\n    format(ignored: IDimension): IDimension {\n        let series = [];\n        this.args.forEach(dataPrim => {\n            if (DataSeries.isDataSeries(dataPrim)) {\n                series.push(dataPrim);\n            } else if (DataFrame.isDataFrame(dataPrim)) {\n                series = series.concat(dataPrim.series);\n            } else if (DataPoint.isDataPoint(dataPrim)) {\n                series.push(new DataSeries([dataPrim]));\n            } else {\n                throw new Error(`frame formatter args incorrect`);\n            }\n        });\n        return new DataFrame(series);\n    }\n}\n","import { DataPrimitiveFormatter } from '../Formatter';\nimport { DataPoint } from '../DataPoint';\nimport { DataType, isDataPrimitive } from '../DataPrimitive';\nimport { DataSeries } from '../DataSeries';\nimport { DataFrame } from '../DataFrame';\nimport { Helper } from './Helper';\nimport { IDimension } from '../Dimensions';\nimport EncodingExecutor from '../EncodingExecutor';\n\n/**\n * Formatter that prepends a DataFrame, DataSeries, or DataPoint to a pre-existing DataFrame or DataSeries with compatible types.\n *\n * If prepending a DataFrame to another DataFrame, the DataFrames must have the same number of DataSeries.\n * For example, a DataFrame with 3 series such as `[[1, 2], [3, 4], [5, 6]]` cannot be prepended to a DataFrame with 2 series such as `[[7, 8], [9, 10]]`.\n *\n * Only the same DataPrimitive type or a DataPrimitive's composite DataPrimitives\n * (e.g. DataSeries or DataPoint for DataFrame, or a DataPoint for a DataSeries) can be prepended to the pre-existing DataPrimitive.\n *\n * ```js\n * <SampleViz\n *     context={{\n *         staticUser: 'All users',\n *         staticId: '*',\n *         additionalUsers: ['Andrew', 'Chanelle'],\n *         idsAsNumbers: [1, 2],\n *         users: '> primary | seriesByName(\"users\") | prepend(staticUser)', // returns ['All users', 'Maurine', 'Jennings']\n *         ids: '> primary | seriesByName(\"ids\") | prepend(staticId)' // returns ['*', '1', '2', '3']\n *         pathologicalIds: '> primary | seriesByName(\"idsAsNumbers\") | prepend(staticId)' // throws an error, since `staticId` is a string, while the pre-existing series is composed of numbers\n *     }}\n *     options={{\n *         consolidatedUsers: '> primary | seriesByName(\"users\") | prepend(additionalUsers)', // returns ['Andrew', 'Chanelle', 'Maurine', 'Jennings']\n *         // returns {\n *         //     columns: [['Maurine', 'Jennings', 'Maurine', 'Jennings'], ['1', '2', '1', '2']]\n *         //     fields: [{ name: 'users' }, { name: 'ids' }]\n *         // }\n *         prependingFrames: '> primary | prepend(primary)'\n *     }}\n *     dataSources={{\n *         primary: {\n *             data: {\n *                 columns: [['Maurine', 'Jennings'], ['1', '2']],\n *                 fields: [{ name: 'users' }, { name: 'ids' }]\n *             }\n *         }\n *     }}\n * />\n * ```\n */\nexport class Prepend implements DataPrimitiveFormatter<DataType, DataType> {\n    private prependMe: IDimension;\n\n    constructor(d: any) {\n        //needs to be able to prepend DataPrimitive and raw\n        this.prependMe = isDataPrimitive(d) ? d : Helper.dataPrimitiveFromRaw(EncodingExecutor.rawTree(d));\n    }\n\n    format(\n        subject: DataPoint<DataType> | DataSeries<DataType> | DataFrame<DataType>\n    ): DataPoint<DataType> | DataSeries<DataType> | DataFrame<DataType> {\n        if (DataFrame.isDataFrame(subject)) {\n            return this.prependToFrame(subject);\n        }\n        if (DataSeries.isDataSeries(subject)) {\n            return this.prependToSeries(subject);\n        }\n        throw new Error(`Can only prepend to DataFrame or DataSeries`);\n    }\n\n    private prependToFrame(subject: DataFrame<DataType>) {\n        if (DataFrame.isDataFrame(this.prependMe)) {\n            return this.prependFrameToFrame(subject);\n        } else if (DataSeries.isDataSeries(this.prependMe)) {\n            return this.prependASeriesToEachSeriesOfFrame(subject);\n        } else if (DataPoint.isDataPoint(this.prependMe)) {\n            return this.prependAPointToEachSeriesOfFrame(subject);\n        }\n        throw new Error(`'prepend' formatter only accepts DataFrame, DataSeries, or DataPoint as argument`);\n    }\n\n    private prependToSeries(subject: DataSeries<DataType>) {\n        if (DataFrame.isDataFrame(this.prependMe)) {\n            throw new Error('cannot prepend a DataFrame to a DataSeries');\n        } else if (DataSeries.isDataSeries(this.prependMe)) {\n            return this.prependSeriesToSeries(subject, this.prependMe);\n        } else if (DataPoint.isDataPoint(this.prependMe)) {\n            return this.prependPointToSeries(subject);\n        }\n        throw new Error(`'prepend' to series formatter only DataSeries, or DataPoint as argument`);\n    }\n\n    private prependAPointToEachSeriesOfFrame(dp: DataFrame<DataType>): DataFrame {\n        return new DataFrame(dp.series.map(s => this.prependPointToSeries(s)));\n    }\n\n    private prependASeriesToEachSeriesOfFrame(frame: DataFrame<DataType>): DataFrame {\n        return new DataFrame(\n            frame.series.map(s => this.prependSeriesToSeries(s, this.prependMe as DataSeries))\n        );\n    }\n\n    private prependFrameToFrame(frame: DataFrame<DataType>): DataFrame {\n        const numSeries1 = (this.prependMe as DataFrame).series.length;\n        const numSeries2 = frame.series.length;\n        if (numSeries1 !== numSeries2) {\n            throw new Error(\n                `can't prepend a frame with ${numSeries1} columns to a field with ${numSeries2} columns`\n            );\n        }\n        return new DataFrame(\n            frame.series.map((s, i) =>\n                this.prependSeriesToSeries(s, (this.prependMe as DataFrame).seriesByIndex(i))\n            )\n        );\n    }\n\n    private prependSeriesToSeries(series: DataSeries, prependMe: DataSeries): DataSeries {\n        const field = series.field; //we will use this to insure the prepended series has the same field\n        const type1 = series.points.length > 0 ? series.points[0].getValue().type : undefined;\n        const type2 = prependMe.points.length > 0 ? prependMe.points[0].getValue().type : undefined;\n        if (type1 && type2 && type1 !== type2) {\n            throw new Error(`cannot prepend ${type2} to ${type1}`);\n        }\n        return new DataSeries(\n            prependMe.points.map(p => new DataPoint(field, p.getValue())).concat(series.points)\n        );\n    }\n\n    private prependPointToSeries(s: DataSeries): DataSeries {\n        const field = s.field;\n        const typedValue = s.firstPoint().getValue(); // we must use the existing series type for the prepended point\n        const type1 = typedValue.type;\n        const typedValue2 = (this.prependMe as DataPoint).getValue();\n        const type2 = typedValue2.type;\n        if (type1 !== type2) {\n            throw new Error(`cannot prepend point of type ${type2} to series of type ${type1}`);\n        }\n        const newPoint = new DataPoint(field, typedValue2);\n        return new DataSeries<DataType>([newPoint, ...s.points]);\n    }\n}\n","import { DataPrimitiveFormatter } from '../Formatter';\nimport { DataType } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\nimport { DataSeries } from '../DataSeries';\nimport { DataFrame } from '../DataFrame';\nimport { merge } from 'lodash';\nimport EncodingExecutor from '../EncodingExecutor';\n\ninterface ObjectConfig {\n    rename: { [key: string]: string };\n}\n\n/**\n * Formatter which converts a DataPrimitive into an array of objects. This is typically used in conjunction with UDF inputs.\n *\n * ```js\n * // UDF inputs\n * {\n *     \"inputs\": {\n *         \"input1\": {\n *             \"context\": {\n *                  \"staticOptions\": [[\"All Users\"], [\"*\"]],\n *                  \"field1\": \"> primary | seriesByName(\\\"users\\\") | renameSeries(\\\"label\\\")\",\n *                  \"field2\": \"> primary | seriesByName(\\\"ids\\\") | renameSeries(\\\"value\\\")\"\",\n *              },\n *              \"type\": \"input.multiselect\",\n *              \"options\": {\n *                  \"items\": \"> frame(field1, field2) | prepend(staticOptions) | objects()\"\n *                      // returns [\n *                      //     { label: 'All users', value: '*' },\n *                      //     { label: 'jane doe', value: 'jdoe' },\n *                      //     { label: 'joe schmo', value: 'jschmo' },\n *                      //     { label: 'jack schmidt', value: 'jschmidt' },\n *                      // ]\n *                  ]\n *              },\n *              \"dataSources\": {\n *                  \"primary\": {\n *                      \"data\": {\n *                          \"fields\": [{ \"name\": 'users' } , { \"name\": \"ids\" } ],\n *                          \"columns\": [[ \"jane doe\", \"joe schmo\", \"jack schmidt\"], [\"jdoe\", \"jschmo\", \"jschmidt\"]]\n *                      }\n *                  }\n *             },\n *         }\n *     }\n * }\n * ```\n */\nexport class Objects implements DataPrimitiveFormatter<DataType, DataType> {\n    private config: ObjectConfig;\n\n    constructor(objectConfig?: ObjectConfig) {\n        this.config = EncodingExecutor.rawTree(objectConfig);\n    }\n\n    format(dp: DataPoint<DataType> | DataSeries<DataType> | DataFrame<DataType>): Record<string, any> {\n        if (DataFrame.isDataFrame(dp)) {\n            const mergedObjectSeries = this.seriesToObjects(dp.series[0]);\n            for (let i = 1; i < dp.series.length; i += 1) {\n                const mergeMeIn = this.seriesToObjects(dp.series[i]);\n                for (let j = 0; j < mergedObjectSeries.length; j += 1) {\n                    mergedObjectSeries[j] = merge(mergedObjectSeries[j], mergeMeIn[j]);\n                }\n            }\n            return mergedObjectSeries;\n        } else if (DataSeries.isDataSeries(dp)) {\n            return this.seriesToObjects(dp);\n        } else if (DataPoint.isDataPoint(dp)) {\n            return [{ [dp.field]: dp.getRawValue() }];\n        } else {\n            throw new Error(`'objects' formatter only allowed on DataFrame, DataPoint, or DataSeries`);\n        }\n    }\n\n    private seriesToObjects(s: DataSeries): Record<string, unknown>[] {\n        return s.points.reduce((acc, pt) => {\n            let key = pt.field;\n            if (this.config && this.config.rename) {\n                key = this.config.rename[key] || key;\n            }\n            acc.push({ [key]: pt.getRawValue() });\n            return acc;\n        }, []);\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/defineProperty\");","import { DataPrimitiveFormatter } from '../Formatter';\nimport { DataType } from '../DataPrimitive';\nimport { DataFrame } from '../DataFrame';\nimport { formatterClasses } from '../FormatterPresets';\n\nimport EncodingExecutor from '../EncodingExecutor';\n\ninterface FormatterMapConfig {\n    nameField: string;\n    valueField: string;\n    formatters: {\n        [key: string]: {\n            type: string;\n            config: Record<string, any>;\n        };\n    };\n}\n\n/**\n * Formatter which accepts a config object containing a map of field-specific formatters.\n * The field-specific formatter is used to evaluate each fields' corresponding values.\n *\n * The three required fields are as follows:\n *\n * - `nameField`, which denotes the list of keys with custom formatters to be applied against\n *\n * - `valueField`, which denotes the field to derive the values from\n *\n * - `formatter1. which is an object that requires the `type` of formatter and the specific required for the specified formatter.\n *\n * ```js\n *     <ChoroplethSvg\n *         context={{\n *             areaColorsFormat: {\n *                 nameField: 'pathIds',\n *                 valueField: 'values',\n *                 formatters: {\n *                     id1: {\n *                         type: 'matchValue',\n *                         config: [{\n *                             match: 100,\n *                             value: '#FF0000'\n *                         }]\n *                     },\n *                     id2: {\n *                         type: 'rangeValue',\n *                         config: [\n *                             {\n *                                 to: 100,\n *                                 value: '#00FF00'\n *                             }\n *                             {\n *                                 from: 100,\n *                                 value: '#0000FF'\n *                             }\n *                         ]\n *                     }\n *                 }\n *             }\n *         }}\n *         options={{\n *             areaIds: '> primary | seriesByName(\"pathIds\")', // returns ['id1', 'id2']\n *             areaValues: '> primary | seriesByName(\"values\")', // returns [100, 200]\n *             areaColors: '> primary | multiFormat(areaColorsFormat)' // returns ['#FF0000', '#0000FF']\n *         }}\n *         dataSources={{\n *             primary: {\n *                 data: {\n *                     columns: [['id1', 'id2'], [100, 200]]\n *                     fields: [{ name: 'pathIds' }, { name: 'values' }]\n *                 }\n *             }\n *         }}\n *     />\n * ```\n *\n */\nexport class MultiFormat implements DataPrimitiveFormatter<DataType, DataType> {\n    private config: FormatterMapConfig;\n\n    constructor(formatConfig: FormatterMapConfig) {\n        this.config = EncodingExecutor.rawTree(formatConfig);\n    }\n\n    format(f: DataFrame<DataType>): Record<string, any> {\n        const namesDataSeries = f.seriesByName(this.config.nameField);\n        const valuesDataSeries = f.seriesByName(this.config.valueField);\n\n        // choroplethSVG expects that the names and values are of the same length\n        // otherwise there would be no way to map an areaId with an areaValue\n        return namesDataSeries.points.map((name, i) => {\n            const { type, config } = this.config.formatters[name.getRawValue()];\n            const formatterClass = formatterClasses[type] as any;\n            const value = valuesDataSeries.pointByIndex(i);\n            if (!formatterClass) {\n                throw new Error(`unknown formatter type \"${type}\" was specified`);\n            }\n            return new formatterClass(config).format(value, valuesDataSeries);\n        });\n    }\n}\n","import * as chroma from 'chroma-js';\nimport { chain, get } from 'lodash';\nimport { AbstractFormatter } from '../Formatter';\nimport { TypedValue } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\nimport EncodingExecutor from '../EncodingExecutor';\nimport { isColor } from '@splunk/visualizations-shared/colorUtils';\n\nexport interface MaxContrastConfig {\n    colors: string[];\n    default?: string;\n}\n\n/**\n * MaxContrast can be used to pick the color with maxContrast.\n *\n * ```js\n * <SampleViz\n *     context={{\n *          contrastConfig: {\n *              colors: ['white', 'black']\n *          }\n *     }}\n *     options={{\n *         color1: 'green',\n *         maxContrastOfColor1: '> color1 | maxContrast(contrastConfig)',    // white\n *         color2: 'gray'\n *         maxContrastOfColor2: '> color2 | maxContrast(contrastConfig)',    // black\n *     }}\n *     dataSources={{\n *         primary: {\n *             data: {\n *                 fields: [{ name: 'foo' }]\n *                 columns: [[100, 200]]\n *             }\n *         }\n *     }}\n * />\n * ```\n * Leverages [Chromajs.contrast](https://gka.github.io/chroma.js/#chroma-contrast) to determine contrast between color and values\n *\n * ## Config Object\n *  * **colors**: 'string[]' array of colors to compare contrast against\n *  * **default**: 'string' default color if no colors or the contrast is not found\n *\n */\nexport class MaxContrast extends AbstractFormatter<'color', 'color'> {\n    private config: MaxContrastConfig;\n    constructor(config?: MaxContrastConfig) {\n        super();\n        this.config = EncodingExecutor.rawTree(config);\n    }\n\n    protected formatTypedValue(p: DataPoint<'color'>): TypedValue<'color'> {\n        const { value, type } = p.getValue();\n        if (type !== 'color' || !isColor(value)) {\n            return { type, value };\n        }\n\n        const colorConfig = get(this, 'config.colors');\n        const defaultColor = get(this, 'config.default');\n\n        if (!Array.isArray(colorConfig) || colorConfig.length === 0) {\n            return isColor(defaultColor) ? { type: 'color', value: defaultColor } : { type, value };\n        }\n\n        if (value === 'transparent' && isColor(defaultColor)) {\n            return { type: 'color', value: defaultColor };\n        }\n\n        try {\n            return {\n                type: 'color',\n                value: chain(colorConfig)\n                    .map(c => ({ color: c, contrast: chroma.contrast(value, c) }))\n                    .maxBy('contrast')\n                    .value().color,\n            };\n        } catch (error) {\n            console.warn(error);\n            return { type: 'color', value: defaultColor || value };\n        }\n    }\n}\n","import { DataSeries } from '../DataSeries';\nimport { DataPoint } from '../DataPoint';\nimport { Default } from './Default';\n\n/**\n * This formatter can be used to rename a series name\n *\n * Example: renameSeries(\"username\").\n *\n * ```js\n * <SampleViz\n *     options={{\n *         original: '> primary | getField()'                                                                    // ['users', 'ids']\n *         dataframe: '> primary | renameSeries(\"username\") | getField()'                                        // ['username', 'ids']\n *         dataSeries: '> primary | seriesByName(\"users\") | renameSeries(\"username\") | getField()'               // 'username'\n *         dataPoint: '> primary | seriesByName(\"users\") | lastPoint() | renameSeries(\"username\") | getField()'  // 'username'\n *     }}\n *     dataSources={{\n *         primary: {\n *             data: {\n *                 columns: [['Maurine', 'Jennings', 'Giuseppe'], ['1', '2', '3']],\n *                 fields: [{ name: 'users' }, { name: 'ids' }]\n *             }\n *         }\n *     }}\n * />\n * ```\n * ## Arguments\n *  * **fieldName**: 'string' new field name for the series\n */\nexport class RenameSeries extends Default {\n    private newFieldName: string;\n\n    constructor(name: string) {\n        super(name);\n        this.newFieldName = name;\n    }\n\n    protected formatPoint(p: DataPoint, s?: DataSeries, i = 0, j = 0): DataPoint {\n        return i === 0 && typeof this.newFieldName === 'string' && this.newFieldName.length > 0\n            ? new DataPoint(this.newFieldName, this.formatTypedValue(p, s, i, j))\n            : super.formatPoint(p, s, i, j);\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/get\");","import { AbstractFormatter } from '../Formatter';\nimport EncodingExecutor from '../EncodingExecutor';\nimport { DataPoint } from '../DataPoint';\nimport { TypedValue } from '../DataPrimitive';\nimport { TypeSafeValue } from '../TypeSafeValue';\nimport { DataSeries } from '../DataSeries';\n\nexport class Default extends AbstractFormatter {\n    private defaultVal: string;\n    constructor(val: any) {\n        super();\n        this.defaultVal = EncodingExecutor.rawTree(val);\n    }\n\n    protected formatTypedValue(p: DataPoint, s: DataSeries, i = 0, j = 0): TypedValue {\n        if (p.getRawValue() === undefined) {\n            return TypeSafeValue.fromRaw(this.defaultVal);\n        } else {\n            return p.getValue();\n        }\n    }\n}\n"],"sourceRoot":""}