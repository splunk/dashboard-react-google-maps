/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 144);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VizBehavior = void 0;
var VizBehavior;

(function (VizBehavior) {
  /**
   * Dynamic Options Behavior.
   * This allows visualization options to be powered by data
   *
   * **Example**
   *
   * sparklineValues: ">primary|seriesByIndex(0)"
   * would configure sparklineValues with an array of data points
   * coming from the first series in the primary datasource
   *
   */
  VizBehavior["DYNAMIC_OPTIONS"] = "dynamic-options";
  VizBehavior["EVENTS"] = "events";
  /**
   * Placeholder behavior: visualization will display a placeholder rather than fail if any of the `requiredProps` is
   * missing.
   * @type {string}
   */

  VizBehavior["PLACEHOLDER"] = "placeholder";
  VizBehavior["PAGE_AND_SORT"] = "page-and-sort";
})(VizBehavior = exports.VizBehavior || (exports.VizBehavior = {}));

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(22);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepMergeWithArrayOverrides = exports.extendStaticWrapperProps = void 0;

var lodash_1 = __webpack_require__(2);
/**
 * @method extendStaticWrapperProps
 * @param {Object} props
 * @param {DashboardVizType} props.Wrapper
 * @param {DashboardVizType} props.Visualization
 */


var extendStaticWrapperProps = function extendStaticWrapperProps(_ref) {
  var Wrapper = _ref.Wrapper,
      Visualization = _ref.Visualization;
  var extendProperties = ['propTypes', 'defaultProps', 'config'];
  extendProperties.forEach(function (prop) {
    if (Visualization[prop]) {
      Wrapper[prop] = Visualization[prop];
    }
  });
};

exports.extendStaticWrapperProps = extendStaticWrapperProps;
/**
 * helper to deeply merge objects while preserving arrays in earlier source objects
 * deeply nested primitive keys are merged similarly to lodash's defaultsDeep, while keys with arrays will be preserved if already present in the resultant merged object
 * this prevents default arrays from appending values to user-defined arrays (this occurs if the default array is longer than the user-defined one)
 *
 * @method deepMergeWithArrayOverrides
 * @param {Object} initial - target object to merge values into
 * @param {Object[]} sources - other default options to be merged into the resultant object if no explicit value is provided, with earlier args taking precedence over later ones
 *
 * @returns {Object}
 */

var deepMergeWithArrayOverrides = function deepMergeWithArrayOverrides(initial) {
  var clone = lodash_1.cloneDeep(initial);

  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(function (sourceToApply) {
    Object.keys(sourceToApply).forEach(function (sourceKey) {
      if (!clone.hasOwnProperty(sourceKey)) {
        clone[sourceKey] = lodash_1.cloneDeep(sourceToApply[sourceKey]);
      } // object merging excluding arrays


      if (clone[sourceKey] && _typeof(clone[sourceKey]) === 'object' && !Array.isArray(clone[sourceKey]) && _typeof(sourceToApply[sourceKey]) === 'object') {
        clone[sourceKey] = exports.deepMergeWithArrayOverrides(clone[sourceKey], sourceToApply[sourceKey]);
      }
    });
  });
  return clone;
};

exports.deepMergeWithArrayOverrides = deepMergeWithArrayOverrides;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generatePrecisionValues = exports.getInitialPreset = exports.isDynamicOption = exports.enhanceOptionsSchemaWithDynamicOptions = exports.enhanceConfig = void 0;

var lodash_1 = __webpack_require__(2);

var schemaUtils_1 = __webpack_require__(14);

var VizBehavior_1 = __webpack_require__(5);

var dynamicOptionsDSLType = {
  type: 'string',
  pattern: schemaUtils_1.DYNAMIC_OPTIONS_DSL_PATTERN
};
/**
 * Helper function to extend an options schema with dynamic options DSL
 * @param optionsSchema a visualization's options schema
 * @returns an updated options schema that additionally allows strings starting with > for each option
 */

function enhanceOptionsSchemaWithDynamicOptions(optionsSchema) {
  var enhancedOptionsSchema = {};
  Object.keys(optionsSchema).forEach(function (key) {
    var _a = optionsSchema[key],
        title = _a.title,
        description = _a.description,
        readOnly = _a.readOnly,
        writeOnly = _a.writeOnly,
        examples = _a.examples,
        defaultValue = _a.default,
        type = _a.type,
        properties = _a.properties,
        patternProperties = _a.patternProperties,
        remainingSchemaEntry = __rest(_a, ["title", "description", "readOnly", "writeOnly", "examples", "default", "type", "properties", "patternProperties"]);

    var annotations = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, title !== undefined && {
      title: title
    }), description !== undefined && {
      description: description
    }), readOnly !== undefined && {
      readOnly: readOnly
    }), writeOnly !== undefined && {
      writeOnly: writeOnly
    }), examples !== undefined && {
      examples: examples
    }), defaultValue !== undefined && {
      default: defaultValue
    });

    if (type === 'object') {
      enhancedOptionsSchema[key] = Object.assign(Object.assign(Object.assign(Object.assign({}, remainingSchemaEntry), annotations), {
        type: type
      }), properties && {
        properties: enhanceOptionsSchemaWithDynamicOptions(properties)
      });

      if (patternProperties) {
        var enhancedPatternProperties = {};
        Object.keys(patternProperties).forEach(function (key) {
          enhancedPatternProperties = Object.assign(Object.assign({}, enhancedPatternProperties), enhanceOptionsSchemaWithDynamicOptions(_defineProperty({}, key, patternProperties[key])));
        });
        enhancedOptionsSchema[key].patternProperties = enhancedPatternProperties;
      }
    } else {
      enhancedOptionsSchema[key] = Object.assign(Object.assign({}, annotations), {
        anyOf: [Object.assign(Object.assign({}, type !== undefined && {
          type: type
        }), remainingSchemaEntry), dynamicOptionsDSLType]
      });
    }
  });
  return enhancedOptionsSchema;
}

exports.enhanceOptionsSchemaWithDynamicOptions = enhanceOptionsSchemaWithDynamicOptions;
/**
 * Helper function to enhance a Visualization Config as needed based on behaviors specified in supports block
 * @param vizConfig a Visualization Config
 * @returns an enhanced Visualization Config containing updated config entries based on behaviors it supports
 */

function enhanceConfig(vizConfig) {
  var enhancedConfig = vizConfig;

  if (vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.DYNAMIC_OPTIONS) !== -1) {
    enhancedConfig.optionsSchema = enhanceOptionsSchemaWithDynamicOptions(vizConfig.optionsSchema);
  }

  return enhancedConfig;
}

exports.enhanceConfig = enhanceConfig;

function isDynamicOption(option) {
  return option && typeof option === 'string' && option.trim().startsWith('>') || false;
}

exports.isDynamicOption = isDynamicOption; // private helpers to improve readability of getInitialPreset
// this shouldn't be tested since this util isn't something that we expect to use outside of getInitialPreset

/**
 * this checks to make sure that all values within vizContext are compatible with the given preset's context to determine the initialPreset
 * if a preset has explicitly specified a key as being undefined, the vizContext must also has that key as undefined, or else this CANNOT be the initialPreset
 * the inverse is true; if a preset has key is NOT undefined, it must also be NOT undefined in the corresponding vizContext
 * the internal config contents are irrelevant (as the user could customize them in source), just as long as the presence of `undefined`s match up
 *
 * Since the presetConfigs have explicit undefined keys to override the existing config, we need to explicitly check the undefined values
 */

function hasCompatibleContexts(vizContext, presetContext) {
  var presetContextKeys = Object.keys(presetContext);
  return presetContextKeys.every(function (contextKey) {
    return presetContext[contextKey] === undefined && vizContext[contextKey] === undefined || presetContext[contextKey] !== undefined && vizContext[contextKey] !== undefined;
  });
}
/**
 * Checks to make sure that dynamic (non-dynamic) options in a given preset are also dynamic (non-dynamic) in the vizOptions
 */


function hasCompatibleOptions(vizOptions, presetOptions) {
  var presetOptionKeys = Object.keys(presetOptions);
  return presetOptionKeys.every(function (optionKey) {
    return isDynamicOption(presetOptions[optionKey]) === isDynamicOption(vizOptions[optionKey]);
  });
}
/**
 * Evaluates whether there is an initialPreset that fits the current state of vizContext + vizOptions
 * This function ignores extraneous vizOptions or vizContext keys, as they could be outside the scope of what the preset is intended to configure
 *
 * @param {Object} vizContext - the current vizContext definition
 * @param {Object} vizOptions - the current vizOptions definition
 * @param {PresetEntry[]} presets - the list of presets, one of which can be considered an initialPreset
 */


function getInitialPreset(vizContext, vizOptions, presets) {
  return presets.find(function (preset) {
    var presetContext = lodash_1.get(preset, ['value', 'context'], {});
    var presetOptions = lodash_1.get(preset, ['value', 'options'], {});
    var presetContextKeys = Object.keys(presetContext);
    var presetOptionKeys = Object.keys(presetOptions); // all presets have to explicitly specify which options to reset (i.e. need explicitly undefined keys)
    // if not, then the preset is invalid in config.ts

    if (presetContextKeys.length === 0 || presetOptionKeys.length === 0) return false;
    return hasCompatibleContexts(vizContext, presetContext) && hasCompatibleOptions(vizOptions, presetOptions);
  });
}

exports.getInitialPreset = getInitialPreset;
/**
 * generates number precision values for a Select editor
 *
 * @param {Number} numPrecisionValues - number of integer precision values to generate
 * @returns {{ label: string; value; string  }[]} array of { label, value } tuples
 */

function generatePrecisionValues(numPrecisionValues) {
  return lodash_1.range(0, numPrecisionValues + 1).map(function (i) {
    return {
      label: "".concat(i, " (0").concat(i > 0 ? '.' : '').concat('0'.repeat(i), ")"),
      value: i
    };
  });
}

exports.generatePrecisionValues = generatePrecisionValues;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/Message");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorUtils");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var SizeAwareWrapper_1 = __webpack_require__(17);

var style_1 = __webpack_require__(13);

var colorUtils_1 = __webpack_require__(11);

var Item = styled_components_1.default.div.attrs(function (_ref) {
  var width = _ref.width;
  return {
    style: {
      width: style_1.toPx(width)
    }
  };
}).withConfig({
  displayName: "FixedSizeContainer__Item",
  componentId: "sc-1yhgpod-0"
})(["position:relative;background-color:", "};"], function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
}); // Use `.attrs()` for highly dynamic styles. Ref: https://github.com/styled-components/styled-components/issues/134#issuecomment-312415291

var FixSizeItem = styled_components_1.default.div.attrs(function (_ref2) {
  var width = _ref2.width,
      height = _ref2.height;
  return {
    style: Object.assign(Object.assign({}, width && {
      width: style_1.toPx(width)
    }), height && {
      height: style_1.toPx(height)
    })
  };
}).withConfig({
  displayName: "FixedSizeContainer__FixSizeItem",
  componentId: "sc-1yhgpod-1"
})(["position:relative;flex-direction:column;flex:1;display:flex;background-color:", "};"], function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
});
var ItemContent = styled_components_1.default.div.withConfig({
  displayName: "FixedSizeContainer__ItemContent",
  componentId: "sc-1yhgpod-2"
})(["position:relative;min-height:100px;width:100%;"]);
var FixSizeItemContent = styled_components_1.default.div.withConfig({
  displayName: "FixedSizeContainer__FixSizeItemContent",
  componentId: "sc-1yhgpod-3"
})(["min-height:0px;flex:1;position:relative;box-sizing:border-box;"]);

var withFixedSizeContainer = function withFixedSizeContainer(Viz) {
  var FixedSizeContainer = function FixedSizeContainer(props) {
    var width = props.width,
        height = props.height,
        backgroundColor = props.backgroundColor;

    if (!height) {
      return React.createElement(Item, {
        "data-test": "item",
        width: width,
        backgroundColor: backgroundColor
      }, React.createElement(ItemContent, null, React.createElement(Viz, Object.assign({}, props))));
    }

    return React.createElement(FixSizeItem, {
      "data-test": "fix-size-item",
      width: width,
      height: height,
      backgroundColor: backgroundColor
    }, React.createElement(FixSizeItemContent, null, React.createElement(SizeAwareWrapper_1.default, null, function (_ref3) {
      var newWidth = _ref3.width,
          newHeight = _ref3.height;
      return React.createElement(Viz, Object.assign({}, props, {
        width: newWidth,
        height: newHeight
      }));
    })));
  };

  FixedSizeContainer.displayName = 'withFixedSizeContainer';
  return FixedSizeContainer;
};

exports.default = withFixedSizeContainer;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/style");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/schemaUtils");

/***/ }),
/* 15 */,
/* 16 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SizeAwareWrapper");

/***/ }),
/* 18 */,
/* 19 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/variables");

/***/ }),
/* 20 */,
/* 21 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/pick");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/typeof");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSortingParams = exports.SortParamsPropTypes = void 0;

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var DataSource_1 = __webpack_require__(33);

exports.SortParamsPropTypes = T.shape({
  currentSortKey: T.string,
  currentSortDir: T.oneOf(DataSource_1.validSortDirs),
  onSort: T.func
});

var getSortingParams = function getSortingParams(_ref) {
  var requestParams = _ref.requestParams,
      onRequestParamsChange = _ref.onRequestParamsChange;
  var currentSortKey;
  var currentSortDir;
  var nextSortDirMap = {
    asc: 'desc',
    desc: 'asc',
    none: 'asc'
  };
  var onSort;

  if (lodash_1.isFunction(onRequestParamsChange)) {
    if (requestParams && lodash_1.has(requestParams, 'sort')) {
      currentSortKey = Object.keys(requestParams.sort).shift();
      currentSortDir = requestParams.sort[currentSortKey];
    } // undid memoization since there is a dependency on requestParams, which is a deeply nested object


    onSort = function onSort(e, _ref2) {
      var sortKey = _ref2.sortKey,
          sortDir = _ref2.sortDir;

      if (typeof sortKey === 'string') {
        var nextSortDir = lodash_1.has(nextSortDirMap, sortDir) ? nextSortDirMap[sortDir] : 'none';
        onRequestParamsChange(Object.assign(Object.assign({}, requestParams), {
          offset: 0,
          sort: _defineProperty({}, sortKey, nextSortDir)
        }));
      } else {
        onRequestParamsChange(requestParams);
      }
    };
  }

  return {
    currentSortKey: currentSortKey,
    currentSortDir: currentSortDir,
    onSort: onSort
  };
};

exports.getSortingParams = getSortingParams;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPaginationParams = exports.PaginatorParamsPropTypes = void 0;

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

exports.PaginatorParamsPropTypes = T.shape({
  isPaging: T.bool,
  current: T.number,
  totalPages: T.number,
  onChange: T.func
});

var getPaginationParams = function getPaginationParams(_ref) {
  var requestParams = _ref.requestParams,
      meta = _ref.meta,
      onRequestParamsChange = _ref.onRequestParamsChange;
  var totalCount = meta && meta.totalCount || 0;
  var offset = requestParams && requestParams.offset || 0;
  var count = requestParams && requestParams.count;
  var totalPages = typeof count === 'number' && count > 0 ? Math.ceil(totalCount / count) : 0;
  var current = typeof count === 'number' && count > 0 ? Math.floor(offset / count) + 1 : 0;
  var isPaging = totalPages > 1 && lodash_1.isFunction(onRequestParamsChange);

  var onChangeHandler = function onChangeHandler(e, _ref2) {
    var page = _ref2.page,
        countArg = _ref2.count;
    var newParams = lodash_1.cloneDeep(requestParams);

    if (typeof countArg === 'number') {
      newParams.count = countArg;
      newParams.offset = 0;
    }

    var pageCount = typeof newParams.count === 'number' ? newParams.count : 10;

    if (typeof page === 'number' && page > 0) {
      newParams.count = pageCount;
      newParams.offset = (page - 1) * pageCount;
    }

    onRequestParamsChange(newParams);
  };

  return {
    isPaging: isPaging,
    current: current,
    totalPages: totalPages,
    onChange: lodash_1.isFunction(onRequestParamsChange) ? onChangeHandler : lodash_1.noop
  };
};

exports.getPaginationParams = getPaginationParams;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldShowIconPlaceholder = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var i18n_1 = __webpack_require__(3);

var Message_1 = __webpack_require__(9);

var FixedSizeContainer_1 = __webpack_require__(12);
/**
 * @method shouldShowIconPlaceholder
 * @param {object} dataSources
 * @param {boolean} loading
 * @returns {boolean}
 */


var shouldShowIconPlaceholder = function shouldShowIconPlaceholder(dataSources) {
  var loading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var data = lodash_1.get(dataSources, 'primary.data.columns[0]', undefined);
  var noData = data === undefined;
  var fields = lodash_1.get(dataSources, 'primary.data.fields[0]', undefined);
  var noFields = fields === undefined;
  return loading || noData || noFields;
};

exports.shouldShowIconPlaceholder = shouldShowIconPlaceholder;
var propTypes = {
  icon: T.func,
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  backgroundColor: T.string
};
/**
 * @method IconPlaceholder
 * @param {IconPlaceholderProps} props
 * @returns {React.ReactElement}
 */

var IconPlaceholder = function IconPlaceholder(props) {
  var width = props.width,
      height = props.height,
      icon = props.icon;

  if (icon) {
    return React.createElement(icon, {
      style: {
        left: '50%',
        top: '50%',
        color: 'grey',
        position: 'absolute',
        transform: 'translate(-50%, -50%)'
      },
      width: '50%',
      height: '50%'
    });
  }

  return React.createElement(Message_1.default, {
    width: width,
    height: height,
    level: "warning",
    message: i18n_1._('No DataSource Connected')
  });
};

IconPlaceholder.propTypes = propTypes;
IconPlaceholder.defaultProps = {
  width: '100%',
  height: 250
};
exports.default = FixedSizeContainer_1.default(IconPlaceholder);

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VizCategory = void 0;
var VizCategory;

(function (VizCategory) {
  VizCategory["SINGLE_VALUE"] = "Single Value";
  VizCategory["TRENDS"] = "Trends";
  VizCategory["COMPARISONS"] = "Comparisons";
  VizCategory["TABLE"] = "Table";
  VizCategory["GAUGE"] = "Gauge";
  VizCategory["DISTRIBUTIONS"] = "Distributions";
  VizCategory["CHOROPLETH"] = "Choropleth Maps";
  VizCategory["SHAPES"] = "Shapes";
  VizCategory["MISC"] = "misc";
  VizCategory["FLOW"] = "Flow";
})(VizCategory = exports.VizCategory || (exports.VizCategory = {}));

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);

var getSettingsFromThemedProps_1 = __webpack_require__(28);

var Options_1 = __webpack_require__(29);

var SanitizeProps_1 = __webpack_require__(30);

var styled_components_1 = __webpack_require__(4);

var SplunkVisualization_1 = __webpack_require__(31);

var VizBehavior_1 = __webpack_require__(5);

var getSorting_1 = __webpack_require__(23);

var getPagination_1 = __webpack_require__(24);

var useDeepMemo_1 = __webpack_require__(34);

var JSONSchemaUtils_1 = __webpack_require__(35);

var MissingPropsMessage_1 = __webpack_require__(36);

var withEditModeCover_1 = __webpack_require__(37);

var withPlaceholder_1 = __webpack_require__(38);

var hocUtils_1 = __webpack_require__(7);
/**
 * hoc that wraps a pure react visualization in a Dashboard visualization
 * @param {DashboardVizOpts} opts
 * @returns {HOC}
 */


var withDashboardViz = function withDashboardViz(opts) {
  var ReactViz = opts.ReactViz,
      vizConfig = opts.vizConfig,
      _opts$computeVizProps = opts.computeVizProps,
      computeVizProps = _opts$computeVizProps === void 0 ? function () {} : _opts$computeVizProps,
      useIconPlaceholder = opts.useIconPlaceholder; // sanitizing props before sending them to reactviz.

  var SanitizedReactViz = SanitizeProps_1.withSanitizedProps(ReactViz);
  var defaultOptions = JSONSchemaUtils_1.pickFieldFromJSONSchema(vizConfig.optionsSchema, 'default');

  var DashboardViz = function DashboardViz(props) {
    var mode = props.mode,
        hasEventHandlers = props.hasEventHandlers,
        dataSources = props.dataSources,
        options = props.options,
        _props$context = props.context,
        context = _props$context === void 0 ? {} : _props$context,
        width = props.width,
        height = props.height,
        onComputedProps = props.onComputedProps,
        onEventTrigger = props.onEventTrigger,
        theme = props.theme,
        onRequestParamsChange = props.onRequestParamsChange;

    var themeFunc = function themeFunc(themeVar) {
      var _a, _b;

      return (_b = (_a = vizConfig.themes)[themeVar]) === null || _b === void 0 ? void 0 : _b.call(_a, props);
    };

    var bgColorFromTheme = themeFunc('defaultBackgroundColor');

    var _getSettingsFromTheme = getSettingsFromThemedProps_1.default({
      theme: theme
    }),
        currentThemeFamily = _getSettingsFromTheme.family,
        currentThemeColorScheme = _getSettingsFromTheme.colorScheme,
        currentThemeDensity = _getSettingsFromTheme.density;

    var evaluatedOptions = {}; // evaluatedOptions need to be initialized as an empty object

    evaluatedOptions = useDeepMemo_1.useDeepMemo(function () {
      try {
        return Options_1.Options.evaluate({
          context: lodash_1.defaultsDeep({}, context, vizConfig.defaultContext),
          options: hocUtils_1.deepMergeWithArrayOverrides({}, options, defaultOptions)
        }, dataSources, themeFunc);
      } catch (e) {
        console.error("unexpected error evaluating options:  + ".concat(e.message));
        return {};
      }
    }, [currentThemeFamily, currentThemeColorScheme, currentThemeDensity, options, context, dataSources]); // useEffect hook needs to be initialized before any early returns
    // this is in accordance with the order of hook calls being the same on each render https://reactjs.org/docs/hooks-rules.html#explanation

    React.useEffect(function () {
      onComputedProps(evaluatedOptions);
    }); // present warning message if any required props are missing

    var _vizConfig$requiredPr = vizConfig.requiredProps,
        requiredProps = _vizConfig$requiredPr === void 0 ? [] : _vizConfig$requiredPr,
        supports = vizConfig.supports;
    var missing = MissingPropsMessage_1.missingKeys(requiredProps, evaluatedOptions);

    if (missing.length > 0 && supports.includes(VizBehavior_1.VizBehavior.PLACEHOLDER)) {
      return React.createElement(MissingPropsMessage_1.default, {
        "data-test": "missing-props-message",
        width: width,
        height: height,
        missingProps: missing,
        backgroundColor: bgColorFromTheme
      });
    } // events


    var eventCallbackProps = {};

    if (hasEventHandlers && mode === 'view' && vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.EVENTS) > -1) {
      var supportedEvents = vizConfig.events;
      Object.keys(supportedEvents).forEach(function (eventName) {
        var eventCallbackPropName = lodash_1.camelCase("on.".concat(eventName));
        eventCallbackProps[eventCallbackPropName] = null; // todo: refactor single value and single value icon to send payload from viz
        // then remove these lines

        var payloadKeys = supportedEvents[eventName].payloadKeys;
        var payload = {};

        if (Array.isArray(payloadKeys) && payloadKeys.length) {
          payloadKeys.forEach(function (p) {
            return payload[p] = evaluatedOptions[p];
          });
        }

        eventCallbackProps[eventCallbackPropName] = function (ev) {
          if (ev && ev.payload) {
            payload = ev.payload;
          }

          return onEventTrigger({
            originalEvent: ev,
            payload: payload,
            type: eventName
          });
        };
      });
    } // compute pure viz props which are not from options


    var computedVizProps = computeVizProps(Object.assign(Object.assign(Object.assign(Object.assign({}, props), evaluatedOptions), eventCallbackProps), {
      themeFunc: themeFunc
    }));
    /**
     * PAGE_AND_SORT behavior
     *
     * Some visualizations, like table, requires metadata about the datasource,
     * like total number of results, current count, offset, and sort, for rendering
     * paginator and sorting direction. In this approach, the visualization
     * allow users to set 'paginateDataSourceKey' to select which datasource
     * should the visualization extract the metadata from. It defaults to 'primary' datasource.
     * The visualization config should set the PAGE_AND_SORT behavior to receive
     * 'requestParams', 'meta' and onRequestParams callback as props.
     *
     * In future, we could automatically detect which all datasources are being used
     * and bind those magically to pagination/sorting behavior.
     */

    var dataSourceMetadata = {};
    var OptionKey = 'paginateDataSourceKey';
    var paginateDataSourceKey = lodash_1.has(evaluatedOptions, OptionKey) && evaluatedOptions[OptionKey] || 'primary';

    if (vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.PAGE_AND_SORT) > -1 && lodash_1.has(dataSources, paginateDataSourceKey)) {
      var requestParams = lodash_1.get(dataSources, [paginateDataSourceKey, 'requestParams'], {});
      var meta = lodash_1.get(dataSources, [paginateDataSourceKey, 'meta'], {});

      var handleRequestParamsChange = function handleRequestParamsChange(payload) {
        return onRequestParamsChange(paginateDataSourceKey, payload);
      };

      var sortParams = getSorting_1.getSortingParams({
        requestParams: requestParams,
        meta: meta,
        onRequestParamsChange: handleRequestParamsChange
      });
      var paginatorParams = getPagination_1.getPaginationParams({
        requestParams: requestParams,
        meta: meta,
        onRequestParamsChange: handleRequestParamsChange
      });
      dataSourceMetadata = {
        sortParams: sortParams,
        paginatorParams: paginatorParams
      };
    }

    return React.createElement(SanitizedReactViz, Object.assign({
      mode: mode,
      width: width,
      height: height
    }, evaluatedOptions, computedVizProps, eventCallbackProps, dataSourceMetadata));
  };

  DashboardViz.propTypes = Object.assign(Object.assign({}, SplunkVisualization_1.default.propTypes), ReactViz.propTypes);
  DashboardViz.defaultProps = Object.assign(Object.assign(Object.assign({}, SplunkVisualization_1.default.defaultProps), ReactViz.defaultProps), {
    // using withTheme requires component to receive theme prop. In case the consumer did not provide ThemeProvider, a default empty object will prevent warnings.
    theme: {}
  }); // attach viz config

  DashboardViz.config = vizConfig; // @ts-ignore: TODO fix sc upgrade TS issues

  return styled_components_1.withTheme(withPlaceholder_1.default(withEditModeCover_1.default(DashboardViz), useIconPlaceholder));
};

exports.default = withDashboardViz;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/getSettingsFromThemedProps");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-encoding/Options");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SanitizeProps");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(10);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INITIAL_HEIGHT = exports.INITIAL_WIDTH = void 0;
/* eslint-disable react/no-unused-prop-types,react/prefer-stateless-function */

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var VizActionHandler_1 = __webpack_require__(32); // this is identical to the initial height and width we use in BaseVisualization in dashboard-visualizations


exports.INITIAL_WIDTH = 250;
exports.INITIAL_HEIGHT = 250;
/**
 * A Splunk visualization
 */

var SplunkVisualization = function SplunkVisualization() {
  _classCallCheck(this, SplunkVisualization);
};

SplunkVisualization.propTypes = {
  /**
   * display mode
   */
  mode: T.oneOf(['view', 'edit', 'export']).isRequired,

  /**
   * width in pixel or string, defaults to 100%
   */
  width: T.oneOfType([T.string, T.number]).isRequired,

  /**
   * height in pixel or string
   */
  height: T.oneOfType([T.string, T.number]).isRequired,

  /**
   * visualization context used for dynamic option evaluation
   */
  context: T.object,

  /**
   * visualization formatting options
   */
  options: T.object,

  /**
   * A callback to update formatting options
   */
  onOptionsChange: T.func,

  /**
   * datasource state which include data and request params, object key indicate the datasource type.
   */
  dataSources: T.objectOf(T.shape({
    /**
     * current request params
     */
    requestParams: T.object,

    /**
     * current dataset
     */
    data: T.shape({
      fields: T.array,
      columns: T.array
    }),

    /**
     * error
     */
    error: T.shape({
      level: T.string,
      message: T.string
    }),

    /**
     * meta data that came with the dataset
     */
    meta: T.object
  })),

  /**
   * A callback to trigger event
   */
  onEventTrigger: T.func,

  /**
   * Inform viz if there are handlers listening to events
   */
  hasEventHandlers: T.bool,

  /**
   * A callback to communicate computed props to a consumer
   */
  onComputedProps: T.func,

  /**
   * A callback to obtain visualization api
   */
  vizActionHandlerRef: T.func,
  loading: T.bool,
  theme: T.object,

  /**
   * A callback to request new data with updated request params
   */
  onRequestParamsChange: T.func
};
/**
 *
 */

SplunkVisualization.defaultProps = {
  // BaseVisualization in dashboard-visualizations uses 100% for width but 250 for height
  width: '100%',
  height: exports.INITIAL_HEIGHT,
  dataSources: {},
  onEventTrigger: function onEventTrigger() {
    return {};
  },
  mode: 'view',
  hasEventHandlers: false,
  options: {},
  context: {},
  onOptionsChange: function onOptionsChange() {
    return {};
  },
  vizActionHandlerRef: function vizActionHandlerRef() {
    return new VizActionHandler_1.DefaultVizActionHandler();
  },
  onComputedProps: function onComputedProps() {
    return {};
  },
  loading: false,
  onRequestParamsChange: lodash_1.noop
};
exports.default = SplunkVisualization;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(10);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultVizActionHandler = void 0;

var DefaultVizActionHandler = /*#__PURE__*/function () {
  function DefaultVizActionHandler() {
    _classCallCheck(this, DefaultVizActionHandler);
  }

  _createClass(DefaultVizActionHandler, [{
    key: "focus",
    value: function focus() {//noop
    }
  }, {
    key: "snapshot",
    value: function snapshot() {
      return null; //noop
    }
  }]);

  return DefaultVizActionHandler;
}();

exports.DefaultVizActionHandler = DefaultVizActionHandler;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validSortDirs = void 0;
exports.validSortDirs = ['asc', 'desc', 'none'];

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDeepMemo = void 0;

var react_1 = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);
/**
 * This hook evaluates and stores the result of a passed function and only
 * re-evaluates the function when passed dependencies change.
 *
 * It is different from the internal React useMemo in the following aspects:
 * - it only stores the last evaluated result
 * - it uses a deep equality check to determine if dependencies have changed
 *
 * Inspired by apollo-client's useDeepMemo
 *
 * @param fn the function to be executed and
 * @param dependencies an array of dependencies
 */


var useDeepMemo = function useDeepMemo(fn, dependencies) {
  var ref = react_1.useRef();

  if (!ref.current || !lodash_1.isEqual(dependencies, ref.current.dependencies)) {
    ref.current = {
      dependencies: dependencies,
      value: fn()
    };
  }

  return ref.current.value;
};

exports.useDeepMemo = useDeepMemo;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickFieldFromJSONSchema = void 0;

var lodash_1 = __webpack_require__(2);

var pickFieldFromJSONSchema = function pickFieldFromJSONSchema(optionsSchema) {
  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  return Object.keys(optionsSchema).reduce(function (accum, k) {
    if (lodash_1.has(optionsSchema[k], fieldName)) {
      accum[k] = optionsSchema[k][fieldName];
    } else if (lodash_1.get(optionsSchema, [k, 'type']) === 'object' && lodash_1.has(optionsSchema[k], 'properties')) {
      var nestedSchema = exports.pickFieldFromJSONSchema(optionsSchema[k].properties, fieldName);

      if (!lodash_1.isEmpty(nestedSchema)) {
        accum[k] = nestedSchema;
      }
    }

    return accum;
  }, {});
};

exports.pickFieldFromJSONSchema = pickFieldFromJSONSchema;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MissingPropsMessage = exports.missingKeys = exports.isMissing = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var i18n_1 = __webpack_require__(3);

var Message_1 = __webpack_require__(9);

var FixedSizeContainer_1 = __webpack_require__(12);
/**
 * @method isMissing
 * @param {any} v
 * @returns {boolean} true if the input value === null or undefined
 */


var isMissing = function isMissing(v) {
  return v === null || v === undefined;
};

exports.isMissing = isMissing;
/**
 * @method misskingKeys
 * @param {string[]} keys
 * @param {object} target
 * @returns {string[]} the keys of missing required props
 */

var missingKeys = function missingKeys(keys, target) {
  return keys.filter(function (k) {
    return exports.isMissing(target[k]);
  });
};

exports.missingKeys = missingKeys;
var propTypes = {
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  backgroundColor: T.string,
  missingProps: T.arrayOf(T.string)
};
/**
 * @method MissingPropsMessage
 * @param {MissingPropsProps} props
 * @returns {React.ReactElement}
 */

var MissingPropsMessage = function MissingPropsMessage(props) {
  var width = props.width,
      height = props.height,
      missingProps = props.missingProps;
  return React.createElement(Message_1.default, {
    "data-test": "message",
    width: width,
    height: height,
    message: i18n_1._("Missing property: ".concat(missingProps.join(', ')))
  });
};

exports.MissingPropsMessage = MissingPropsMessage;
exports.MissingPropsMessage.propTypes = propTypes;
exports.MissingPropsMessage.defaultProps = {
  width: '100%',
  height: 250
};
exports.default = FixedSizeContainer_1.default(exports.MissingPropsMessage);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var hocUtils_1 = __webpack_require__(7);

var Cover = styled_components_1.default.div.withConfig({
  displayName: "withEditModeCover__Cover",
  componentId: "sc-1gsbnxb-0"
})(["position:absolute;left:0;right:0;top:0;bottom:0;"]);
var Blocker = styled_components_1.default.div.withConfig({
  displayName: "withEditModeCover__Blocker",
  componentId: "sc-1gsbnxb-1"
})(["position:relative;width:100%;height:100%;"]);
/**
 * HOC that renders a cover layer in edit mode
 * @method withEditModeCover
 * @param {ExtendedDashViz} Visualization
 * @returns {ExtendedDashViz} Wrapper
 */

var withEditModeCover = function withEditModeCover(Visualization) {
  var Wrapper = function Wrapper(props) {
    var mode = props.mode;
    return React.createElement(Blocker, null, React.createElement(Visualization, Object.assign({}, props)), mode === 'edit' && React.createElement(Cover, {
      "data-test": "edit-mode-cover"
    }));
  };

  hocUtils_1.extendStaticWrapperProps({
    Wrapper: Wrapper,
    Visualization: Visualization
  });
  return Wrapper;
};

exports.default = withEditModeCover;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var colorUtils_1 = __webpack_require__(11);

var IconPlaceholder_1 = __webpack_require__(25);

var VizBehavior_1 = __webpack_require__(5);

var hocUtils_1 = __webpack_require__(7);

var withPlaceholder = function withPlaceholder(Visualization) {
  var useIconPlaceholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IconPlaceholder_1.shouldShowIconPlaceholder;
  var config = Visualization.config;
  var themes = config.themes;

  var Wrapper = function Wrapper(props) {
    var _a;

    var dataSources = props.dataSources,
        loading = props.loading,
        options = props.options,
        height = props.height,
        width = props.width;
    var showPlaceholder = useIconPlaceholder(dataSources, loading, options);
    var bgColorFromTheme = colorUtils_1.isColor(options === null || options === void 0 ? void 0 : options.backgroundColor) ? options === null || options === void 0 ? void 0 : options.backgroundColor : (_a = themes === null || themes === void 0 ? void 0 : themes.defaultBackgroundColor) === null || _a === void 0 ? void 0 : _a.call(themes, props);

    if (config.supports.includes(VizBehavior_1.VizBehavior.PLACEHOLDER) && showPlaceholder) {
      return React.createElement(IconPlaceholder_1.default, {
        "data-test": "icon-placeholder",
        icon: config.icon,
        width: width,
        height: height,
        backgroundColor: bgColorFromTheme
      });
    }

    return React.createElement(Visualization, Object.assign({}, props));
  };

  hocUtils_1.extendStaticWrapperProps({
    Wrapper: Wrapper,
    Visualization: Visualization
  });
  return Wrapper;
};

exports.default = withPlaceholder;

/***/ }),
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-icons");

/***/ }),
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-color-palettes/editors/PresetPalettes");

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_0__);

var VizStyleWrapper = styled_components__WEBPACK_IMPORTED_MODULE_0___default.a.div.attrs(function (_ref) {
  var dataTestKey = _ref.dataTestKey;
  return {
    'data-test': dataTestKey
  };
}).withConfig({
  displayName: "VizStyleWrapper",
  componentId: "sc-6rw6wv-0"
})(["display:flex;justify-content:center;flex-direction:column;width:100%;height:100%;background-color:", ";"], function (props) {
  return props.backgroundColor;
});
VizStyleWrapper.displayName = 'VizStyleWrapper';
/* harmony default export */ __webpack_exports__["default"] = (VizStyleWrapper);

/***/ }),
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_configUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _utils_configUtils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_configUtils__WEBPACK_IMPORTED_MODULE_1__);


var StaticBackgroundColorEditor = {
  label: Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_0__["_"])('Static Background'),
  option: 'backgroundColor',
  editor: 'editor.color',
  showEditor: function showEditor(_ref) {
    var options = _ref.options;
    return !Object(_utils_configUtils__WEBPACK_IMPORTED_MODULE_1__["isDynamicOption"])(options.backgroundColor);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (StaticBackgroundColorEditor);

/***/ }),
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/inherits");

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/possibleConstructorReturn");

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/getPrototypeOf");

/***/ }),
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(10);

var _createClass = __webpack_require__(16);

var _inherits = __webpack_require__(81);

var _possibleConstructorReturn = __webpack_require__(82);

var _getPrototypeOf = __webpack_require__(83);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);

var SvgMutator_1 = __webpack_require__(150);
/**
 * This react component simply take an SVG document, and mutates it by applying data to the document according to
 * dataBindings. The data (data prop) is processed by performing the mutation once for each 'row' of the data even though the data is formatted as columns.
 * If the data looks like {foo:['a', 'b', 'c'], bar:['x', 'y', 'z']} then mutation is performed three times, since the data has three rows.
 * The special $i variable is incremented for each row processed.
 * The first mutation has $i=0, the second has $1=1, the third has $i=2.
 * This allows for JEXL expressions to access the data in a row-like fashion via expressions such as 'foo[$i] + bar[$i]' which will return "ax" for the first row mutation, "by" for the second, and "cz" for the third mutation
 */


var SvgChoroplethDynamic = /*#__PURE__*/function (_React$Component) {
  _inherits(SvgChoroplethDynamic, _React$Component);

  var _super = _createSuper(SvgChoroplethDynamic);

  function SvgChoroplethDynamic(props, context) {
    var _this;

    _classCallCheck(this, SvgChoroplethDynamic);

    _this = _super.call(this, props, context);

    _this.handleAreaClick = function (ev) {
      if (typeof _this.props.onAreaClick === 'function') {
        _this.props.onAreaClick(Object.assign(Object.assign({}, ev), {
          payload: ev.detail
        }));
      }
    };

    _this.areaClickRef = function (node) {
      if (!node) {
        return;
      }

      node.addEventListener('areaClick', function (ev) {
        return _this.handleAreaClick(ev);
      });
      _this.node = node;
    };

    _this.state = {
      svgNode: null
    };
    _this.node = null;
    return _this;
  }

  _createClass(SvgChoroplethDynamic, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.mutate();
    } //Note - this component is currently ignoring the width and height in order to properly scale to
    //fill whatever component it is in. If we revisit that, we need to remember to allow the component to
    //update when width and height change

  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      return nextProps.svg !== this.props.svg || !lodash_1.isEqual(nextProps.data, this.props.data) || // must do deep equal on data because when no data is passed we do 'let data = { featureIDs: [], values: [], fill: [] };' in ChoroplethSVG which looks to react like different data every time
      nextState.svgNode !== this.state.svgNode;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.svg !== this.props.svg || !lodash_1.isEqual(prevProps.data, this.props.data)) {
        this.mutate();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.node) {
        this.node.removeEventListener('areaClick', this.handleAreaClick);
      }
    }
  }, {
    key: "mutate",
    value: function mutate() {
      var svg = this.props.svg;

      if (svg) {
        var m = new SvgMutator_1.SvgMutator(this.props);

        try {
          // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
          this.setState({
            svgNode: m.mutate()
          });
        } catch (e) {
          console.error(e);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          _this$props$width = _this$props.width,
          width = _this$props$width === void 0 ? '100%' : _this$props$width,
          _this$props$height = _this$props.height,
          height = _this$props$height === void 0 ? '100%' : _this$props$height;
      var svgNode = this.state.svgNode;

      if (svgNode) {
        return React.createElement("div", {
          style: {
            width: width,
            height: height
          },
          ref: this.areaClickRef
        }, svgNode);
      }

      return null;
    }
  }]);

  return SvgChoroplethDynamic;
}(React.Component);

exports.default = SvgChoroplethDynamic;
SvgChoroplethDynamic.defaultProps = {
  svg: ''
};

/***/ }),
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useIconPlaceholder = exports.createProtocolHandlers = exports.PureSvgChoroplethDynamic = exports.PureChoroplethSvg = exports.config = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var FeatureFlagContext_1 = __webpack_require__(145);

var ImageContext_1 = __webpack_require__(146);

var FileDownloader_1 = __webpack_require__(147);

var Downloader_1 = __webpack_require__(148);

var withDashboardViz_1 = __webpack_require__(27);

var PureChoroplethSvg_1 = __webpack_require__(149);

var SvgChoroplethDynamic_1 = __webpack_require__(112);

var config_1 = __webpack_require__(154);

var IconPlaceholder_1 = __webpack_require__(25);

exports.config = config_1.default;
exports.PureChoroplethSvg = PureChoroplethSvg_1.default; // todo: need remove when deleting @splunk/react-visualizations package

exports.PureSvgChoroplethDynamic = SvgChoroplethDynamic_1.default;
/**
 * This function generates the protocol handlers
 * by default, svg supports data and local handler
 * if feature flag enableSvgHttpDownloader is turned on, then http and https also added into handlers
 * @param {FeatureFlagContext} featureFlagContext
 * @param {ImageContext} imageContext
 * @returns {object}
 */

var createProtocolHandlers = function createProtocolHandlers() {
  var featureFlagContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var imageContext = arguments.length > 1 ? arguments[1] : undefined;
  var handlers = {
    data: new Downloader_1.URLDownloader()
  };

  if (imageContext) {
    imageContext.listProviders().forEach(function (_ref) {
      var type = _ref.type;
      handlers[type] = new Downloader_1.ImageRegistryFetcher(imageContext);
    });
  }

  var enableSvgHttpDownloader = featureFlagContext.enableSvgHttpDownloader;

  if (enableSvgHttpDownloader) {
    handlers['http'] = new Downloader_1.URLDownloader();
    handlers['https'] = new Downloader_1.URLDownloader();
  }

  return handlers;
};

exports.createProtocolHandlers = createProtocolHandlers;

var ChoroplethSvg = function ChoroplethSvg(_a) {
  var props = __rest(_a, []);

  var svg = props.svg; // note that the FileDownloader will just immediately pass through literal (non-url) content in the case that
  // the svg argument is not a url.

  return React.createElement(ImageContext_1.default.Consumer, null, function (imageContext) {
    return React.createElement(FeatureFlagContext_1.default.Consumer, null, function (featureFlagContext) {
      return React.createElement(FileDownloader_1.FileDownloader, {
        url: svg,
        protocolHandlers: exports.createProtocolHandlers(featureFlagContext, imageContext),
        renderContent: function renderContent(svg) {
          var pureVizProps = Object.assign(Object.assign({}, props), {
            svg: svg
          });
          return React.createElement(exports.PureChoroplethSvg, Object.assign({}, pureVizProps));
        }
      });
    });
  });
};

ChoroplethSvg.propTypes = {
  svg: T.string
};

function useIconPlaceholder(dataSources, loading, options) {
  var svg = lodash_1.get(options, 'svg');
  var missingData = IconPlaceholder_1.shouldShowIconPlaceholder(dataSources, loading);
  return missingData && !svg;
}

exports.useIconPlaceholder = useIconPlaceholder;
var platformViz = withDashboardViz_1.default({
  ReactViz: ChoroplethSvg,
  vizConfig: config_1.default,
  useIconPlaceholder: useIconPlaceholder
}); //(platformViz as any).defaultProps.width = '100%';
//(platformViz as any).defaultProps.height = '100%';

exports.default = platformViz;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-context/FeatureFlagContext");

/***/ }),
/* 146 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-context/ImageContext");

/***/ }),
/* 147 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/FileDownloader");

/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/Downloader");

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeSvgDynamicProps = void 0;

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var lodash_1 = __webpack_require__(2);

var style_1 = __webpack_require__(13);

var SizeAwareWrapper_1 = __webpack_require__(17);

var SvgChoroplethDynamic_1 = __webpack_require__(112);

var VizStyleWrapper_1 = __webpack_require__(57);

var Container = styled_components_1.default.div.withConfig({
  displayName: "PureChoroplethSvg__Container",
  componentId: "m24jrf-0"
})(["position:relative;flex-direction:column;flex:1;display:flex;", ";"], function (props) {
  return style_1.toDimension(lodash_1.pick(props, ['width', 'height']));
});
var ChoroplethSvgWrapper = styled_components_1.default.div.withConfig({
  displayName: "PureChoroplethSvg__ChoroplethSvgWrapper",
  componentId: "m24jrf-1"
})(["min-height:0px;flex:1;position:relative;"]);

var computeSvgDynamicProps = function computeSvgDynamicProps(_a) {
  var props = __rest(_a, []);

  var data = {
    featureIDs: props.areaIds || [],
    values: props.areaValues || [],
    fill: props.areaColors || []
  }; //current implementation is limited to only setting the fill attribute

  var dataBinding = [{
    xPath: "'//*[@id=\"'+featureIDs[$i]+'\"]/@fill'",
    value: 'fill[$i]'
  }];
  return Object.assign(Object.assign({}, lodash_1.omit(props, ['areaIds', 'areaValues', 'areaColors'])), {
    data: data,
    dataBinding: dataBinding
  });
};

exports.computeSvgDynamicProps = computeSvgDynamicProps;

var PureChoroplethSvg = function PureChoroplethSvg(_a) {
  var props = __rest(_a, []);

  var width = props.width,
      height = props.height,
      backgroundColor = props.backgroundColor;

  var renderVisualization = function renderVisualization(_ref) {
    var containerWidth = _ref.width,
        containerHeight = _ref.height;
    var svgProps = exports.computeSvgDynamicProps(Object.assign(Object.assign({}, props), {
      width: containerWidth,
      height: containerHeight
    }));
    return React.createElement(VizStyleWrapper_1.default, {
      backgroundColor: backgroundColor,
      dataTestKey: "ChoroplethSvgWrapper"
    }, React.createElement(SvgChoroplethDynamic_1.default, Object.assign({}, svgProps)));
  };

  return React.createElement(Container, {
    width: width,
    height: height
  }, React.createElement(ChoroplethSvgWrapper, null, React.createElement(SizeAwareWrapper_1.default, null, function (containerDimension) {
    return renderVisualization(containerDimension);
  })));
};

PureChoroplethSvg.defaultProps = {
  width: '100%',
  height: 250,
  onAreaClick: function onAreaClick() {}
};
exports.default = styled_components_1.withTheme(PureChoroplethSvg);

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(10);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SvgMutator = exports.ERROR_NON_ATTRIBUTE_MUTATION = void 0;

var React = __webpack_require__(1);

var XPath = __webpack_require__(151);

var xmldom_1 = __webpack_require__(152);

var jexl = __webpack_require__(153);
/**
 * An error message indicating that a mutation has attempted to target anything other than SVG attribute(s)
 * @type {string}
 */


exports.ERROR_NON_ATTRIBUTE_MUTATION = 'mutations only allowed on attribute nodes';
/**
 * This class takes columnar data and mutates an SVG document by applying rules defined in DataBindings. This class
 * includes capability to place delays between the mutations such that the data can be animated "row by row" with definable
 * animation delays. This class parses an SVG document into an internal dom (NOT THE BROWSER DOM), which is then
 * converted into a ReactNode.
 */

var SvgMutator = /*#__PURE__*/function () {
  /**
   * parses the svg and stores the parsed Document in a local field. Keeps a copy of the props.
   * @param {SvgChoroplethDynamicProps} props
   */
  function SvgMutator(props) {
    _classCallCheck(this, SvgMutator);

    var svg = props.svg;
    this.svgDoc = new xmldom_1.DOMParser().parseFromString(svg);
    this.props = Object.assign({}, props);
  }
  /**
   * Applies all data mutations on a clone of this.svgDoc and returns a ReactNode
   * suitable for displaying the mutated content. Includes callback that can be used to get the actual
   * dom node.
   * @param {(node: Node) => void} refCallback
   * @returns {React.ReactNode}
   */


  _createClass(SvgMutator, [{
    key: "mutate",
    value: function mutate() {
      var refCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var content = this.applyMutations(this.svgDoc);
      return SvgMutator.getSandboxedIframe(refCallback, content, this.props);
    }
    /**
     * This method forms a JEXL context from the data, and a special '$i' variable which tells which row is being processed.
     * The context is passed to JEXL which is used to find the XPathResult which we consider as "hits" in the search of the
     * SVG for attributes to mutate. Once we have these 'found' attribute hits, we mutate each one.
     * @param dataBinding
     * @param data
     * @param {number} i
     * @param {Node} target
     */

  }, {
    key: "applyMutations",
    value:
    /**
     * Clones the prototypical Node, applies all data mutations to the cloned target, and returns the mutated clone
     * @param {Node} prototypicalNode
     * @returns {Node}
     */
    function applyMutations(prototypicalNode) {
      var _this$props = this.props,
          dataBinding = _this$props.dataBinding,
          data = _this$props.data;
      var target = prototypicalNode.cloneNode(true);

      if (data) {
        var anyKey = Object.keys(data)[0];
        var len = data[anyKey].length;

        var _loop = function _loop(i) {
          // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
          dataBinding.forEach(function (db) {
            return SvgMutator.applyMutation(db, data, i, target);
          });
        };

        for (var i = 0; i < len; i++) {
          _loop(i);
        }
      }

      return target;
    }
    /**
     *
     * @param {(node: Node) => void} refCallback called with actual iframe node in real DOM
     * @param {Node} node
     * @param width
     * @param height
     * @returns {React.ReactElement}
     */

  }], [{
    key: "applyMutation",
    value: function applyMutation(dataBinding, data, i, target) {
      var xPath = dataBinding.xPath;

      if (!xPath) {
        throw new Error('xPath property not defined');
      } //use xpath expression to seek out places to make changes


      var hits = SvgMutator.evaluateXPath(xPath, target, Object.assign(Object.assign({}, data), {
        $i: i
      }));
      var hit;

      for (hit = hits.iterateNext(); hit; hit = hits.iterateNext()) {
        SvgMutator.mutateNode(hit, dataBinding, data, i);
      }
    }
  }, {
    key: "getSandboxedIframe",
    value: function getSandboxedIframe(refCallback, //fixme get rid of?
    node, currentProps) {
      var svgNode = SvgMutator.getSvgElementFromDoc(node);
      svgNode.setAttribute('width', currentProps.width || '100%');
      svgNode.setAttribute('height', currentProps.height || '100%');
      var NONCE = window.crypto.getRandomValues(new Uint32Array(4)).join('');
      var PARENT_ID = window.crypto.getRandomValues(new Uint32Array(4)).join('');
      var html = SvgMutator.getIframeHtml(NONCE, PARENT_ID, svgNode);
      var b64 = btoa(html);
      var iframe = React.createElement('iframe', {
        src: "data:text/html;base64,".concat(b64),
        style: {
          position: 'absolute',
          height: '100%',
          width: '100%',
          margin: '0',
          padding: '0',
          pointerEvents: 'auto' //if this isn't 'none' it absorbs all pointer events and none get to enclosing div (credit @hwerner)

        },
        frameBorder: 0,
        sandbox: 'allow-scripts',
        id: 'svgChoroplethIframe'
      });
      var intervalID = null;
      var messageListener = null;
      return React.createElement('div', {
        style: {
          width: '100%',
          height: '100%',
          left: 0,
          top: 0,
          position: 'absolute'
        },
        id: 'svgDiv',
        ref: function ref(div) {
          if (!div) {
            //called on unmount
            SvgMutator.removeIframeEventListener(div, messageListener, intervalID, refCallback);
            return;
          }

          messageListener = SvgMutator.createIframeMessageListener(NONCE, intervalID, div);
          window.addEventListener('message', messageListener);

          function sendSetupMessage() {
            var svgIframe = div.querySelector('#svgChoroplethIframe'); //send single message to iframe content so that content can "learn" the targetOrigin for it's reply messages

            svgIframe && svgIframe.contentWindow.postMessage({
              parentIdentity: PARENT_ID
            }, '*');
          } //continuously send an initialization message to the iframe until it ack's back


          intervalID = setInterval(sendSetupMessage, 500);
          refCallback(div);
        }
      }, iframe // child of div
      );
    }
  }, {
    key: "getSvgElementFromDoc",
    value: function getSvgElementFromDoc(node) {
      if (node.nodeName === '#document') {
        var kids = node.childNodes;

        for (var i = 0; i < kids.length; i++) {
          node = kids.item(i); // re https://jira.splunk.com/browse/SPL-188348 DOCTYPE nodes that we want to skip would have
          // nodeName 'svg', but only the actualy <svg> element has nodeType 1 (ELEMENT_NODE)

          if (node.nodeName === 'svg' && node.nodeType && node.nodeType === 1) {
            break;
          }
        }
      }

      if (node.nodeName !== 'svg') {
        throw new Error("Could not find an <svg> element");
      }

      return node;
    }
    /**
     * Runs JEXL to evaluate an expression that returns an XPath string, then evaluate the XPath string against the
     * svg document Node (i.e. 'search' the SVG document)
     * @param {string} xpathExpr
     * @param {Node} doc
     * @param {object} context
     * @returns {XPathResult}
     */

  }, {
    key: "evaluateXPath",
    value: function evaluateXPath(xpathExpr, doc) {
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var resolver = {
        lookupNamespaceURI: function lookupNamespaceURI() {
          return 'http://www.w3.org/2000/svg';
        }
      };
      var xpath = jexl.evalSync(xpathExpr, context);
      return XPath.evaluate(xpath, doc, resolver, XPathResult.ANY_TYPE, null);
    }
    /**
     * At this point we have identified an SVG attribute Node that we wish to mutate. That node is passed in here along
     * with the data binding and the data. We have already used the dataBinding's xpath (that is how we found the
     * attribute Node. Now we use the dataBindings 'value' field, which is also an expression to extract a value from
     * the data itself. We then alter the attribute's value (it's nodeValue). If the data has a 'values' column, then we
     * also set data-value attribute of the node, and similarly for the data-name (coming from the data's featureId column)
     * @param {Node} n
     * @param {SvgAttributeBinding} dataBinding
     * @param {{[p: string]: string[]}} data
     * @param {number} i
     * @returns {any}
     */

  }, {
    key: "mutateNode",
    value: function mutateNode(n, dataBinding, data, i) {
      if (n.nodeType && n.nodeType != Node.ATTRIBUTE_NODE) {
        throw new Error(exports.ERROR_NON_ATTRIBUTE_MUTATION);
      }

      var context = Object.assign(Object.assign({
        $oldValue: n.nodeValue
      }, data), {
        $i: i
      });
      var computed;

      try {
        computed = jexl.evalSync(dataBinding.value, context);
      } catch (error) {
        return;
      } // this is the actual mutation: we change the attributes value


      n.nodeValue = computed;
      n.value = computed; // So you may ask...why do we set BOTH the nodeValue and the Attr value. The nodeValue seems to be the one that "shows up" as reflecting the change. We use nodeValue down in addSubtree. Yet XMLSerializer will only see the changes from Attr.value. So what the heck, we use BOTH
      // we also add data-* attributes to the node and a title that behaves like a hover

      var title = '';
      var parent = n.ownerElement;

      if (data['values'] && data['values'][i]) {
        parent.setAttribute('data-value', data['values'][i]);
        title += "name: ".concat(data['values'][i]);
      }

      if (data['featureIDs'] && data['featureIDs'][i]) {
        parent.setAttribute('data-name', data['featureIDs'][i]);
        title += "\nvalue: ".concat(data['featureIDs'][i]);
      }

      if (title !== '') {
        var titleElem = document.createElementNS('http://www.w3.org/2000/svg', 'title');
        titleElem.textContent = title;
        parent.appendChild(titleElem);
      }

      data['featureIDs'] && parent.setAttribute('data-name', data['featureIDs'][i]);
      return computed; //makes this method more testable to return the updated node value, though real callers don't need to use the returned value.
    }
  }, {
    key: "getCssResetStyle",
    value: function getCssResetStyle() {
      return "/* http://meyerweb.com/eric/tools/css/reset/\n                   v2.0 | 20110126\n                   License: none (public domain)\n                */\n\n                html, body, div, span, applet, object, iframe,\n                h1, h2, h3, h4, h5, h6, p, blockquote, pre,\n                a, abbr, acronym, address, big, cite, code,\n                del, dfn, em, img, ins, kbd, q, s, samp,\n                small, strike, strong, sub, sup, tt, var,\n                b, u, i, center,\n                dl, dt, dd, ol, ul, li,\n                fieldset, form, label, legend,\n                table, caption, tbody, tfoot, thead, tr, th, td,\n                article, aside, canvas, details, embed,\n                figure, figcaption, footer, header, hgroup,\n                menu, nav, output, ruby, section, summary,\n                time, mark, audio, video {\n                    margin: 0;\n                    padding: 0;\n                    border: 0;\n                    font-size: 100%;\n                    font: inherit;\n                    vertical-align: baseline;\n                }\n                /* HTML5 display-role reset for older browsers */\n                article, aside, details, figcaption, figure,\n                footer, header, hgroup, menu, nav, section {\n                    display: block;\n                }\n                body {\n                    line-height: 1;\n                }\n                ol, ul {\n                    list-style: none;\n                }\n                blockquote, q {\n                    quotes: none;\n                }\n                blockquote:before, blockquote:after,\n                q:before, q:after {\n                    content: '';\n                    content: none;\n                }\n                table {\n                    border-collapse: collapse;\n                    border-spacing: 0;\n                }\n                svg {\n                    pointer-events:all;\n                }";
    }
  }, {
    key: "getCsp",
    value: function getCsp(nonce) {
      return "default-src 'self'; child-src 'none'; style-src 'self' 'unsafe-inline'; img-src data: ; script-src 'nonce-".concat(nonce, "'");
    }
  }, {
    key: "getIframeHtml",
    value: function getIframeHtml(nonce, parentId, svgNode) {
      return "<html><head>\n                         <meta http-equiv=\"Content-Security-Policy\" content=\"".concat(this.getCsp("".concat(nonce)), "\"/>\n                         <style>\n                            ").concat(SvgMutator.getCssResetStyle(), "\n                        </style>\n\n                      </head>\n                      <body>\n                        <div id=\"svgChoroplethSvgDiv\" style=\"position:absolute;height:100%;width:100%;overflow:hidden\">\n                            ").concat(SvgMutator.serializer.serializeToString(svgNode), "\n                        </div>\n                        <script nonce=\"").concat(nonce, "\">\n\n                            let parentOrigin = null;\n                            let parentWindow = null;\n\n                            function sendMessage(m){\n\n                                if(!parentWindow){\n                                    return; // don't send any messages until we know where to send them\n                                }\n                                m.nonce = '").concat(nonce, "'; // set nonce into message.\n                                parentWindow.postMessage(m,parentOrigin);\n                            }\n\n\n                            const parentSetupMessageListener = m =>{\n                                const {parentIdentity} = m.data;\n                                if(parentIdentity !== '").concat(parentId, "'){\n                                    return;\n                                }\n                                //set parent origin\n                                parentOrigin = m.origin;\n                                if(parentOrigin === 'null'){ // yes, this is supposed to be a string 'null'\n                                    parentOrigin = '*';\n                                }\n                                if(!m.source){\n                                    return;\n                                }\n                                parentWindow = m.source;\n                                sendMessage({}); //acknowledge\n                                // we can now remove ourself since initial setup complete\n                                window.removeEventListener('message', parentSetupMessageListener);\n                            };\n\n                            function registerListeners(){\n\n                                //listen for a first message to establish the parent origin\n                                window.addEventListener('message', parentSetupMessageListener);\n\n                                ['mousemove', 'mouseover', 'mousedown', 'mouseup', 'click'].forEach(eventType => {\n                                    const svgElement = document.getElementsByTagName('svg')[0];\n                                    svgElement.addEventListener(eventType, (e)=> {\n                                        const value = e.target.getAttribute('data-value');\n                                        const name = e.target.getAttribute('data-name');\n                                        sendMessage({\n                                            nonce:'").concat(nonce, "',\n                                            eventType,\n                                            clientX:e.clientX,\n                                            clientY:e.clientY,\n                                            value,\n                                            name,\n                                        });\n                                    });\n                                });\n\n\n                            }\n                            registerListeners();\n                        </script>\n                      </body></html>");
    }
  }, {
    key: "createIframeMessageListener",
    value: function createIframeMessageListener(expectedNonce, intervalId, div) {
      var jsdom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      return function (m) {
        var _m$data = m.data,
            nonce = _m$data.nonce,
            eventType = _m$data.eventType,
            clientX = _m$data.clientX,
            clientY = _m$data.clientY,
            value = _m$data.value,
            name = _m$data.name;

        if (nonce !== expectedNonce || !jsdom && m.origin !== 'null') {
          //yes, m.origin IS actually supposed to be a string 'null'. That is origin for opaque URL
          return; //If message did not contain expected nonce, then ignore (comms will not be stablished).
        }

        if (intervalId) {
          clearInterval(intervalId); // stop sending setup message
        }

        var boundingRect = div.getBoundingClientRect();

        if (eventType && clientX && clientY) {
          var mEvent;
          var realClientX = Math.round(clientX + boundingRect.left);
          var realClientY = Math.round(clientY + boundingRect.top);
          var eventSetting = {
            bubbles: true,
            cancelable: true,
            composed: true
          }; // only dispatch customEvent for click because value and name are needed to bubble up

          if (eventType === 'click') {
            mEvent = new CustomEvent('areaClick', Object.assign({
              detail: {
                clientX: realClientX,
                clientY: realClientY,
                value: value,
                name: name
              }
            }, eventSetting));
          } else {
            mEvent = new MouseEvent(eventType, Object.assign({
              clientX: realClientX,
              clientY: realClientY
            }, eventSetting));
          }

          div.dispatchEvent(mEvent);
        }
      };
    }
  }, {
    key: "removeIframeEventListener",
    value: function removeIframeEventListener(element, messageListener, intervalID, refCallback) {
      if (messageListener) {
        window.removeEventListener('message', messageListener);
      }

      if (intervalID) {
        clearInterval(intervalID); // stop sending setup message
      }

      refCallback(element);
    }
  }]);

  return SvgMutator;
}();

exports.SvgMutator = SvgMutator;
SvgMutator.serializer = new xmldom_1.XMLSerializer();

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = require("xpath");

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = require("@xmldom/xmldom");

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = require("jexl");

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var i18n_1 = __webpack_require__(3);

var pick_1 = __webpack_require__(21);

var variables_1 = __webpack_require__(19);

var schemaUtils_1 = __webpack_require__(14);

var PresetPalettes_1 = __webpack_require__(56);

var visualization_icons_1 = __webpack_require__(42);

var VizBehavior_1 = __webpack_require__(5);

var configUtils_1 = __webpack_require__(8);

var VizCategory_1 = __webpack_require__(26);

var StaticBackgroundColorEditor_1 = __webpack_require__(70);

var dataContract = {
  requiredDataSources: [],
  optionalDataSources: [{
    name: 'primary',
    description: 'DataSource that powers the visualization'
  }],
  initialRequestParams: {
    primary: {
      offset: 0,
      count: 10000
    }
  }
};
var size = {
  initialWidth: 300,
  initialHeight: 300
};
var defaultContext = {
  areaColorsGradientConfig: {
    colors: ['#7EEFDA', '#6484F6', '#C093F9', '#293873']
  },
  areaColorsRangeConfig: [{
    to: 20,
    value: '#D41F1F'
  }, {
    from: 20,
    to: 40,
    value: '#D94E17'
  }, {
    from: 40,
    to: 60,
    value: '#CBA700'
  }, {
    from: 60,
    to: 80,
    value: '#669922'
  }, {
    from: 80,
    value: '#118832'
  }]
};
var optionsSchema = {
  areaIds: {
    default: '> primary|seriesByType("string")',
    description: 'Specify the dataSource field that should be used to identify each area in the Choropleth svg, where the area has been tagged with an id field.',
    type: 'array',
    items: {
      type: 'string'
    }
  },
  areaValues: {
    default: '> primary|seriesByType("number")',
    description: 'Specify the dataSource field that indicates the values for the areas.',
    type: 'array',
    items: {
      type: 'number'
    }
  },
  areaColors: {
    default: '> areaValues|rangeValue(areaColorsRangeConfig)',
    description: 'Specify the dataSource field that should be used to set the svg fill attribute of identified areas.',
    type: 'array',
    items: {
      type: 'string',
      pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
    }
  },
  svg: {
    description: 'Literal svg, or svg data URI.',
    type: 'string'
  },
  backgroundColor: {
    default: '> themes.defaultBackgroundColor',
    description: 'the background color behind the SVG, title, and description.',
    type: 'string',
    pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
  }
};
var themes = {
  defaultBackgroundColor: function defaultBackgroundColor(props) {
    return pick_1.default({
      enterprise: {
        dark: variables_1.default.backgroundColorSidebar(props),
        light: variables_1.default.backgroundColor(props)
      },
      prisma: variables_1.default.backgroundColorSidebar(props)
    })(props);
  }
};
var editorConfig = [{
  label: i18n_1._('SVG Data'),
  open: true,
  layout: [[{
    label: '',
    option: 'svg',
    editor: 'editor.image',
    editorProps: {
      validMediaTypes: ['svg'],
      svgRenderAsDom: true
    }
  }]]
}, {
  label: i18n_1._('Path ID Field Formatting'),
  layout: [[{
    label: 'SVG Path ID Field',
    editor: 'editor.columnSelector',
    option: 'areaIds',
    context: 'areaIdContext',
    editorProps: {
      dataSourceKey: 'primary'
    }
  }], [{
    label: 'Value Field',
    editor: 'editor.columnSelector',
    option: 'areaValues',
    context: 'areaValuesContext',
    editorProps: {
      dataSourceKey: 'primary'
    }
  }], [{
    label: i18n_1._('Coloring'),
    option: 'areaColors',
    context: 'defaultContext',
    editor: 'editor.dynamicColor',
    editorProps: {
      labelPosition: 'left',
      flyoutTitle: i18n_1._('Path ID Field Formatting: Value'),
      formatters: [{
        label: i18n_1._('Ranges'),
        value: 'rangeValue',
        isDefault: true,
        defaults: {
          areaValues: defaultContext.areaColorsRangeConfig
        }
      } // TODO(fkurniawan): add back in when FormatterEditor supports full MatchValue editor
      // {
      //     label: _('Matches'),
      //     value: 'matchValue',
      //     defaults: {
      //         areaValues: [{ match: 'foo', value: '#f00' }],
      //     },
      // },
      ],
      dataSelectors: [{
        label: i18n_1._('Value'),
        value: 'areaValues'
      }],
      defaultPalettesConfig: PresetPalettes_1.defaultPalettesConfig
    }
  }], [Object.assign(Object.assign({}, StaticBackgroundColorEditor_1.default), {
    editorProps: {
      labelPosition: 'left',
      themes: themes
    }
  })]]
}];
/**
 * visualization configuration
 */

var config = {
  /**
   * unique viz key
   */
  key: 'splunk.choropleth.svg',

  /**
   * viz name
   */
  name: 'Choropleth Svg',
  category: VizCategory_1.VizCategory.CHOROPLETH,

  /**
   * viz icon
   */
  icon: visualization_icons_1.ChoroplethSvg,
  dataContract: dataContract,
  size: size,
  defaultContext: defaultContext,
  optionsSchema: optionsSchema,
  requiredProps: ['svg'],
  editorConfig: editorConfig,
  events: {
    'area.click': {
      description: 'trigger when user clicks one area',
      payloadKeys: ['value', 'name']
    }
  },
  supports: [VizBehavior_1.VizBehavior.DYNAMIC_OPTIONS, VizBehavior_1.VizBehavior.EVENTS, VizBehavior_1.VizBehavior.PLACEHOLDER],
  themes: themes
};
exports.default = configUtils_1.enhanceConfig(config);

/***/ })
/******/ ]);
//# sourceMappingURL=ChoroplethSvg.js.map