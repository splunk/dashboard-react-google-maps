/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 206);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VizBehavior = void 0;
var VizBehavior;

(function (VizBehavior) {
  /**
   * Dynamic Options Behavior.
   * This allows visualization options to be powered by data
   *
   * **Example**
   *
   * sparklineValues: ">primary|seriesByIndex(0)"
   * would configure sparklineValues with an array of data points
   * coming from the first series in the primary datasource
   *
   */
  VizBehavior["DYNAMIC_OPTIONS"] = "dynamic-options";
  VizBehavior["EVENTS"] = "events";
  /**
   * Placeholder behavior: visualization will display a placeholder rather than fail if any of the `requiredProps` is
   * missing.
   * @type {string}
   */

  VizBehavior["PLACEHOLDER"] = "placeholder";
  VizBehavior["PAGE_AND_SORT"] = "page-and-sort";
})(VizBehavior = exports.VizBehavior || (exports.VizBehavior = {}));

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(22);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepMergeWithArrayOverrides = exports.extendStaticWrapperProps = void 0;

var lodash_1 = __webpack_require__(2);
/**
 * @method extendStaticWrapperProps
 * @param {Object} props
 * @param {DashboardVizType} props.Wrapper
 * @param {DashboardVizType} props.Visualization
 */


var extendStaticWrapperProps = function extendStaticWrapperProps(_ref) {
  var Wrapper = _ref.Wrapper,
      Visualization = _ref.Visualization;
  var extendProperties = ['propTypes', 'defaultProps', 'config'];
  extendProperties.forEach(function (prop) {
    if (Visualization[prop]) {
      Wrapper[prop] = Visualization[prop];
    }
  });
};

exports.extendStaticWrapperProps = extendStaticWrapperProps;
/**
 * helper to deeply merge objects while preserving arrays in earlier source objects
 * deeply nested primitive keys are merged similarly to lodash's defaultsDeep, while keys with arrays will be preserved if already present in the resultant merged object
 * this prevents default arrays from appending values to user-defined arrays (this occurs if the default array is longer than the user-defined one)
 *
 * @method deepMergeWithArrayOverrides
 * @param {Object} initial - target object to merge values into
 * @param {Object[]} sources - other default options to be merged into the resultant object if no explicit value is provided, with earlier args taking precedence over later ones
 *
 * @returns {Object}
 */

var deepMergeWithArrayOverrides = function deepMergeWithArrayOverrides(initial) {
  var clone = lodash_1.cloneDeep(initial);

  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(function (sourceToApply) {
    Object.keys(sourceToApply).forEach(function (sourceKey) {
      if (!clone.hasOwnProperty(sourceKey)) {
        clone[sourceKey] = lodash_1.cloneDeep(sourceToApply[sourceKey]);
      } // object merging excluding arrays


      if (clone[sourceKey] && _typeof(clone[sourceKey]) === 'object' && !Array.isArray(clone[sourceKey]) && _typeof(sourceToApply[sourceKey]) === 'object') {
        clone[sourceKey] = exports.deepMergeWithArrayOverrides(clone[sourceKey], sourceToApply[sourceKey]);
      }
    });
  });
  return clone;
};

exports.deepMergeWithArrayOverrides = deepMergeWithArrayOverrides;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generatePrecisionValues = exports.getInitialPreset = exports.isDynamicOption = exports.enhanceOptionsSchemaWithDynamicOptions = exports.enhanceConfig = void 0;

var lodash_1 = __webpack_require__(2);

var schemaUtils_1 = __webpack_require__(14);

var VizBehavior_1 = __webpack_require__(5);

var dynamicOptionsDSLType = {
  type: 'string',
  pattern: schemaUtils_1.DYNAMIC_OPTIONS_DSL_PATTERN
};
/**
 * Helper function to extend an options schema with dynamic options DSL
 * @param optionsSchema a visualization's options schema
 * @returns an updated options schema that additionally allows strings starting with > for each option
 */

function enhanceOptionsSchemaWithDynamicOptions(optionsSchema) {
  var enhancedOptionsSchema = {};
  Object.keys(optionsSchema).forEach(function (key) {
    var _a = optionsSchema[key],
        title = _a.title,
        description = _a.description,
        readOnly = _a.readOnly,
        writeOnly = _a.writeOnly,
        examples = _a.examples,
        defaultValue = _a.default,
        type = _a.type,
        properties = _a.properties,
        patternProperties = _a.patternProperties,
        remainingSchemaEntry = __rest(_a, ["title", "description", "readOnly", "writeOnly", "examples", "default", "type", "properties", "patternProperties"]);

    var annotations = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, title !== undefined && {
      title: title
    }), description !== undefined && {
      description: description
    }), readOnly !== undefined && {
      readOnly: readOnly
    }), writeOnly !== undefined && {
      writeOnly: writeOnly
    }), examples !== undefined && {
      examples: examples
    }), defaultValue !== undefined && {
      default: defaultValue
    });

    if (type === 'object') {
      enhancedOptionsSchema[key] = Object.assign(Object.assign(Object.assign(Object.assign({}, remainingSchemaEntry), annotations), {
        type: type
      }), properties && {
        properties: enhanceOptionsSchemaWithDynamicOptions(properties)
      });

      if (patternProperties) {
        var enhancedPatternProperties = {};
        Object.keys(patternProperties).forEach(function (key) {
          enhancedPatternProperties = Object.assign(Object.assign({}, enhancedPatternProperties), enhanceOptionsSchemaWithDynamicOptions(_defineProperty({}, key, patternProperties[key])));
        });
        enhancedOptionsSchema[key].patternProperties = enhancedPatternProperties;
      }
    } else {
      enhancedOptionsSchema[key] = Object.assign(Object.assign({}, annotations), {
        anyOf: [Object.assign(Object.assign({}, type !== undefined && {
          type: type
        }), remainingSchemaEntry), dynamicOptionsDSLType]
      });
    }
  });
  return enhancedOptionsSchema;
}

exports.enhanceOptionsSchemaWithDynamicOptions = enhanceOptionsSchemaWithDynamicOptions;
/**
 * Helper function to enhance a Visualization Config as needed based on behaviors specified in supports block
 * @param vizConfig a Visualization Config
 * @returns an enhanced Visualization Config containing updated config entries based on behaviors it supports
 */

function enhanceConfig(vizConfig) {
  var enhancedConfig = vizConfig;

  if (vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.DYNAMIC_OPTIONS) !== -1) {
    enhancedConfig.optionsSchema = enhanceOptionsSchemaWithDynamicOptions(vizConfig.optionsSchema);
  }

  return enhancedConfig;
}

exports.enhanceConfig = enhanceConfig;

function isDynamicOption(option) {
  return option && typeof option === 'string' && option.trim().startsWith('>') || false;
}

exports.isDynamicOption = isDynamicOption; // private helpers to improve readability of getInitialPreset
// this shouldn't be tested since this util isn't something that we expect to use outside of getInitialPreset

/**
 * this checks to make sure that all values within vizContext are compatible with the given preset's context to determine the initialPreset
 * if a preset has explicitly specified a key as being undefined, the vizContext must also has that key as undefined, or else this CANNOT be the initialPreset
 * the inverse is true; if a preset has key is NOT undefined, it must also be NOT undefined in the corresponding vizContext
 * the internal config contents are irrelevant (as the user could customize them in source), just as long as the presence of `undefined`s match up
 *
 * Since the presetConfigs have explicit undefined keys to override the existing config, we need to explicitly check the undefined values
 */

function hasCompatibleContexts(vizContext, presetContext) {
  var presetContextKeys = Object.keys(presetContext);
  return presetContextKeys.every(function (contextKey) {
    return presetContext[contextKey] === undefined && vizContext[contextKey] === undefined || presetContext[contextKey] !== undefined && vizContext[contextKey] !== undefined;
  });
}
/**
 * Checks to make sure that dynamic (non-dynamic) options in a given preset are also dynamic (non-dynamic) in the vizOptions
 */


function hasCompatibleOptions(vizOptions, presetOptions) {
  var presetOptionKeys = Object.keys(presetOptions);
  return presetOptionKeys.every(function (optionKey) {
    return isDynamicOption(presetOptions[optionKey]) === isDynamicOption(vizOptions[optionKey]);
  });
}
/**
 * Evaluates whether there is an initialPreset that fits the current state of vizContext + vizOptions
 * This function ignores extraneous vizOptions or vizContext keys, as they could be outside the scope of what the preset is intended to configure
 *
 * @param {Object} vizContext - the current vizContext definition
 * @param {Object} vizOptions - the current vizOptions definition
 * @param {PresetEntry[]} presets - the list of presets, one of which can be considered an initialPreset
 */


function getInitialPreset(vizContext, vizOptions, presets) {
  return presets.find(function (preset) {
    var presetContext = lodash_1.get(preset, ['value', 'context'], {});
    var presetOptions = lodash_1.get(preset, ['value', 'options'], {});
    var presetContextKeys = Object.keys(presetContext);
    var presetOptionKeys = Object.keys(presetOptions); // all presets have to explicitly specify which options to reset (i.e. need explicitly undefined keys)
    // if not, then the preset is invalid in config.ts

    if (presetContextKeys.length === 0 || presetOptionKeys.length === 0) return false;
    return hasCompatibleContexts(vizContext, presetContext) && hasCompatibleOptions(vizOptions, presetOptions);
  });
}

exports.getInitialPreset = getInitialPreset;
/**
 * generates number precision values for a Select editor
 *
 * @param {Number} numPrecisionValues - number of integer precision values to generate
 * @returns {{ label: string; value; string  }[]} array of { label, value } tuples
 */

function generatePrecisionValues(numPrecisionValues) {
  return lodash_1.range(0, numPrecisionValues + 1).map(function (i) {
    return {
      label: "".concat(i, " (0").concat(i > 0 ? '.' : '').concat('0'.repeat(i), ")"),
      value: i
    };
  });
}

exports.generatePrecisionValues = generatePrecisionValues;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/Message");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorUtils");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var SizeAwareWrapper_1 = __webpack_require__(17);

var style_1 = __webpack_require__(13);

var colorUtils_1 = __webpack_require__(11);

var Item = styled_components_1.default.div.attrs(function (_ref) {
  var width = _ref.width;
  return {
    style: {
      width: style_1.toPx(width)
    }
  };
}).withConfig({
  displayName: "FixedSizeContainer__Item",
  componentId: "sc-1yhgpod-0"
})(["position:relative;background-color:", "};"], function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
}); // Use `.attrs()` for highly dynamic styles. Ref: https://github.com/styled-components/styled-components/issues/134#issuecomment-312415291

var FixSizeItem = styled_components_1.default.div.attrs(function (_ref2) {
  var width = _ref2.width,
      height = _ref2.height;
  return {
    style: Object.assign(Object.assign({}, width && {
      width: style_1.toPx(width)
    }), height && {
      height: style_1.toPx(height)
    })
  };
}).withConfig({
  displayName: "FixedSizeContainer__FixSizeItem",
  componentId: "sc-1yhgpod-1"
})(["position:relative;flex-direction:column;flex:1;display:flex;background-color:", "};"], function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
});
var ItemContent = styled_components_1.default.div.withConfig({
  displayName: "FixedSizeContainer__ItemContent",
  componentId: "sc-1yhgpod-2"
})(["position:relative;min-height:100px;width:100%;"]);
var FixSizeItemContent = styled_components_1.default.div.withConfig({
  displayName: "FixedSizeContainer__FixSizeItemContent",
  componentId: "sc-1yhgpod-3"
})(["min-height:0px;flex:1;position:relative;box-sizing:border-box;"]);

var withFixedSizeContainer = function withFixedSizeContainer(Viz) {
  var FixedSizeContainer = function FixedSizeContainer(props) {
    var width = props.width,
        height = props.height,
        backgroundColor = props.backgroundColor;

    if (!height) {
      return React.createElement(Item, {
        "data-test": "item",
        width: width,
        backgroundColor: backgroundColor
      }, React.createElement(ItemContent, null, React.createElement(Viz, Object.assign({}, props))));
    }

    return React.createElement(FixSizeItem, {
      "data-test": "fix-size-item",
      width: width,
      height: height,
      backgroundColor: backgroundColor
    }, React.createElement(FixSizeItemContent, null, React.createElement(SizeAwareWrapper_1.default, null, function (_ref3) {
      var newWidth = _ref3.width,
          newHeight = _ref3.height;
      return React.createElement(Viz, Object.assign({}, props, {
        width: newWidth,
        height: newHeight
      }));
    })));
  };

  FixedSizeContainer.displayName = 'withFixedSizeContainer';
  return FixedSizeContainer;
};

exports.default = withFixedSizeContainer;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/style");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/schemaUtils");

/***/ }),
/* 15 */,
/* 16 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SizeAwareWrapper");

/***/ }),
/* 18 */,
/* 19 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/variables");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/numberUtils");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/pick");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/typeof");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSortingParams = exports.SortParamsPropTypes = void 0;

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var DataSource_1 = __webpack_require__(33);

exports.SortParamsPropTypes = T.shape({
  currentSortKey: T.string,
  currentSortDir: T.oneOf(DataSource_1.validSortDirs),
  onSort: T.func
});

var getSortingParams = function getSortingParams(_ref) {
  var requestParams = _ref.requestParams,
      onRequestParamsChange = _ref.onRequestParamsChange;
  var currentSortKey;
  var currentSortDir;
  var nextSortDirMap = {
    asc: 'desc',
    desc: 'asc',
    none: 'asc'
  };
  var onSort;

  if (lodash_1.isFunction(onRequestParamsChange)) {
    if (requestParams && lodash_1.has(requestParams, 'sort')) {
      currentSortKey = Object.keys(requestParams.sort).shift();
      currentSortDir = requestParams.sort[currentSortKey];
    } // undid memoization since there is a dependency on requestParams, which is a deeply nested object


    onSort = function onSort(e, _ref2) {
      var sortKey = _ref2.sortKey,
          sortDir = _ref2.sortDir;

      if (typeof sortKey === 'string') {
        var nextSortDir = lodash_1.has(nextSortDirMap, sortDir) ? nextSortDirMap[sortDir] : 'none';
        onRequestParamsChange(Object.assign(Object.assign({}, requestParams), {
          offset: 0,
          sort: _defineProperty({}, sortKey, nextSortDir)
        }));
      } else {
        onRequestParamsChange(requestParams);
      }
    };
  }

  return {
    currentSortKey: currentSortKey,
    currentSortDir: currentSortDir,
    onSort: onSort
  };
};

exports.getSortingParams = getSortingParams;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPaginationParams = exports.PaginatorParamsPropTypes = void 0;

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

exports.PaginatorParamsPropTypes = T.shape({
  isPaging: T.bool,
  current: T.number,
  totalPages: T.number,
  onChange: T.func
});

var getPaginationParams = function getPaginationParams(_ref) {
  var requestParams = _ref.requestParams,
      meta = _ref.meta,
      onRequestParamsChange = _ref.onRequestParamsChange;
  var totalCount = meta && meta.totalCount || 0;
  var offset = requestParams && requestParams.offset || 0;
  var count = requestParams && requestParams.count;
  var totalPages = typeof count === 'number' && count > 0 ? Math.ceil(totalCount / count) : 0;
  var current = typeof count === 'number' && count > 0 ? Math.floor(offset / count) + 1 : 0;
  var isPaging = totalPages > 1 && lodash_1.isFunction(onRequestParamsChange);

  var onChangeHandler = function onChangeHandler(e, _ref2) {
    var page = _ref2.page,
        countArg = _ref2.count;
    var newParams = lodash_1.cloneDeep(requestParams);

    if (typeof countArg === 'number') {
      newParams.count = countArg;
      newParams.offset = 0;
    }

    var pageCount = typeof newParams.count === 'number' ? newParams.count : 10;

    if (typeof page === 'number' && page > 0) {
      newParams.count = pageCount;
      newParams.offset = (page - 1) * pageCount;
    }

    onRequestParamsChange(newParams);
  };

  return {
    isPaging: isPaging,
    current: current,
    totalPages: totalPages,
    onChange: lodash_1.isFunction(onRequestParamsChange) ? onChangeHandler : lodash_1.noop
  };
};

exports.getPaginationParams = getPaginationParams;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldShowIconPlaceholder = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var i18n_1 = __webpack_require__(3);

var Message_1 = __webpack_require__(9);

var FixedSizeContainer_1 = __webpack_require__(12);
/**
 * @method shouldShowIconPlaceholder
 * @param {object} dataSources
 * @param {boolean} loading
 * @returns {boolean}
 */


var shouldShowIconPlaceholder = function shouldShowIconPlaceholder(dataSources) {
  var loading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var data = lodash_1.get(dataSources, 'primary.data.columns[0]', undefined);
  var noData = data === undefined;
  var fields = lodash_1.get(dataSources, 'primary.data.fields[0]', undefined);
  var noFields = fields === undefined;
  return loading || noData || noFields;
};

exports.shouldShowIconPlaceholder = shouldShowIconPlaceholder;
var propTypes = {
  icon: T.func,
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  backgroundColor: T.string
};
/**
 * @method IconPlaceholder
 * @param {IconPlaceholderProps} props
 * @returns {React.ReactElement}
 */

var IconPlaceholder = function IconPlaceholder(props) {
  var width = props.width,
      height = props.height,
      icon = props.icon;

  if (icon) {
    return React.createElement(icon, {
      style: {
        left: '50%',
        top: '50%',
        color: 'grey',
        position: 'absolute',
        transform: 'translate(-50%, -50%)'
      },
      width: '50%',
      height: '50%'
    });
  }

  return React.createElement(Message_1.default, {
    width: width,
    height: height,
    level: "warning",
    message: i18n_1._('No DataSource Connected')
  });
};

IconPlaceholder.propTypes = propTypes;
IconPlaceholder.defaultProps = {
  width: '100%',
  height: 250
};
exports.default = FixedSizeContainer_1.default(IconPlaceholder);

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VizCategory = void 0;
var VizCategory;

(function (VizCategory) {
  VizCategory["SINGLE_VALUE"] = "Single Value";
  VizCategory["TRENDS"] = "Trends";
  VizCategory["COMPARISONS"] = "Comparisons";
  VizCategory["TABLE"] = "Table";
  VizCategory["GAUGE"] = "Gauge";
  VizCategory["DISTRIBUTIONS"] = "Distributions";
  VizCategory["CHOROPLETH"] = "Choropleth Maps";
  VizCategory["SHAPES"] = "Shapes";
  VizCategory["MISC"] = "misc";
  VizCategory["FLOW"] = "Flow";
})(VizCategory = exports.VizCategory || (exports.VizCategory = {}));

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);

var getSettingsFromThemedProps_1 = __webpack_require__(28);

var Options_1 = __webpack_require__(29);

var SanitizeProps_1 = __webpack_require__(30);

var styled_components_1 = __webpack_require__(4);

var SplunkVisualization_1 = __webpack_require__(31);

var VizBehavior_1 = __webpack_require__(5);

var getSorting_1 = __webpack_require__(23);

var getPagination_1 = __webpack_require__(24);

var useDeepMemo_1 = __webpack_require__(34);

var JSONSchemaUtils_1 = __webpack_require__(35);

var MissingPropsMessage_1 = __webpack_require__(36);

var withEditModeCover_1 = __webpack_require__(37);

var withPlaceholder_1 = __webpack_require__(38);

var hocUtils_1 = __webpack_require__(7);
/**
 * hoc that wraps a pure react visualization in a Dashboard visualization
 * @param {DashboardVizOpts} opts
 * @returns {HOC}
 */


var withDashboardViz = function withDashboardViz(opts) {
  var ReactViz = opts.ReactViz,
      vizConfig = opts.vizConfig,
      _opts$computeVizProps = opts.computeVizProps,
      computeVizProps = _opts$computeVizProps === void 0 ? function () {} : _opts$computeVizProps,
      useIconPlaceholder = opts.useIconPlaceholder; // sanitizing props before sending them to reactviz.

  var SanitizedReactViz = SanitizeProps_1.withSanitizedProps(ReactViz);
  var defaultOptions = JSONSchemaUtils_1.pickFieldFromJSONSchema(vizConfig.optionsSchema, 'default');

  var DashboardViz = function DashboardViz(props) {
    var mode = props.mode,
        hasEventHandlers = props.hasEventHandlers,
        dataSources = props.dataSources,
        options = props.options,
        _props$context = props.context,
        context = _props$context === void 0 ? {} : _props$context,
        width = props.width,
        height = props.height,
        onComputedProps = props.onComputedProps,
        onEventTrigger = props.onEventTrigger,
        theme = props.theme,
        onRequestParamsChange = props.onRequestParamsChange;

    var themeFunc = function themeFunc(themeVar) {
      var _a, _b;

      return (_b = (_a = vizConfig.themes)[themeVar]) === null || _b === void 0 ? void 0 : _b.call(_a, props);
    };

    var bgColorFromTheme = themeFunc('defaultBackgroundColor');

    var _getSettingsFromTheme = getSettingsFromThemedProps_1.default({
      theme: theme
    }),
        currentThemeFamily = _getSettingsFromTheme.family,
        currentThemeColorScheme = _getSettingsFromTheme.colorScheme,
        currentThemeDensity = _getSettingsFromTheme.density;

    var evaluatedOptions = {}; // evaluatedOptions need to be initialized as an empty object

    evaluatedOptions = useDeepMemo_1.useDeepMemo(function () {
      try {
        return Options_1.Options.evaluate({
          context: lodash_1.defaultsDeep({}, context, vizConfig.defaultContext),
          options: hocUtils_1.deepMergeWithArrayOverrides({}, options, defaultOptions)
        }, dataSources, themeFunc);
      } catch (e) {
        console.error("unexpected error evaluating options:  + ".concat(e.message));
        return {};
      }
    }, [currentThemeFamily, currentThemeColorScheme, currentThemeDensity, options, context, dataSources]); // useEffect hook needs to be initialized before any early returns
    // this is in accordance with the order of hook calls being the same on each render https://reactjs.org/docs/hooks-rules.html#explanation

    React.useEffect(function () {
      onComputedProps(evaluatedOptions);
    }); // present warning message if any required props are missing

    var _vizConfig$requiredPr = vizConfig.requiredProps,
        requiredProps = _vizConfig$requiredPr === void 0 ? [] : _vizConfig$requiredPr,
        supports = vizConfig.supports;
    var missing = MissingPropsMessage_1.missingKeys(requiredProps, evaluatedOptions);

    if (missing.length > 0 && supports.includes(VizBehavior_1.VizBehavior.PLACEHOLDER)) {
      return React.createElement(MissingPropsMessage_1.default, {
        "data-test": "missing-props-message",
        width: width,
        height: height,
        missingProps: missing,
        backgroundColor: bgColorFromTheme
      });
    } // events


    var eventCallbackProps = {};

    if (hasEventHandlers && mode === 'view' && vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.EVENTS) > -1) {
      var supportedEvents = vizConfig.events;
      Object.keys(supportedEvents).forEach(function (eventName) {
        var eventCallbackPropName = lodash_1.camelCase("on.".concat(eventName));
        eventCallbackProps[eventCallbackPropName] = null; // todo: refactor single value and single value icon to send payload from viz
        // then remove these lines

        var payloadKeys = supportedEvents[eventName].payloadKeys;
        var payload = {};

        if (Array.isArray(payloadKeys) && payloadKeys.length) {
          payloadKeys.forEach(function (p) {
            return payload[p] = evaluatedOptions[p];
          });
        }

        eventCallbackProps[eventCallbackPropName] = function (ev) {
          if (ev && ev.payload) {
            payload = ev.payload;
          }

          return onEventTrigger({
            originalEvent: ev,
            payload: payload,
            type: eventName
          });
        };
      });
    } // compute pure viz props which are not from options


    var computedVizProps = computeVizProps(Object.assign(Object.assign(Object.assign(Object.assign({}, props), evaluatedOptions), eventCallbackProps), {
      themeFunc: themeFunc
    }));
    /**
     * PAGE_AND_SORT behavior
     *
     * Some visualizations, like table, requires metadata about the datasource,
     * like total number of results, current count, offset, and sort, for rendering
     * paginator and sorting direction. In this approach, the visualization
     * allow users to set 'paginateDataSourceKey' to select which datasource
     * should the visualization extract the metadata from. It defaults to 'primary' datasource.
     * The visualization config should set the PAGE_AND_SORT behavior to receive
     * 'requestParams', 'meta' and onRequestParams callback as props.
     *
     * In future, we could automatically detect which all datasources are being used
     * and bind those magically to pagination/sorting behavior.
     */

    var dataSourceMetadata = {};
    var OptionKey = 'paginateDataSourceKey';
    var paginateDataSourceKey = lodash_1.has(evaluatedOptions, OptionKey) && evaluatedOptions[OptionKey] || 'primary';

    if (vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.PAGE_AND_SORT) > -1 && lodash_1.has(dataSources, paginateDataSourceKey)) {
      var requestParams = lodash_1.get(dataSources, [paginateDataSourceKey, 'requestParams'], {});
      var meta = lodash_1.get(dataSources, [paginateDataSourceKey, 'meta'], {});

      var handleRequestParamsChange = function handleRequestParamsChange(payload) {
        return onRequestParamsChange(paginateDataSourceKey, payload);
      };

      var sortParams = getSorting_1.getSortingParams({
        requestParams: requestParams,
        meta: meta,
        onRequestParamsChange: handleRequestParamsChange
      });
      var paginatorParams = getPagination_1.getPaginationParams({
        requestParams: requestParams,
        meta: meta,
        onRequestParamsChange: handleRequestParamsChange
      });
      dataSourceMetadata = {
        sortParams: sortParams,
        paginatorParams: paginatorParams
      };
    }

    return React.createElement(SanitizedReactViz, Object.assign({
      mode: mode,
      width: width,
      height: height
    }, evaluatedOptions, computedVizProps, eventCallbackProps, dataSourceMetadata));
  };

  DashboardViz.propTypes = Object.assign(Object.assign({}, SplunkVisualization_1.default.propTypes), ReactViz.propTypes);
  DashboardViz.defaultProps = Object.assign(Object.assign(Object.assign({}, SplunkVisualization_1.default.defaultProps), ReactViz.defaultProps), {
    // using withTheme requires component to receive theme prop. In case the consumer did not provide ThemeProvider, a default empty object will prevent warnings.
    theme: {}
  }); // attach viz config

  DashboardViz.config = vizConfig; // @ts-ignore: TODO fix sc upgrade TS issues

  return styled_components_1.withTheme(withPlaceholder_1.default(withEditModeCover_1.default(DashboardViz), useIconPlaceholder));
};

exports.default = withDashboardViz;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/getSettingsFromThemedProps");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-encoding/Options");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SanitizeProps");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(10);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INITIAL_HEIGHT = exports.INITIAL_WIDTH = void 0;
/* eslint-disable react/no-unused-prop-types,react/prefer-stateless-function */

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var VizActionHandler_1 = __webpack_require__(32); // this is identical to the initial height and width we use in BaseVisualization in dashboard-visualizations


exports.INITIAL_WIDTH = 250;
exports.INITIAL_HEIGHT = 250;
/**
 * A Splunk visualization
 */

var SplunkVisualization = function SplunkVisualization() {
  _classCallCheck(this, SplunkVisualization);
};

SplunkVisualization.propTypes = {
  /**
   * display mode
   */
  mode: T.oneOf(['view', 'edit', 'export']).isRequired,

  /**
   * width in pixel or string, defaults to 100%
   */
  width: T.oneOfType([T.string, T.number]).isRequired,

  /**
   * height in pixel or string
   */
  height: T.oneOfType([T.string, T.number]).isRequired,

  /**
   * visualization context used for dynamic option evaluation
   */
  context: T.object,

  /**
   * visualization formatting options
   */
  options: T.object,

  /**
   * A callback to update formatting options
   */
  onOptionsChange: T.func,

  /**
   * datasource state which include data and request params, object key indicate the datasource type.
   */
  dataSources: T.objectOf(T.shape({
    /**
     * current request params
     */
    requestParams: T.object,

    /**
     * current dataset
     */
    data: T.shape({
      fields: T.array,
      columns: T.array
    }),

    /**
     * error
     */
    error: T.shape({
      level: T.string,
      message: T.string
    }),

    /**
     * meta data that came with the dataset
     */
    meta: T.object
  })),

  /**
   * A callback to trigger event
   */
  onEventTrigger: T.func,

  /**
   * Inform viz if there are handlers listening to events
   */
  hasEventHandlers: T.bool,

  /**
   * A callback to communicate computed props to a consumer
   */
  onComputedProps: T.func,

  /**
   * A callback to obtain visualization api
   */
  vizActionHandlerRef: T.func,
  loading: T.bool,
  theme: T.object,

  /**
   * A callback to request new data with updated request params
   */
  onRequestParamsChange: T.func
};
/**
 *
 */

SplunkVisualization.defaultProps = {
  // BaseVisualization in dashboard-visualizations uses 100% for width but 250 for height
  width: '100%',
  height: exports.INITIAL_HEIGHT,
  dataSources: {},
  onEventTrigger: function onEventTrigger() {
    return {};
  },
  mode: 'view',
  hasEventHandlers: false,
  options: {},
  context: {},
  onOptionsChange: function onOptionsChange() {
    return {};
  },
  vizActionHandlerRef: function vizActionHandlerRef() {
    return new VizActionHandler_1.DefaultVizActionHandler();
  },
  onComputedProps: function onComputedProps() {
    return {};
  },
  loading: false,
  onRequestParamsChange: lodash_1.noop
};
exports.default = SplunkVisualization;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(10);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultVizActionHandler = void 0;

var DefaultVizActionHandler = /*#__PURE__*/function () {
  function DefaultVizActionHandler() {
    _classCallCheck(this, DefaultVizActionHandler);
  }

  _createClass(DefaultVizActionHandler, [{
    key: "focus",
    value: function focus() {//noop
    }
  }, {
    key: "snapshot",
    value: function snapshot() {
      return null; //noop
    }
  }]);

  return DefaultVizActionHandler;
}();

exports.DefaultVizActionHandler = DefaultVizActionHandler;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validSortDirs = void 0;
exports.validSortDirs = ['asc', 'desc', 'none'];

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDeepMemo = void 0;

var react_1 = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);
/**
 * This hook evaluates and stores the result of a passed function and only
 * re-evaluates the function when passed dependencies change.
 *
 * It is different from the internal React useMemo in the following aspects:
 * - it only stores the last evaluated result
 * - it uses a deep equality check to determine if dependencies have changed
 *
 * Inspired by apollo-client's useDeepMemo
 *
 * @param fn the function to be executed and
 * @param dependencies an array of dependencies
 */


var useDeepMemo = function useDeepMemo(fn, dependencies) {
  var ref = react_1.useRef();

  if (!ref.current || !lodash_1.isEqual(dependencies, ref.current.dependencies)) {
    ref.current = {
      dependencies: dependencies,
      value: fn()
    };
  }

  return ref.current.value;
};

exports.useDeepMemo = useDeepMemo;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickFieldFromJSONSchema = void 0;

var lodash_1 = __webpack_require__(2);

var pickFieldFromJSONSchema = function pickFieldFromJSONSchema(optionsSchema) {
  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  return Object.keys(optionsSchema).reduce(function (accum, k) {
    if (lodash_1.has(optionsSchema[k], fieldName)) {
      accum[k] = optionsSchema[k][fieldName];
    } else if (lodash_1.get(optionsSchema, [k, 'type']) === 'object' && lodash_1.has(optionsSchema[k], 'properties')) {
      var nestedSchema = exports.pickFieldFromJSONSchema(optionsSchema[k].properties, fieldName);

      if (!lodash_1.isEmpty(nestedSchema)) {
        accum[k] = nestedSchema;
      }
    }

    return accum;
  }, {});
};

exports.pickFieldFromJSONSchema = pickFieldFromJSONSchema;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MissingPropsMessage = exports.missingKeys = exports.isMissing = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var i18n_1 = __webpack_require__(3);

var Message_1 = __webpack_require__(9);

var FixedSizeContainer_1 = __webpack_require__(12);
/**
 * @method isMissing
 * @param {any} v
 * @returns {boolean} true if the input value === null or undefined
 */


var isMissing = function isMissing(v) {
  return v === null || v === undefined;
};

exports.isMissing = isMissing;
/**
 * @method misskingKeys
 * @param {string[]} keys
 * @param {object} target
 * @returns {string[]} the keys of missing required props
 */

var missingKeys = function missingKeys(keys, target) {
  return keys.filter(function (k) {
    return exports.isMissing(target[k]);
  });
};

exports.missingKeys = missingKeys;
var propTypes = {
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  backgroundColor: T.string,
  missingProps: T.arrayOf(T.string)
};
/**
 * @method MissingPropsMessage
 * @param {MissingPropsProps} props
 * @returns {React.ReactElement}
 */

var MissingPropsMessage = function MissingPropsMessage(props) {
  var width = props.width,
      height = props.height,
      missingProps = props.missingProps;
  return React.createElement(Message_1.default, {
    "data-test": "message",
    width: width,
    height: height,
    message: i18n_1._("Missing property: ".concat(missingProps.join(', ')))
  });
};

exports.MissingPropsMessage = MissingPropsMessage;
exports.MissingPropsMessage.propTypes = propTypes;
exports.MissingPropsMessage.defaultProps = {
  width: '100%',
  height: 250
};
exports.default = FixedSizeContainer_1.default(exports.MissingPropsMessage);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var hocUtils_1 = __webpack_require__(7);

var Cover = styled_components_1.default.div.withConfig({
  displayName: "withEditModeCover__Cover",
  componentId: "sc-1gsbnxb-0"
})(["position:absolute;left:0;right:0;top:0;bottom:0;"]);
var Blocker = styled_components_1.default.div.withConfig({
  displayName: "withEditModeCover__Blocker",
  componentId: "sc-1gsbnxb-1"
})(["position:relative;width:100%;height:100%;"]);
/**
 * HOC that renders a cover layer in edit mode
 * @method withEditModeCover
 * @param {ExtendedDashViz} Visualization
 * @returns {ExtendedDashViz} Wrapper
 */

var withEditModeCover = function withEditModeCover(Visualization) {
  var Wrapper = function Wrapper(props) {
    var mode = props.mode;
    return React.createElement(Blocker, null, React.createElement(Visualization, Object.assign({}, props)), mode === 'edit' && React.createElement(Cover, {
      "data-test": "edit-mode-cover"
    }));
  };

  hocUtils_1.extendStaticWrapperProps({
    Wrapper: Wrapper,
    Visualization: Visualization
  });
  return Wrapper;
};

exports.default = withEditModeCover;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var colorUtils_1 = __webpack_require__(11);

var IconPlaceholder_1 = __webpack_require__(25);

var VizBehavior_1 = __webpack_require__(5);

var hocUtils_1 = __webpack_require__(7);

var withPlaceholder = function withPlaceholder(Visualization) {
  var useIconPlaceholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IconPlaceholder_1.shouldShowIconPlaceholder;
  var config = Visualization.config;
  var themes = config.themes;

  var Wrapper = function Wrapper(props) {
    var _a;

    var dataSources = props.dataSources,
        loading = props.loading,
        options = props.options,
        height = props.height,
        width = props.width;
    var showPlaceholder = useIconPlaceholder(dataSources, loading, options);
    var bgColorFromTheme = colorUtils_1.isColor(options === null || options === void 0 ? void 0 : options.backgroundColor) ? options === null || options === void 0 ? void 0 : options.backgroundColor : (_a = themes === null || themes === void 0 ? void 0 : themes.defaultBackgroundColor) === null || _a === void 0 ? void 0 : _a.call(themes, props);

    if (config.supports.includes(VizBehavior_1.VizBehavior.PLACEHOLDER) && showPlaceholder) {
      return React.createElement(IconPlaceholder_1.default, {
        "data-test": "icon-placeholder",
        icon: config.icon,
        width: width,
        height: height,
        backgroundColor: bgColorFromTheme
      });
    }

    return React.createElement(Visualization, Object.assign({}, props));
  };

  hocUtils_1.extendStaticWrapperProps({
    Wrapper: Wrapper,
    Visualization: Visualization
  });
  return Wrapper;
};

exports.default = withPlaceholder;

/***/ }),
/* 39 */,
/* 40 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-color-palettes");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-icons");

/***/ }),
/* 43 */,
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var i18n_1 = __webpack_require__(3);

var background = function background(_ref) {
  var themes = _ref.themes,
      labelPosition = _ref.labelPosition;
  return [{
    label: i18n_1._('Background'),
    option: 'backgroundColor',
    editor: 'editor.color',
    editorProps: {
      labelPosition: labelPosition || 'top',
      themes: themes
    }
  }];
};

exports.default = background;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(40);

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constructFieldsAndColumns = exports.toArrayForSeries = exports.isMultiSeriesData = exports.convertOverlayFields = exports.convertY2AxisOptions = exports.mapToValues = exports.truncateData = exports.getAnnotations = void 0;

var lodash_1 = __webpack_require__(2);
/**
 * Get formatted annotations
 * @method getAnnotations
 * @param {Object} options
 * @param {Array} options.annotationX
 * @param {Array} options.annotationColor
 * @param {Array} options.annotationLabel
 * @returns {Array}
 */


var getAnnotations = function getAnnotations(_ref) {
  var annotationX = _ref.annotationX,
      annotationColor = _ref.annotationColor,
      annotationLabel = _ref.annotationLabel;
  return annotationX && annotationX.length ? annotationX.map(function (timestamp, i) {
    return {
      color: annotationColor && annotationColor[i],
      label: annotationLabel && annotationLabel[i],
      time: timestamp
    };
  }) : [];
};

exports.getAnnotations = getAnnotations;
/**
 * Truncate the result set to given limit
 * @method truncateData
 * @param {Object} dataSet - dataSources.primary.data
 * @param {Number|String} truncationLimit - options['chart.resultTruncationLimit']
 * @returns {Object}
 */

var truncateData = function truncateData(dataSet, truncationLimit) {
  if (!dataSet) {
    return null;
  }

  var limit = parseInt(truncationLimit, 10);

  if (!limit || limit <= 0) {
    return dataSet;
  }

  var truncatedData = Object.assign({}, dataSet);
  truncatedData.columns = truncatedData.columns.map(function (columnData) {
    return columnData.slice(0, limit);
  });
  return truncatedData;
};

exports.truncateData = truncateData;
/**
 * Helper method to update the option values into the values that SC accepts
 * @method mapToValues
 * @param {Object} options
 * @returns {Object}
 */

var mapToValues = function mapToValues(optionValuesSCMapping) {
  return function (options) {
    var convertedOptions = Object.assign({}, options);
    Object.keys(optionValuesSCMapping).forEach(function (key) {
      if (lodash_1.has(options, key)) {
        var updatedValue = optionValuesSCMapping[key][options[key]];

        if (!lodash_1.isUndefined(updatedValue)) {
          convertedOptions[key] = updatedValue;
        }
      }
    });
    return convertedOptions;
  };
};

exports.mapToValues = mapToValues;
/**
 * Helper method to process options related to y2Fields
 * @method convertY2AxisOptions
 * @param {Object} originalOptions
 * @returns {Object}
 */

var convertY2AxisOptions = function convertY2AxisOptions(_a) {
  var y2Fields = _a.y2Fields,
      originalOptions = __rest(_a, ["y2Fields"]);

  var convertedOptions = Object.assign({}, originalOptions);

  if (y2Fields) {
    convertedOptions['axisY2.enabled'] = true;
    convertedOptions['axisY2.fields'] = lodash_1.isArray(y2Fields) ? y2Fields.filter(function (name) {
      return name;
    }).join(',') : y2Fields;
  }

  return convertedOptions;
};

exports.convertY2AxisOptions = convertY2AxisOptions;
/**
 * Helper method to format value for overlayFields
 * @method convertOverlayFields
 * @param {Object} originalOptions
 * @returns {Object}
 */

var convertOverlayFields = function convertOverlayFields(originalOptions) {
  var convertedOptions = Object.assign({}, originalOptions);
  var overlayFields = originalOptions.overlayFields;

  if (overlayFields) {
    convertedOptions.overlayFields = Array.isArray(overlayFields) ? overlayFields.filter(function (field) {
      return field;
    }).map(function (field) {
      return field.trim();
    }).join(',') : overlayFields;
  }

  return convertedOptions;
};

exports.convertOverlayFields = convertOverlayFields;
/**
 * checks whether data is multi series data
 * @param {array} data array
 * @return {Boolean}
 */

var isMultiSeriesData = function isMultiSeriesData(data) {
  return Array.isArray(data) && Array.isArray(data[0]);
};

exports.isMultiSeriesData = isMultiSeriesData;
/**
 * checks whether data is multi series data and returns value as array
 * @param {array} data array
 * @param {*} value to return as array
 * @return {array}
 */

var toArrayForSeries = function toArrayForSeries(data, value) {
  return exports.isMultiSeriesData(data) ? value : [value];
};

exports.toArrayForSeries = toArrayForSeries;

var constructFieldsAndColumns = function constructFieldsAndColumns(_ref2) {
  var _ref2$x = _ref2.x,
      x = _ref2$x === void 0 ? [] : _ref2$x,
      _ref2$y = _ref2.y,
      y = _ref2$y === void 0 ? [] : _ref2$y,
      xField = _ref2.xField,
      yFields = _ref2.yFields,
      y2 = _ref2.y2,
      y2Fields = _ref2.y2Fields;
  var columns = [x.map(String)].concat(_toConsumableArray(exports.toArrayForSeries(y, y).map(function (series) {
    return series.map(String);
  })));
  var yFieldsArray = exports.toArrayForSeries(y, yFields);
  var fields = [{
    name: xField
  }].concat(_toConsumableArray(yFieldsArray.map(function (field) {
    return {
      name: field
    };
  }))); // splunk-charting requires y2 to be part of columns
  // when y & y2 options are configured with different (mutually exclusive) series
  // y2 columns need to be added to columns

  if (y2Fields) {
    var y2FieldsArray = exports.toArrayForSeries(y2, y2Fields);
    var y2AsArray = exports.toArrayForSeries(y2, y2).map(function (series) {
      return series === null || series === void 0 ? void 0 : series.map(String);
    });
    y2FieldsArray.forEach(function (y2Field, index) {
      if (yFieldsArray.indexOf(y2Field) === -1 && y2AsArray[index]) {
        fields.push({
          name: y2Field
        });
        columns.push(y2AsArray[index]);
      }
    });
  }

  return {
    columns: columns,
    fields: fields
  };
};

exports.constructFieldsAndColumns = constructFieldsAndColumns;

/***/ }),
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/slicedToArray");

/***/ }),
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */
/***/ (function(module, exports) {

module.exports = require("d3-scale");

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = __webpack_require__(60);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.truncateAxisLabelText = exports.isBubbleSelected = exports.isSomethingSelected = exports.getDataByRows = exports.createValueScale = exports.getScales = exports.getChartAreaDimensions = exports.getColorCategoryMapping = exports.GRAYSCALE_FILTER_ID = exports.BUBBLE_LABELS_TYPES = exports.COLOR_MODE_TYPES = exports.BUBBLE_SCALE_TYPES = exports.BUBBLE_ROW_SCALE_TYPES = exports.AXIS_ORIENTATION_TYPES = void 0;

var d3_scale_1 = __webpack_require__(72);
/**
 * @enum {AXIS_ORIENTATION_TYPES}
 */


var AXIS_ORIENTATION_TYPES;

(function (AXIS_ORIENTATION_TYPES) {
  AXIS_ORIENTATION_TYPES["VERTICAL"] = "vertical";
  AXIS_ORIENTATION_TYPES["HORIZONTAL"] = "horizontal";
})(AXIS_ORIENTATION_TYPES = exports.AXIS_ORIENTATION_TYPES || (exports.AXIS_ORIENTATION_TYPES = {}));
/**
 * @enum {BUBBLE_ROW_SCALE_TYPES}
 */


var BUBBLE_ROW_SCALE_TYPES;

(function (BUBBLE_ROW_SCALE_TYPES) {
  BUBBLE_ROW_SCALE_TYPES["GLOBAL"] = "global";
  BUBBLE_ROW_SCALE_TYPES["ROW"] = "row";
})(BUBBLE_ROW_SCALE_TYPES = exports.BUBBLE_ROW_SCALE_TYPES || (exports.BUBBLE_ROW_SCALE_TYPES = {}));
/**
 * @enum {BUBBLE_SCALE_TYPES}
 */


var BUBBLE_SCALE_TYPES;

(function (BUBBLE_SCALE_TYPES) {
  BUBBLE_SCALE_TYPES["RADIUS"] = "radius";
  BUBBLE_SCALE_TYPES["AREA"] = "area";
})(BUBBLE_SCALE_TYPES = exports.BUBBLE_SCALE_TYPES || (exports.BUBBLE_SCALE_TYPES = {}));
/**
 * @enum {COLOR_MODE_TYPES}
 */


var COLOR_MODE_TYPES;

(function (COLOR_MODE_TYPES) {
  COLOR_MODE_TYPES["SEQUENTIAL"] = "sequential";
  COLOR_MODE_TYPES["CATEGORICAL"] = "categorical";
})(COLOR_MODE_TYPES = exports.COLOR_MODE_TYPES || (exports.COLOR_MODE_TYPES = {}));
/**
 * @enum {BUBBLE_LABELS_TYPES}
 */


var BUBBLE_LABELS_TYPES;

(function (BUBBLE_LABELS_TYPES) {
  BUBBLE_LABELS_TYPES["ALL"] = "all";
  BUBBLE_LABELS_TYPES["MAX"] = "max";
  BUBBLE_LABELS_TYPES["NONE"] = "none";
})(BUBBLE_LABELS_TYPES = exports.BUBBLE_LABELS_TYPES || (exports.BUBBLE_LABELS_TYPES = {}));
/**
 * @string GRAYSCALE_FILTER_ID
 */


exports.GRAYSCALE_FILTER_ID = "punchcard-grayscale-filter-id-".concat(Math.floor(Math.random() * 1000));
var X_AXIS_HEIGHT = 15;
var Y_AXIS_WIDTH = 77;
var MARGIN = 10;
var LEGEND_WIDTH = 135;
var HORIZONTAL_SPACE_FOR_SINGLE_CHAR = 6;
/**
 * get a mapping of categories to colors given all categories
 * @method getColorCategoryMapping
 * @param {Object} input
 * @param {Array<String>} category
 * @param {COLOR_MODE_TYPES} colorMode
 * @param {Array<String>} seriesColors
 * @return {Function} colorCategoryMapping
 */

var getColorCategoryMapping = function getColorCategoryMapping(_ref) {
  var category = _ref.category,
      colorMode = _ref.colorMode,
      seriesColors = _ref.seriesColors;

  if (colorMode === COLOR_MODE_TYPES.SEQUENTIAL) {
    return null;
  }

  return d3_scale_1.scaleOrdinal().domain(category).range(seriesColors).unknown(seriesColors[0]);
};

exports.getColorCategoryMapping = getColorCategoryMapping;
/**
 * get punchcard dimensions given container width and height
 * @method getChartAreaDimensions
 * @param {Object} input
 * @param {Number} containerWidth
 * @param {Number} containerHeight
 * @param {Boolean} displayLegend
 * @return {Object} dimensions
 * @return {Number} dimensions.xAxisStartY
 * @return {Number} dimensions.yAxisStartX
 * @return {Number} dimensions.chartAreaStartX
 * @return {Number} dimensions.chartAreaStartY
 * @return {Number} dimensions.chartAreaEndX
 * @return {Number} dimensions.chartAreaEndY
 */

var getChartAreaDimensions = function getChartAreaDimensions(_ref2) {
  var containerWidth = _ref2.containerWidth,
      containerHeight = _ref2.containerHeight,
      displayLegend = _ref2.displayLegend;
  var yAxisStartX = MARGIN;
  var chartAreaStartX = yAxisStartX + Y_AXIS_WIDTH + MARGIN;
  var chartAreaEndX = containerWidth - MARGIN;
  var legendStartX = null;

  if (displayLegend) {
    legendStartX = containerWidth - LEGEND_WIDTH;
    chartAreaEndX = legendStartX - MARGIN;
  }

  var chartAreaStartY = MARGIN;
  var xAxisStartY = containerHeight - X_AXIS_HEIGHT - MARGIN;
  var chartAreaEndY = xAxisStartY - MARGIN;
  return {
    xAxisStartY: xAxisStartY,
    yAxisStartX: yAxisStartX,
    chartAreaStartX: chartAreaStartX,
    chartAreaStartY: chartAreaStartY,
    chartAreaEndX: chartAreaEndX,
    chartAreaEndY: chartAreaEndY,
    legendStartX: legendStartX
  };
};

exports.getChartAreaDimensions = getChartAreaDimensions;
/**
 * gets a scale used to map values to x or y plane
 * @method getScales
 * @param {Object} input
 * @param {(Array<String>\|Array<Number>)} values
 * @param {Number} start
 * @param {Number} end
 * @return {Object} scales
 * @return {Function} scales.scale function to return beginning of band
 * @return {Function} scales.positionScale function to return middle of band
 */

var getScales = function getScales(_ref3) {
  var values = _ref3.values,
      start = _ref3.start,
      end = _ref3.end;
  var scale = d3_scale_1.scaleBand().domain(values).range([start, end]); // Returns the middle of the band

  var positionScale = function positionScale(value) {
    return scale(value) + scale.bandwidth() / 2;
  };

  return {
    scale: scale,
    positionScale: positionScale
  };
};

exports.getScales = getScales;
/**
 * Maps an array of values to a percentage
 * Excludes zero values and takes the absolute minimum and maximum value
 * @method createValueScale
 * @param {Array<Number>} values
 * @return {Function} radiusScale
 */

var createValueScale = function createValueScale(values) {
  var absValuesWithoutZero = [];
  values.forEach(function (value) {
    // Ignore undefined, null and 0 values
    if (value) {
      absValuesWithoutZero.push(Math.abs(value));
    }
  });
  return d3_scale_1.scaleLinear().domain([Math.min.apply(Math, absValuesWithoutZero), Math.max.apply(Math, absValuesWithoutZero)]).range([0, 1]).clamp(true).unknown(0);
};

exports.createValueScale = createValueScale;
/**
 * Given a dataset, partition it by row and for each row:
 * get x, size, category and rowSizeScales
 * @method getDataByRows
 * @param {Object} input
 * @param {BUBBLE_ROW_SCALE_TYPES} bubbleRowScale
 * @param {BUBBLE_SCALE_TYPES} bubbleScale
 * @param {Array<String>} category
 * @param {Function} colorCategoryMapping
 * @param {COLOR_MODE_TYPES} colorMode
 * @param {(String|Array<String>)} bubbleColor
 * @param {Number} minBubbleColorIntensity
 * @param {Array<Number>} size
 * @param {(Array<String>\|Array<Number>)} x
 * @param {(Array<String>\|Array<Number>)} y
 * @param {Boolean} isBubbleSizeDynamic
 * @param {Number} minBubbleSize  // Used when isBubbleSizeDynamic
 * @param {Number} maxBubbleSize  // Used when isBubbleSizeDynamic
 * @param {Number} minBand  // Used to calculated radius when isBubbleSizeDynamic
 * @param {Number} maxBubbleRadius  // Used when !isBubbleSizeDynamic
 * @param {Number} minBubbleRadius  // Used when !isBubbleSizeDynamic
 * @return {Object<String\|Number, RowData>} dataByRows
 */

var getDataByRows = function getDataByRows(_ref4) {
  var bubbleRowScale = _ref4.bubbleRowScale,
      bubbleScale = _ref4.bubbleScale,
      category = _ref4.category,
      colorCategoryMapping = _ref4.colorCategoryMapping,
      colorMode = _ref4.colorMode,
      bubbleColor = _ref4.bubbleColor,
      minBubbleColorIntensity = _ref4.minBubbleColorIntensity,
      size = _ref4.size,
      x = _ref4.x,
      y = _ref4.y,
      isBubbleSizeDynamic = _ref4.isBubbleSizeDynamic,
      minBubbleSize = _ref4.minBubbleSize,
      maxBubbleSize = _ref4.maxBubbleSize,
      minBand = _ref4.minBand,
      maxBubbleRadius = _ref4.maxBubbleRadius,
      minBubbleRadius = _ref4.minBubbleRadius;
  var dataByRows = {};
  var minRadius = isBubbleSizeDynamic ? minBand / 2 * minBubbleSize : minBubbleRadius;
  var maxRadius = isBubbleSizeDynamic ? minBand / 2 * maxBubbleSize : maxBubbleRadius;
  var minArea = Math.PI * Math.pow(minRadius, 2);
  var maxArea = Math.PI * Math.pow(maxRadius, 2);
  var isBubbleColorAnArray = Array.isArray(bubbleColor);
  var globalSizeScale = exports.createValueScale(size);

  var getRadiusValue = function getRadiusValue(value, sizeScale) {
    return bubbleScale === BUBBLE_SCALE_TYPES.RADIUS ? (maxRadius - minRadius) * sizeScale(Math.abs(value)) + minRadius : Math.sqrt(((maxArea - minArea) * sizeScale(Math.abs(value)) + minArea) / Math.PI);
  };

  var getColorValue = function getColorValue(c) {
    return colorMode === COLOR_MODE_TYPES.CATEGORICAL ? colorCategoryMapping(c) : bubbleColor;
  };

  var getOpacityValue = function getOpacityValue(value, sizeScale) {
    return colorMode === COLOR_MODE_TYPES.CATEGORICAL || isBubbleColorAnArray ? 1 : sizeScale(Math.abs(value)) * (1 - minBubbleColorIntensity) + minBubbleColorIntensity;
  };

  y.forEach(function (yValue, index) {
    var xValue = x[index];
    var sizeValue = size[index];
    var categoryValue = category && category[index] ? category[index] : null;
    var bubbleColorValue = colorMode === COLOR_MODE_TYPES.SEQUENTIAL && isBubbleColorAnArray ? bubbleColor[index] : getColorValue(categoryValue); // if we find an invalid data point here (x, y or size is null or undefined), we ignore it

    if (xValue == null || yValue == null || sizeValue == null) {
      return;
    } // initialize rowData


    if (!dataByRows[yValue]) {
      dataByRows[yValue] = {
        rowXValues: [],
        rowSizeValues: [],
        rowCategoryValues: [],
        rowColorValues: [],
        rowFillOpacityValues: [],
        rowSizeScale: globalSizeScale,
        rowRadiusValues: []
      };
    }

    dataByRows[yValue].rowXValues.push(xValue);
    dataByRows[yValue].rowSizeValues.push(sizeValue);
    dataByRows[yValue].rowCategoryValues.push(categoryValue);
    dataByRows[yValue].rowColorValues.push(bubbleColorValue);
    dataByRows[yValue].rowFillOpacityValues.push(getOpacityValue(size[index], dataByRows[yValue].rowSizeScale));
    dataByRows[yValue].rowRadiusValues.push(getRadiusValue(size[index], dataByRows[yValue].rowSizeScale));
  }); // If we are using row scaling we need to recalculate opacity, radius and size scale

  if (bubbleRowScale === BUBBLE_ROW_SCALE_TYPES.ROW) {
    Object.entries(dataByRows).forEach(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          row = _ref6[0],
          rowData = _ref6[1];

      var rowSizeScale = exports.createValueScale(rowData.rowSizeValues);
      dataByRows[row].rowSizeScale = rowSizeScale; // Fill in opacity and radius values based on row scale

      rowData.rowSizeValues.forEach(function (rowSizeValue, index) {
        dataByRows[row].rowFillOpacityValues[index] = getOpacityValue(rowData.rowSizeValues[index], rowSizeScale);
        dataByRows[row].rowRadiusValues[index] = getRadiusValue(rowData.rowSizeValues[index], rowSizeScale);
      });
    });
  }

  return dataByRows;
};

exports.getDataByRows = getDataByRows;
/**
 * Given selected dimensions
 * return true if there is something currently being selected
 * @method isSomethingSelected
 * @param {Object} input
 * @param {String|Number} selectedX
 * @param {String|Number} selectedY
 * @param {String} selectedCategory
 * @return {Boolean}
 */

var isSomethingSelected = function isSomethingSelected(_ref7) {
  var selectedX = _ref7.selectedX,
      selectedY = _ref7.selectedY,
      selectedCategory = _ref7.selectedCategory;
  return selectedX !== null || selectedY !== null || selectedCategory !== null;
};

exports.isSomethingSelected = isSomethingSelected;
/**
 * Given selected dimensions and a specific bubble's values
 * return true if that bubble should be selected
 * @method isBubbleSelected
 * @param {Object} input
 * @param {String|Number} selectedX
 * @param {String|Number} selectedY
 * @param {String} selectedCategory
 * @param {String|Number} xValue
 * @param {String|Number} yValue
 * @param {Boolean} categoryValue
 * @return {Boolean}
 */

var isBubbleSelected = function isBubbleSelected(_ref8) {
  var selectedX = _ref8.selectedX,
      selectedY = _ref8.selectedY,
      selectedCategory = _ref8.selectedCategory,
      xValue = _ref8.xValue,
      yValue = _ref8.yValue,
      categoryValue = _ref8.categoryValue;

  if (selectedX !== null && xValue !== selectedX) {
    return false;
  }

  if (selectedY !== null && yValue !== selectedY) {
    return false;
  }

  if (selectedCategory !== null && categoryValue !== selectedCategory) {
    return false;
  }

  return true;
};

exports.isBubbleSelected = isBubbleSelected;
/**
 * Given text and available width, the truncateAxisLabelText will ellipsize
 * the truncateLocation of the text
 * @method truncateAxisLabelText
 * @param {Object} input
 * @param {String} label - The text to truncate
 * @param {Number} widthInPX - Available width to render the text
 * @param {('ellipsisStart' | 'ellipsisEnd')} axisLabelOverflowMode - Truncate start or end of the text
 */

var truncateAxisLabelText = function truncateAxisLabelText(_ref9) {
  var label = _ref9.label,
      _ref9$widthInPX = _ref9.widthInPX,
      widthInPX = _ref9$widthInPX === void 0 ? Y_AXIS_WIDTH : _ref9$widthInPX,
      _ref9$axisLabelOverfl = _ref9.axisLabelOverflowMode,
      axisLabelOverflowMode = _ref9$axisLabelOverfl === void 0 ? 'ellipsisEnd' : _ref9$axisLabelOverfl;
  // convert available width to number of characters that can be rendered.
  var availableLength = Math.floor(widthInPX / HORIZONTAL_SPACE_FOR_SINGLE_CHAR);

  if (label.length <= availableLength) {
    return label;
  } // return empty string if available space cannot accomodate
  // at least one label character


  if (availableLength < 'X...'.length) {
    return '';
  }

  var endMarker = Math.max(0, availableLength - '...'.length);

  if (axisLabelOverflowMode === 'ellipsisStart') {
    return "...".concat(label.slice(-endMarker));
  }

  return "".concat(label.slice(0, endMarker), "...");
};

exports.truncateAxisLabelText = truncateAxisLabelText;

/***/ }),
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */
/***/ (function(module, exports) {

module.exports = require("lodash/find");

/***/ }),
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/taggedTemplateLiteral");

/***/ }),
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */
/***/ (function(module, exports) {

module.exports = require("lodash/findIndex");

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = require("lodash/flattenDeep");

/***/ }),
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */
/***/ (function(module, exports) {

module.exports = require("lodash/sortBy");

/***/ }),
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.themes = exports.computeVizProps = exports.PurePunchcard = exports.config = void 0;

var lodash_1 = __webpack_require__(2);

var config_1 = __webpack_require__(207);

var withDashboardViz_1 = __webpack_require__(27);

var Punchcard_1 = __webpack_require__(208);

var punchcardUtils_1 = __webpack_require__(216);

var visualization_color_palettes_1 = __webpack_require__(41);

exports.config = config_1.default;
exports.PurePunchcard = Punchcard_1.default;
var validOptions = Object.keys(exports.config.optionsSchema);

var computeVizProps = function computeVizProps(_a) {
  var onPointClick = _a.onPointClick,
      onLegendClick = _a.onLegendClick,
      x = _a.x,
      y = _a.y,
      category = _a.category,
      otherOptions = __rest(_a, ["onPointClick", "onLegendClick", "x", "y", "category"]);

  var options = lodash_1.chain(otherOptions).pick(validOptions).thru(punchcardUtils_1.convertToPunchcardProperties).value();

  if (options.seriesColors && typeof options.seriesColors === 'string') {
    try {
      options.seriesColors = JSON.parse(options.seriesColors);
    } catch (e) {
      options.seriesColors = visualization_color_palettes_1.VIZ_CATEGORICAL;
    }
  }

  return Object.assign({
    onPointClick: onPointClick,
    onLegendClick: onLegendClick,
    x: x,
    y: y,
    // PurePunchcard accepts category as string array
    category: category && category.map(String)
  }, options);
};

exports.computeVizProps = computeVizProps;
var viz = withDashboardViz_1.default({
  ReactViz: Punchcard_1.default,
  computeVizProps: exports.computeVizProps,
  vizConfig: config_1.default
});
exports.themes = config_1.default.themes;
exports.default = viz;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var i18n_1 = __webpack_require__(3);

var schemaUtils_1 = __webpack_require__(14);

var visualization_icons_1 = __webpack_require__(42);

var visualization_color_palettes_1 = __webpack_require__(41);

var pick_1 = __webpack_require__(21);

var variables_1 = __webpack_require__(19);

var VizBehavior_1 = __webpack_require__(5);

var VizCategory_1 = __webpack_require__(26);

var configUtils_1 = __webpack_require__(8);

var BackgroundColor_1 = __webpack_require__(44);

var dataContract = {
  requiredDataSources: [{
    name: 'primary',
    description: 'DataSource that powers the visualization'
  }],
  optionalDataSources: [// Note: SCP-14090 disable ui for optional datasources. We may need to add it back later
    // {
    //     name: 'annotation',
    //     description: 'DataSource that populate event annotations',
    // },
  ],
  initialRequestParams: {
    primary: {
      offset: 0,
      count: 10000
    }
  }
};
var size = {
  initialWidth: 300,
  initialHeight: 300
};
var defaultContext = {
  bubbleColorConfig: {
    colors: ['rgba(123,86,219,0.4)', 'rgba(123,86,219,1)']
  }
};
var optionsSchema = {
  x: {
    default: '> primary | seriesByIndex(0)',
    description: 'Specify the dataSource applied to the x-axis.',
    type: 'array',
    items: {
      type: ['string', 'number']
    }
  },
  y: {
    default: '> primary | seriesByIndex(1)',
    description: 'Specify the dataSource applied to the y-axis.',
    type: 'array',
    items: {
      type: ['string', 'number']
    }
  },
  category: {
    default: '> primary | seriesByIndex(3)',
    description: 'Specify the dataSource to apply series categories.',
    type: 'array',
    items: {
      type: ['string', 'number']
    }
  },
  size: {
    default: '> primary | seriesByIndex(2)',
    description: 'Specify the dataSource to apply bubble size in the chart.',
    type: 'array',
    items: {
      type: 'number'
    }
  },
  xField: {
    default: '> x | getField()',
    description: 'Specify the field that should be mapped to the x-axis.',
    type: 'string'
  },
  yField: {
    default: '> y | getField()',
    description: 'Specify the field that should be mapped to the y-axis.',
    type: 'string'
  },
  categoryField: {
    default: '> category | getField()',
    description: 'Specify the field that should be mapped to the series categories.',
    type: 'string'
  },
  sizeField: {
    default: '> size | getField()',
    description: 'Specify the field that should be mapped to the bubble size in the chart.',
    type: 'string'
  },
  backgroundColor: {
    default: '> themes.defaultBackgroundColor',
    description: 'Specify the color used for the background. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
    pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN,
    type: 'string'
  },
  bubbleColor: {
    default: '> size | gradient(bubbleColorConfig)',
    description: 'Specify the coloring method used for the bubbles when the colorMode “dynamic” is specified. For example “> size | gradient(bubbleColorConfig)".',
    type: ['string', 'array']
  },
  bubbleLabelDisplay: {
    default: 'all',
    description: 'Specify whether all bubble labels, the max value bubble labels, or none of the bubble labels should be displayed.',
    pattern: schemaUtils_1.getPattern(['all', 'max', 'off']),
    type: 'string'
  },
  bubbleRadiusMax: {
    default: 15,
    description: 'Specify the max radius (in pixels) of the bubbles when showDynamicBubbleSize option is false. Greater than 0.',
    type: 'number'
  },
  bubbleRadiusMin: {
    default: 1,
    description: 'Specify the min radius (in pixels) of the bubbles when showDynamicBubbleSize option is false. Greater than 0.',
    type: 'number'
  },
  bubbleRowScale: {
    default: 'global',
    description: 'Specify how bubbles are scaled relative to other rows.',
    pattern: schemaUtils_1.getPattern(['global', 'row']),
    type: 'string'
  },
  bubbleSizeMax: {
    default: 1,
    description: 'Specify the max percentage (in decimal format) of space a bubble should take up within a cell when showDynamicBubbleSize option is true. The number specified must be between 0 and 1.',
    type: 'number'
  },
  bubbleSizeMin: {
    default: 0.25,
    description: 'Specify the min percentage (in decimal format) of space a bubble should take up within a cell when showDynamicBubbleSize option is true. The number specified must be between 0 and 1.',
    type: 'number'
  },
  bubbleSizeMethod: {
    default: 'area',
    description: 'Specify whether bubble area or diameter corresponds to the size value.',
    pattern: schemaUtils_1.getPattern(['radius', 'area']),
    type: 'string'
  },
  colorMode: {
    default: 'dynamic',
    description: 'Specify the coloring method used for the bubbles.',
    pattern: schemaUtils_1.getPattern(['categorical', 'dynamic']),
    type: 'string'
  },
  legendDisplay: {
    default: 'right',
    description: 'Specify the location of the legend on the panel.',
    pattern: schemaUtils_1.getPattern(['right', 'off']),
    type: 'string'
  },
  seriesColors: {
    default: visualization_color_palettes_1.VIZ_CATEGORICAL,
    description: 'Specify the colors used for a series. For example, "#FF0000", "#0000FF", "#008000".',
    type: 'array',
    items: {
      type: 'string'
    }
  },
  showDefaultSort: {
    default: false,
    description: 'Specify whether axes should be sorted based on order of time, digits and strings.',
    type: 'boolean'
  },
  showDynamicBubbleSize: {
    default: true,
    description: 'Specify whether the bubble size should be dynamic or fixed.',
    type: 'boolean'
  },
  showMaxValuePulsation: {
    default: true,
    description: 'Specify whether the max value bubble should pulsate.',
    type: 'boolean'
  }
};
var themes = {
  defaultBackgroundColor: function defaultBackgroundColor(props) {
    return pick_1.default({
      enterprise: {
        dark: variables_1.default.black(props),
        light: variables_1.default.backgroundColor(props)
      },
      prisma: variables_1.default.backgroundColorSidebar(props)
    })(props);
  }
};
var editorConfig = [{
  label: i18n_1._('General'),
  open: true,
  layout: [[{
    label: i18n_1._('Pulsate Max Value'),
    option: 'showMaxValuePulsation',
    editor: 'editor.toggle'
  }], [{
    label: i18n_1._('Show Bubble Labels'),
    option: 'bubbleLabelDisplay',
    editor: 'editor.radioBar',
    editorProps: {
      values: [{
        label: i18n_1._('All'),
        value: 'all'
      }, {
        label: i18n_1._('Max'),
        value: 'max'
      }, {
        label: i18n_1._('Off'),
        value: 'off'
      }]
    }
  }], [{
    label: i18n_1._('Bubble Row Scale'),
    option: 'bubbleRowScale',
    editor: 'editor.radioBar',
    editorProps: {
      values: [{
        label: i18n_1._('Global'),
        value: 'global'
      }, {
        label: i18n_1._('By Row'),
        value: 'row'
      }]
    }
  }], [{
    label: i18n_1._('Bubble Scale'),
    option: 'bubbleSizeMethod',
    editor: 'editor.radioBar',
    editorProps: {
      values: [{
        label: i18n_1._('Radius'),
        value: 'radius'
      }, {
        label: i18n_1._('Area'),
        value: 'area'
      }]
    }
  }]]
}, {
  label: i18n_1._('Coloring'),
  open: true,
  layout: [[{
    label: i18n_1._('Color Mode'),
    option: 'colorMode',
    editor: 'editor.radioBar',
    editorProps: {
      values: [{
        label: i18n_1._('Dynamic'),
        value: 'dynamic'
      }, {
        label: i18n_1._('Categorical'),
        value: 'categorical'
      }]
    }
  }], [// This should be hidden in categorical color mode
  {
    label: i18n_1._('Color by Field'),
    editor: 'editor.columnSelector',
    option: 'bubbleColor',
    context: 'bubbleColorConfig',
    showEditor: function showEditor(_ref) {
      var options = _ref.options;
      return options.colorMode === 'dynamic' || options.colorMode === undefined;
    },
    editorProps: {
      dataSourceKey: 'primary',
      prepareValue: function prepareValue(definition) {
        var bubbleColor = definition.options.bubbleColor;
        return {
          context: {},
          options: {
            bubbleColor: "".concat(bubbleColor, " | gradient(bubbleColorConfig)")
          }
        };
      }
    }
  }], BackgroundColor_1.default({
    themes: themes,
    labelPosition: 'left'
  }), [{
    label: i18n_1._('Legend Display'),
    option: 'legendDisplay',
    editor: 'editor.select',
    editorProps: {
      values: [{
        label: i18n_1._('Right'),
        value: 'right'
      }, {
        label: i18n_1._('Off'),
        value: 'off'
      }]
    },
    showEditor: function showEditor(_ref2) {
      var options = _ref2.options;
      return options.colorMode === 'categorical';
    }
  }]]
}];
/**
 * visualization configuration
 */

var config = {
  /**
   * unique viz key
   */
  key: 'splunk.punchcard',

  /**
   * viz name
   */
  name: 'Punchcard',
  category: VizCategory_1.VizCategory.COMPARISONS,

  /**
   * viz icon
   */
  icon: visualization_icons_1.Punchcard,
  dataContract: dataContract,
  size: size,
  defaultContext: defaultContext,
  optionsSchema: optionsSchema,
  editorConfig: editorConfig,
  events: {
    'legend.click': {
      description: 'Triggered when user clicks a chart legend'
    },
    'point.click': {
      description: 'Triggered when user clicks a data point'
    }
  },
  supports: [VizBehavior_1.VizBehavior.DYNAMIC_OPTIONS, VizBehavior_1.VizBehavior.PLACEHOLDER, VizBehavior_1.VizBehavior.EVENTS],
  themes: themes,
  requiredProps: ['x', 'y', 'size']
};
exports.default = configUtils_1.enhanceConfig(config);

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

var _slicedToArray = __webpack_require__(60);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var SizeAwareWrapper_1 = __webpack_require__(17);

var style_1 = __webpack_require__(13);

var visualization_color_palettes_1 = __webpack_require__(41);

var punchcardUtils_1 = __webpack_require__(73);

var sortUtils_1 = __webpack_require__(209);

var PunchcardAxis_1 = __webpack_require__(210);

var PunchcardChartArea_1 = __webpack_require__(211);

var PunchcardLegend_1 = __webpack_require__(214);

var PunchcardGridLines_1 = __webpack_require__(215);

var Container = styled_components_1.default.div.withConfig({
  displayName: "Punchcard__Container",
  componentId: "orvtgq-0"
})(["cursor:default;overflow:hidden;", ";background-color:", ";"], function (props) {
  return style_1.toDimension(lodash_1.pick(props, ['width', 'height']));
}, function (props) {
  return props.backgroundColor;
});
var PunchcardWrapper = styled_components_1.default.div.withConfig({
  displayName: "Punchcard__PunchcardWrapper",
  componentId: "orvtgq-1"
})(["display:flex;justify-content:center;flex-direction:row;width:100%;height:100%;background-color:", ";"], function (props) {
  return props.backgroundColor;
});
var PunchcardContainer = styled_components_1.default.div.withConfig({
  displayName: "Punchcard__PunchcardContainer",
  componentId: "orvtgq-2"
})(["overflow:hidden;position:relative;", ";"], function (props) {
  return style_1.toDimension(lodash_1.pick(props, ['width', 'height']));
});
var PunchcardSVG = styled_components_1.default.svg.withConfig({
  displayName: "Punchcard__PunchcardSVG",
  componentId: "orvtgq-3"
})(["", ";"], function (props) {
  return style_1.toDimension(lodash_1.pick(props, ['width', 'height']));
});

var Punchcard = function Punchcard(props) {
  var _React$useState = React.useState(null),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      selectedX = _React$useState2[0],
      setSelectedX = _React$useState2[1];

  var _React$useState3 = React.useState(null),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      selectedY = _React$useState4[0],
      setSelectedY = _React$useState4[1];

  var _React$useState5 = React.useState(null),
      _React$useState6 = _slicedToArray(_React$useState5, 2),
      selectedCategory = _React$useState6[0],
      setSelectedCategory = _React$useState6[1];

  var handleMouseLeave = function handleMouseLeave() {
    setSelectedX(null);
    setSelectedY(null);
    setSelectedCategory(null);
  };

  var handleLegendHover = function handleLegendHover(category) {
    setSelectedX(null);
    setSelectedY(null);
    setSelectedCategory(category);
  };

  var handleXAxisHover = function handleXAxisHover(xValue) {
    setSelectedX(xValue);
    setSelectedY(null);
    setSelectedCategory(null);
  };

  var handleYAxisHover = function handleYAxisHover(yValue) {
    setSelectedX(null);
    setSelectedY(yValue);
    setSelectedCategory(null);
  };

  var handleBubbleHover = function handleBubbleHover(xValue, yValue, category) {
    setSelectedX(xValue);
    setSelectedY(yValue);
    setSelectedCategory(category);
  };

  var backgroundColor = props.backgroundColor,
      showBubbleLabels = props.showBubbleLabels,
      bubbleRowScale = props.bubbleRowScale,
      bubbleScale = props.bubbleScale,
      category = props.category,
      categoryField = props.categoryField,
      colorMode = props.colorMode,
      seriesColors = props.seriesColors,
      bubbleColor = props.bubbleColor,
      minBubbleColorIntensity = props.minBubbleColorIntensity,
      height = props.height,
      showMaxValuePulsation = props.showMaxValuePulsation,
      isBubbleSizeDynamic = props.isBubbleSizeDynamic,
      minBubbleSize = props.minBubbleSize,
      maxBubbleSize = props.maxBubbleSize,
      maxBubbleRadius = props.maxBubbleRadius,
      minBubbleRadius = props.minBubbleRadius,
      useDefaultSort = props.useDefaultSort,
      showLegend = props.showLegend,
      size = props.size,
      sizeField = props.sizeField,
      width = props.width,
      x = props.x,
      y = props.y,
      xField = props.xField,
      yField = props.yField,
      onPointClick = props.onPointClick,
      onLegendClick = props.onLegendClick;
  var calculatedColorMode = category ? colorMode : punchcardUtils_1.COLOR_MODE_TYPES.SEQUENTIAL;
  var displayLegend = showLegend && calculatedColorMode === punchcardUtils_1.COLOR_MODE_TYPES.CATEGORICAL;
  var uniqX = useDefaultSort ? sortUtils_1.sortAxis(lodash_1.uniq(x.map(function (v) {
    return "".concat(v);
  }))) : lodash_1.uniq(x);
  var uniqY = useDefaultSort ? sortUtils_1.sortAxis(lodash_1.uniq(y.map(function (v) {
    return "".concat(v);
  }))) : lodash_1.uniq(y);
  var uniqCategory = lodash_1.uniq(category);
  var colorCategoryMapping = punchcardUtils_1.getColorCategoryMapping({
    category: uniqCategory,
    colorMode: calculatedColorMode,
    seriesColors: seriesColors
  });

  var handlePointClick = function handlePointClick(sizeValue) {
    var _rowData;

    var rowData = (_rowData = {}, _defineProperty(_rowData, "row.".concat(xField, ".value"), selectedX), _defineProperty(_rowData, "row.".concat(yField, ".value"), selectedY), _defineProperty(_rowData, "row.".concat(sizeField, ".value"), sizeValue), _rowData);
    if (categoryField) rowData["row.".concat(categoryField, ".value")] = selectedCategory;
    onPointClick({
      type: 'point.click',
      payload: Object.assign({
        value: selectedY,
        name: yField
      }, rowData)
    });
  };

  var handleLegendClick = function handleLegendClick() {
    onLegendClick({
      type: 'legend.click',
      payload: {
        name: yField
      }
    });
  };

  var renderVisualization = function renderVisualization(_ref) {
    var containerWidth = _ref.width,
        containerHeight = _ref.height;

    var _punchcardUtils_1$get = punchcardUtils_1.getChartAreaDimensions({
      containerWidth: containerWidth,
      containerHeight: containerHeight,
      displayLegend: displayLegend
    }),
        xAxisStartY = _punchcardUtils_1$get.xAxisStartY,
        yAxisStartX = _punchcardUtils_1$get.yAxisStartX,
        chartAreaStartX = _punchcardUtils_1$get.chartAreaStartX,
        chartAreaStartY = _punchcardUtils_1$get.chartAreaStartY,
        chartAreaEndX = _punchcardUtils_1$get.chartAreaEndX,
        chartAreaEndY = _punchcardUtils_1$get.chartAreaEndY,
        legendStartX = _punchcardUtils_1$get.legendStartX;

    var _punchcardUtils_1$get2 = punchcardUtils_1.getScales({
      values: uniqX,
      start: chartAreaStartX,
      end: chartAreaEndX
    }),
        xScale = _punchcardUtils_1$get2.scale,
        xPositionScale = _punchcardUtils_1$get2.positionScale;

    var _punchcardUtils_1$get3 = punchcardUtils_1.getScales({
      values: uniqY,
      start: chartAreaStartY,
      end: chartAreaEndY
    }),
        yScale = _punchcardUtils_1$get3.scale,
        yPositionScale = _punchcardUtils_1$get3.positionScale;

    var minBand = Math.min(xScale.bandwidth(), yScale.bandwidth());
    return React.createElement(PunchcardWrapper, {
      backgroundColor: backgroundColor
    }, React.createElement(PunchcardContainer, {
      width: containerWidth,
      height: containerHeight
    }, React.createElement(PunchcardSVG, {
      width: containerWidth,
      height: containerHeight
    }, React.createElement(PunchcardGridLines_1.default, {
      xStartPosition: xPositionScale(uniqX[0]),
      xEndPosition: xPositionScale(uniqX[uniqX.length - 1]),
      yStartPosition: yPositionScale(uniqY[0]),
      yEndPosition: yPositionScale(uniqY[uniqY.length - 1]),
      xDelta: xScale.bandwidth(),
      yDelta: yScale.bandwidth()
    }), React.createElement(PunchcardAxis_1.default, {
      labels: uniqX,
      orientation: punchcardUtils_1.AXIS_ORIENTATION_TYPES.HORIZONTAL,
      handleMouseEnter: handleXAxisHover,
      handleMouseLeave: handleMouseLeave,
      startPositionX: chartAreaStartX,
      startPositionY: xAxisStartY,
      scale: xScale,
      selected: selectedX
    }), React.createElement(PunchcardAxis_1.default, {
      labels: uniqY,
      orientation: punchcardUtils_1.AXIS_ORIENTATION_TYPES.VERTICAL,
      handleMouseEnter: handleYAxisHover,
      handleMouseLeave: handleMouseLeave,
      startPositionX: yAxisStartX,
      startPositionY: chartAreaStartY,
      scale: yScale,
      selected: selectedY
    }), displayLegend && React.createElement(PunchcardLegend_1.default, {
      category: uniqCategory,
      colorCategoryMapping: colorCategoryMapping,
      handleMouseEnter: handleLegendHover,
      handleMouseLeave: handleMouseLeave,
      selected: selectedCategory,
      startPositionX: legendStartX,
      startPositionY: yPositionScale(uniqY[0]),
      containerWidth: containerWidth,
      containerHeight: containerHeight,
      handleLegendClick: handleLegendClick
    }), React.createElement(PunchcardChartArea_1.default, {
      showBubbleLabels: showBubbleLabels,
      bubbleRowScale: bubbleRowScale,
      bubbleScale: bubbleScale,
      category: category,
      colorCategoryMapping: colorCategoryMapping,
      colorMode: calculatedColorMode,
      bubbleColor: bubbleColor,
      minBubbleColorIntensity: minBubbleColorIntensity,
      handleMouseEnter: handleBubbleHover,
      handleMouseLeave: handleMouseLeave,
      isBubbleSizeDynamic: isBubbleSizeDynamic,
      minBand: minBand,
      minBubbleSize: minBubbleSize,
      maxBubbleSize: maxBubbleSize,
      minBubbleRadius: minBubbleRadius,
      maxBubbleRadius: maxBubbleRadius,
      showMaxValuePulsation: showMaxValuePulsation,
      selectedCategory: selectedCategory,
      selectedX: selectedX,
      selectedY: selectedY,
      size: size,
      x: x,
      xScale: xPositionScale,
      y: y,
      yScale: yPositionScale,
      handlePointClick: handlePointClick
    }), React.createElement("filter", {
      id: punchcardUtils_1.GRAYSCALE_FILTER_ID
    }, React.createElement("feColorMatrix", {
      type: "matrix",
      values: "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
    })))));
  };

  return React.createElement(Container, {
    backgroundColor: backgroundColor,
    height: height,
    width: width
  }, React.createElement(SizeAwareWrapper_1.default, null, function (containerDimension) {
    return renderVisualization(containerDimension);
  }));
};

var propTypes = {
  backgroundColor: T.string,
  showBubbleLabels: T.oneOf(Object.values(punchcardUtils_1.BUBBLE_LABELS_TYPES)),
  bubbleRowScale: T.oneOf(Object.values(punchcardUtils_1.BUBBLE_ROW_SCALE_TYPES)),
  bubbleScale: T.oneOf(Object.values(punchcardUtils_1.BUBBLE_SCALE_TYPES)),
  category: T.arrayOf(T.string),
  categoryField: T.string,
  colorMode: T.oneOf(Object.values(punchcardUtils_1.COLOR_MODE_TYPES)),
  seriesColors: T.arrayOf(T.string),
  bubbleColor: T.oneOfType([T.string, T.arrayOf(T.string)]),
  minBubbleColorIntensity: T.number,
  height: T.oneOfType([T.string, T.number]),
  isBubbleSizeDynamic: T.bool,
  minBubbleSize: T.number,
  maxBubbleSize: T.number,
  maxBubbleRadius: T.number,
  minBubbleRadius: T.number,
  useDefaultSort: T.bool,
  showMaxValuePulsation: T.bool,
  showLegend: T.bool,
  sizeField: T.string,
  width: T.oneOfType([T.string, T.number]),
  // hotfix: isRequired check is removed here for x, y and size props
  // to remove console warnings on early return of this component and
  // implemented in config file using requiredProps
  x: T.arrayOf(T.oneOfType([T.string, T.number])),
  y: T.arrayOf(T.oneOfType([T.string, T.number])),
  size: T.arrayOf(T.number),
  xField: T.string,
  yField: T.string,
  onPointClick: T.func,
  onLegendClick: T.func
};
var defaultProps = {
  backgroundColor: 'transparent',
  showBubbleLabels: 'all',
  bubbleRowScale: 'global',
  bubbleScale: 'area',
  category: null,
  categoryField: null,
  colorMode: 'categorical',
  seriesColors: visualization_color_palettes_1.CATEGORICAL,
  bubbleColor: '#7B56DB',
  minBubbleColorIntensity: 0.4,
  showMaxValuePulsation: true,
  height: 500,
  isBubbleSizeDynamic: true,
  minBubbleSize: 0.25,
  maxBubbleSize: 1,
  maxBubbleRadius: 15,
  minBubbleRadius: 1,
  useDefaultSort: false,
  showLegend: true,
  size: null,
  sizeField: null,
  width: '100%',
  x: null,
  y: null,
  xField: null,
  yField: null,
  onPointClick: lodash_1.noop,
  onLegendClick: lodash_1.noop
};
Punchcard.propTypes = propTypes;
Punchcard.defaultProps = defaultProps;
exports.default = Punchcard;

/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortedByWeekday", function() { return sortedByWeekday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortedByMonth", function() { return sortedByMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortedByDTime", function() { return sortedByDTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortByDigitOrAlpha", function() { return sortByDigitOrAlpha; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortAxis", function() { return sortAxis; });
/* harmony import */ var lodash_findIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/* harmony import */ var lodash_findIndex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_findIndex__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_find__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_sortBy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(129);
/* harmony import */ var lodash_sortBy__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_sortBy__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_flattenDeep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(105);
/* harmony import */ var lodash_flattenDeep__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_flattenDeep__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);





var TIME_RANGES = {
  month: [{
    january: true,
    jan: true,
    'jan.': true
  }, {
    february: true,
    feb: true,
    'feb.': true
  }, {
    march: true,
    mar: true,
    'mar.': true
  }, {
    april: true,
    apr: true,
    'apr.': true
  }, {
    may: true
  }, {
    june: true,
    jun: true,
    'jun.': true
  }, {
    july: true,
    jul: true,
    'jul.': true
  }, {
    august: true,
    aug: true,
    'aug.': true
  }, {
    september: true,
    sep: true,
    sept: true,
    'sep.': true,
    'sept.': true
  }, {
    october: true,
    oct: true,
    'oct.': true
  }, {
    november: true,
    nov: true,
    'nov.': true
  }, {
    december: true,
    dec: true,
    'dec.': true
  }],
  wday: [{
    monday: true,
    mon: true,
    'mon.': true
  }, {
    tuesday: true,
    tu: true,
    'tu.': true,
    tue: true,
    'tue.': true,
    tues: true,
    'tues.': true
  }, {
    wednesday: true,
    wed: true,
    'wed.': true
  }, {
    thursday: true,
    th: true,
    'th.': true,
    thur: true,
    'thur.': true,
    thurs: true,
    'thurs.': true
  }, {
    friday: true,
    fri: true,
    'fri.': true
  }, {
    saturday: true,
    sat: true,
    'sat.': true
  }, {
    sunday: true,
    sun: true,
    'sun.': true
  }]
};
/**
 * Sort axis labels by weekday
 * @param {array} axis - string array
 * @return {array} - string array. If those are not weekday strings, return []
 */

var sortedByWeekday = function sortedByWeekday(axis) {
  var sortedAxis = [];
  var notWeekDay = lodash_find__WEBPACK_IMPORTED_MODULE_1___default()(axis, function (value) {
    var lowerValue = value.toLowerCase();
    var index = lodash_findIndex__WEBPACK_IMPORTED_MODULE_0___default()(TIME_RANGES.wday, lowerValue);

    if (index === -1) {
      // if the axis contains any value not inside weekdays, then don't treat it as weekdays
      return true;
    }

    if (sortedAxis[index]) {
      sortedAxis[index] = [sortedAxis[index], value];
    } else {
      sortedAxis[index] = value;
    }

    return false;
  });
  return notWeekDay ? [] : lodash_flattenDeep__WEBPACK_IMPORTED_MODULE_3___default()(sortedAxis.filter(Boolean));
};
/**
 * Sort axis labels by month
 * @param {array} axis - string array
 * @return {array} - string array. If those are not month strings, return []
 */

var sortedByMonth = function sortedByMonth(axis) {
  var sortedAxis = [];
  var notMonth = lodash_find__WEBPACK_IMPORTED_MODULE_1___default()(axis, function (value) {
    var lowerValue = value.toLowerCase();
    var index = lodash_findIndex__WEBPACK_IMPORTED_MODULE_0___default()(TIME_RANGES.month, lowerValue);

    if (index === -1) {
      // if the axis contains any value not inside month, then don't treat it as month
      return true;
    }

    if (sortedAxis[index]) {
      sortedAxis[index] = [sortedAxis[index], value];
    } else {
      sortedAxis[index] = value;
    }

    return false;
  });
  return notMonth ? [] : lodash_flattenDeep__WEBPACK_IMPORTED_MODULE_3___default()(sortedAxis.filter(Boolean));
};
/**
 * Sort axis labels by date time
 * @param {array} axis - string array
 * @return {array} - string array. If those are not in acceptTimeFormat or formatted date, return []
 */

var sortedByDTime = function sortedByDTime(axis) {
  // valid time format 01:00 am, 01:00:00, 01:00
  var acceptTimeFormat = [/^([0-1])?\d( )?(am|pm)$/i, // 1am, 1 am, 12am, 12 am
  /^([0-1])?\d:[0-5]\d( )?(am|pm)$/i, // 01:00 am, 01:00am, 1:00am
  /^([0-2])?\d:([0-5]\d:)?[0-5]\d$/, // 01:00:00, 1:00:00, 23:00
  /^([0-2])?\d:[0-5]\d:[0-5]\d( )?(am|pm)$/i // 01:00:00 am, 1:00:00am
  ];
  var sortArr = [];
  var notDate = lodash_find__WEBPACK_IMPORTED_MODULE_1___default()(axis, function (value) {
    if (!Number.isNaN(Number(value))) {
      return true;
    } // should accept long date: 2019-03-02, Mar 2 2019, ..., 2019-01-01T00:00:00.000Z


    var convertedDate = new Date(value);

    if (!Number.isNaN(Number(convertedDate))) {
      sortArr.push({
        epoch: convertedDate,
        original: value
      });
      return false;
    }

    var acceptedTime = acceptTimeFormat.find(function (format) {
      return format.test(value);
    });

    if (acceptedTime) {
      var midday = /(am|pm)$/i;
      var reformatTime = value;
      var containsMidday = value.match(midday);

      if (containsMidday) {
        // for time format like 01:00 am and 1 am
        reformatTime = value.split(midday).slice(0, -1);
        reformatTime[0] = "".concat(reformatTime[0].trim(), ":00");
        reformatTime = reformatTime.join(' ');
      }

      convertedDate = new Date("1970/01/01 ".concat(reformatTime));
      sortArr.push({
        epoch: convertedDate,
        original: value
      });
      return false;
    }

    return true;
  });

  if (notDate) {
    return [];
  }

  return lodash_sortBy__WEBPACK_IMPORTED_MODULE_2___default()(sortArr, function (val) {
    return val.epoch;
  }).map(function (val) {
    return val.original;
  });
};
/**
 * Sort axis labels by digits or alphabetical order
 * @param {array} axis - string array
 * @return {array} - string array.
 * If those inputs are numbers, then return in digits order. Otherwise, return array based on alphabetical order
 */

var sortByDigitOrAlpha = function sortByDigitOrAlpha(axis) {
  // 10, 10.0, 10.1, not accept 10,000.0
  var coercedIsFinite = function coercedIsFinite(num) {
    return Number.isFinite(Number(num));
  };

  if (Object(lodash__WEBPACK_IMPORTED_MODULE_4__["every"])(axis, coercedIsFinite)) {
    return axis.sort(function (a, b) {
      return Number(a) - Number(b);
    });
  }

  return axis.sort();
};
/**
 * Sort axis based on the priority: time measures, numbers, strings in ascending order
 * @param {array} axis - string array
 * @return {array} - string array
 */

var sortAxis = function sortAxis(axis) {
  var sortedTimeAxis = sortedByDTime(axis);

  if (sortedTimeAxis.length) {
    return sortedTimeAxis;
  }

  var sortedWeekdays = sortedByWeekday(axis);

  if (sortedWeekdays.length) {
    return sortedWeekdays;
  }

  var sortedMonths = sortedByMonth(axis);

  if (sortedMonths.length) {
    return sortedMonths;
  }

  return sortByDigitOrAlpha(axis);
};

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var styled_components_1 = __webpack_require__(4);

var pick_1 = __webpack_require__(21);

var variables_1 = __webpack_require__(19);

var punchcardUtils_1 = __webpack_require__(73);

var AxisLabelText = styled_components_1.default.text.withConfig({
  displayName: "PunchcardAxis__AxisLabelText",
  componentId: "sc-1jv7cdw-0"
})(["cursor:pointer;dominant-baseline:middle;fill:", ";font-size:12px;text-anchor:", ";opacity:", ";transition:all 0.15s;"], pick_1.default({
  /* was previously named textColor in themeReg */
  enterprise: variables_1.default.textColor,
  prisma: variables_1.default.contentColorDefault
}), function (props) {
  return props.orientation === punchcardUtils_1.AXIS_ORIENTATION_TYPES.HORIZONTAL ? 'middle' : 'start';
}, function (props) {
  return props.muted ? 0.15 : 1;
});

var PunchcardAxis = function PunchcardAxis(props) {
  var labels = props.labels,
      handleMouseEnter = props.handleMouseEnter,
      handleMouseLeave = props.handleMouseLeave,
      orientation = props.orientation,
      scale = props.scale,
      selected = props.selected,
      startPositionX = props.startPositionX,
      startPositionY = props.startPositionY;
  return React.createElement("g", null, labels.map(function (label, index) {
    // Space between labels either in x or y direction depending on orientation
    var positionDelta = index * scale.bandwidth() + scale.bandwidth() / 2;
    var xPosition = orientation === punchcardUtils_1.AXIS_ORIENTATION_TYPES.VERTICAL ? startPositionX : startPositionX + positionDelta;
    var yPosition = orientation === punchcardUtils_1.AXIS_ORIENTATION_TYPES.VERTICAL ? startPositionY + positionDelta : startPositionY; // create padding between x-axis labels

    var xAxisWidthScale = scale.copy().paddingInner(0.1).round(true);
    var truncatedLabel = orientation === punchcardUtils_1.AXIS_ORIENTATION_TYPES.VERTICAL ? punchcardUtils_1.truncateAxisLabelText({
      label: "".concat(label)
    }) : punchcardUtils_1.truncateAxisLabelText({
      label: "".concat(label),
      widthInPX: xAxisWidthScale.bandwidth()
    });
    return React.createElement(AxisLabelText, {
      key: label,
      x: xPosition,
      y: yPosition,
      orientation: orientation,
      onMouseEnter: function onMouseEnter() {
        return handleMouseEnter(label);
      },
      onMouseLeave: handleMouseLeave,
      muted: selected && label !== selected
    }, React.createElement("title", null, label), truncatedLabel);
  }));
};

var propTypes = {
  labels: T.arrayOf(T.oneOfType([T.string, T.number])).isRequired,
  handleMouseEnter: T.func,
  handleMouseLeave: T.func,
  orientation: T.oneOf(Object.values(punchcardUtils_1.AXIS_ORIENTATION_TYPES)),
  scale: T.func.isRequired,
  selected: T.oneOfType([T.string, T.number]),
  startPositionX: T.number,
  startPositionY: T.number
};
var defaultProps = {
  // set as undefined as we are using defaultProps in conjunction with ts
  // where it requires all keys of interface to be present in defaultProps
  labels: undefined,
  handleMouseEnter: function handleMouseEnter() {},
  handleMouseLeave: function handleMouseLeave() {},
  orientation: 'vertical',
  scale: undefined,
  selected: null,
  startPositionX: 0,
  startPositionY: 0
};
PunchcardAxis.propTypes = propTypes;
PunchcardAxis.defaultProps = defaultProps;
exports.default = PunchcardAxis;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(40);

var _slicedToArray = __webpack_require__(60);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var punchcardUtils_1 = __webpack_require__(73);

var PunchcardRow_1 = __webpack_require__(212);

var PunchcardChartArea = function PunchcardChartArea(props) {
  var showBubbleLabels = props.showBubbleLabels,
      bubbleRowScale = props.bubbleRowScale,
      bubbleScale = props.bubbleScale,
      category = props.category,
      colorCategoryMapping = props.colorCategoryMapping,
      colorMode = props.colorMode,
      bubbleColor = props.bubbleColor,
      handleMouseEnter = props.handleMouseEnter,
      handleMouseLeave = props.handleMouseLeave,
      isBubbleSizeDynamic = props.isBubbleSizeDynamic,
      minBubbleColorIntensity = props.minBubbleColorIntensity,
      minBand = props.minBand,
      minBubbleSize = props.minBubbleSize,
      maxBubbleSize = props.maxBubbleSize,
      maxBubbleRadius = props.maxBubbleRadius,
      minBubbleRadius = props.minBubbleRadius,
      showMaxValuePulsation = props.showMaxValuePulsation,
      selectedCategory = props.selectedCategory,
      selectedX = props.selectedX,
      selectedY = props.selectedY,
      size = props.size,
      x = props.x,
      xScale = props.xScale,
      y = props.y,
      yScale = props.yScale,
      handlePointClick = props.handlePointClick;
  /** @type {Object<String\|Number, import('./utils/punchcardUtils').RowData>} */

  var dataByRows = punchcardUtils_1.getDataByRows({
    bubbleRowScale: bubbleRowScale,
    bubbleScale: bubbleScale,
    category: category,
    colorCategoryMapping: colorCategoryMapping,
    colorMode: colorMode,
    bubbleColor: bubbleColor,
    minBubbleColorIntensity: minBubbleColorIntensity,
    size: size,
    x: x,
    y: y,
    isBubbleSizeDynamic: isBubbleSizeDynamic,
    minBand: minBand,
    minBubbleSize: minBubbleSize,
    maxBubbleSize: maxBubbleSize,
    maxBubbleRadius: maxBubbleRadius,
    minBubbleRadius: minBubbleRadius
  });
  return React.createElement("g", null, Object.entries(dataByRows).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        row = _ref2[0],
        rowData = _ref2[1];

    var rowXValues = rowData.rowXValues,
        rowSizeValues = rowData.rowSizeValues,
        rowCategoryValues = rowData.rowCategoryValues,
        rowColorValues = rowData.rowColorValues,
        rowFillOpacityValues = rowData.rowFillOpacityValues,
        rowSizeScale = rowData.rowSizeScale,
        rowRadiusValues = rowData.rowRadiusValues;
    var yPosition = yScale(row);
    return React.createElement(PunchcardRow_1.default, {
      key: row,
      showBubbleLabels: showBubbleLabels,
      category: rowCategoryValues,
      colors: rowColorValues,
      handleMouseEnter: handleMouseEnter,
      handleMouseLeave: handleMouseLeave,
      maxSizeValue: Math.max.apply(Math, _toConsumableArray(size)),
      opacities: rowFillOpacityValues,
      radiusValues: rowRadiusValues,
      selectedCategory: selectedCategory,
      selectedX: selectedX,
      selectedY: selectedY,
      showMaxValuePulsation: showMaxValuePulsation,
      sizeScale: rowSizeScale,
      size: rowSizeValues,
      x: rowXValues,
      xScale: xScale,
      yPosition: yPosition,
      yValue: row,
      handlePointClick: handlePointClick
    });
  }));
};

var propTypes = {
  showBubbleLabels: T.oneOf(Object.values(punchcardUtils_1.BUBBLE_LABELS_TYPES)),
  bubbleRowScale: T.oneOf(Object.values(punchcardUtils_1.BUBBLE_ROW_SCALE_TYPES)),
  bubbleScale: T.oneOf(Object.values(punchcardUtils_1.BUBBLE_SCALE_TYPES)),
  category: T.arrayOf(T.string),
  colorCategoryMapping: T.func,
  colorMode: T.oneOf(Object.values(punchcardUtils_1.COLOR_MODE_TYPES)),
  bubbleColor: T.oneOfType([T.string, T.arrayOf(T.string)]),
  handleMouseEnter: T.func,
  handleMouseLeave: T.func,
  isBubbleSizeDynamic: T.bool,
  minBubbleColorIntensity: T.number,
  minBand: T.number,
  minBubbleSize: T.number,
  maxBubbleSize: T.number,
  maxBubbleRadius: T.number,
  minBubbleRadius: T.number,
  showMaxValuePulsation: T.bool,
  selectedCategory: T.oneOfType([T.string, T.number]),
  selectedX: T.oneOfType([T.string, T.number]),
  selectedY: T.oneOfType([T.string, T.number]),
  size: T.arrayOf(T.number).isRequired,
  x: T.arrayOf(T.oneOfType([T.string, T.number])).isRequired,
  xScale: T.func,
  y: T.arrayOf(T.oneOfType([T.string, T.number])).isRequired,
  yScale: T.func,
  handlePointClick: T.func
};
var defaultProps = {
  showBubbleLabels: punchcardUtils_1.BUBBLE_LABELS_TYPES.ALL,
  bubbleRowScale: punchcardUtils_1.BUBBLE_ROW_SCALE_TYPES.ROW,
  bubbleScale: punchcardUtils_1.BUBBLE_SCALE_TYPES.AREA,
  category: null,
  colorCategoryMapping: null,
  colorMode: punchcardUtils_1.COLOR_MODE_TYPES.CATEGORICAL,
  bubbleColor: '#A870EF',
  handleMouseEnter: function handleMouseEnter() {},
  handleMouseLeave: function handleMouseLeave() {},
  isBubbleSizeDynamic: true,
  minBubbleColorIntensity: 0.25,
  minBand: 15,
  minBubbleSize: 0.01,
  maxBubbleSize: 1,
  maxBubbleRadius: 15,
  minBubbleRadius: 1,
  showMaxValuePulsation: true,
  selectedCategory: null,
  selectedX: null,
  selectedY: null,
  size: null,
  x: null,
  xScale: null,
  y: null,
  yScale: null,
  handlePointClick: function handlePointClick() {}
};
PunchcardChartArea.propTypes = propTypes;
PunchcardChartArea.defaultProps = defaultProps;
exports.default = PunchcardChartArea;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var styled_components_1 = __webpack_require__(4);

var PunchcardBubble_1 = __webpack_require__(213);

var punchcardUtils_1 = __webpack_require__(73);

var PunchcardRow = function PunchcardRow(props) {
  var showBubbleLabels = props.showBubbleLabels,
      category = props.category,
      colors = props.colors,
      _handleMouseEnter = props.handleMouseEnter,
      handleMouseLeave = props.handleMouseLeave,
      maxSizeValue = props.maxSizeValue,
      opacities = props.opacities,
      radiusValues = props.radiusValues,
      selectedCategory = props.selectedCategory,
      selectedX = props.selectedX,
      selectedY = props.selectedY,
      showMaxValuePulsation = props.showMaxValuePulsation,
      size = props.size,
      x = props.x,
      xScale = props.xScale,
      yPosition = props.yPosition,
      yValue = props.yValue,
      handlePointClick = props.handlePointClick;
  return React.createElement("g", null, x.map(function (xValue, index) {
    var sizeValue = size[index];
    var categoryValue = category[index];
    var colorValue = colors[index];
    var cx = xScale(xValue);
    var r = radiusValues[index];
    var fillOpacity = opacities[index];
    var hover = punchcardUtils_1.isSomethingSelected({
      selectedX: selectedX,
      selectedY: selectedY,
      selectedCategory: selectedCategory
    }) && punchcardUtils_1.isBubbleSelected({
      selectedX: selectedX,
      selectedY: selectedY,
      selectedCategory: selectedCategory,
      xValue: xValue,
      yValue: yValue,
      categoryValue: categoryValue
    });
    var muted = punchcardUtils_1.isSomethingSelected({
      selectedX: selectedX,
      selectedY: selectedY,
      selectedCategory: selectedCategory
    }) && !hover;
    var showBubbleLabel = showBubbleLabels === punchcardUtils_1.BUBBLE_LABELS_TYPES.ALL || showBubbleLabels === punchcardUtils_1.BUBBLE_LABELS_TYPES.MAX && maxSizeValue === sizeValue;
    return React.createElement(PunchcardBubble_1.default, {
      key: "".concat(xValue, "-").concat(yValue, "-").concat(sizeValue, "-").concat(categoryValue),
      showBubbleLabel: showBubbleLabel,
      color: colorValue,
      cx: cx,
      cy: yPosition,
      fillOpacity: fillOpacity,
      handleMouseEnter: function handleMouseEnter() {
        _handleMouseEnter(xValue, yValue, categoryValue);
      },
      handleMouseLeave: handleMouseLeave,
      hover: hover,
      muted: muted,
      pulsate: showMaxValuePulsation && sizeValue === maxSizeValue,
      value: sizeValue,
      r: r,
      handlePointClick: handlePointClick
    });
  }));
};

var propTypes = {
  showBubbleLabels: T.oneOf(Object.values(punchcardUtils_1.BUBBLE_LABELS_TYPES)),
  category: T.arrayOf(T.string),
  colors: T.arrayOf(T.string),
  handleMouseEnter: T.func,
  handleMouseLeave: T.func,
  maxSizeValue: T.number,
  opacities: T.arrayOf(T.number),
  radiusValues: T.arrayOf(T.number),
  selectedCategory: T.oneOfType([T.string, T.number]),
  selectedX: T.oneOfType([T.string, T.number]),
  selectedY: T.oneOfType([T.string, T.number]),
  showMaxValuePulsation: T.bool,
  size: T.arrayOf(T.number),
  x: T.arrayOf(T.oneOfType([T.string, T.number])).isRequired,
  xScale: T.func,
  yPosition: T.number,
  yValue: T.oneOfType([T.string, T.number]),
  handlePointClick: T.func
};
var defaultProps = {
  showBubbleLabels: null,
  category: null,
  colors: null,
  handleMouseEnter: function handleMouseEnter() {},
  handleMouseLeave: function handleMouseLeave() {},
  maxSizeValue: null,
  opacities: null,
  radiusValues: null,
  selectedCategory: null,
  selectedX: null,
  selectedY: null,
  showMaxValuePulsation: true,
  size: null,
  x: null,
  xScale: null,
  yPosition: null,
  yValue: null,
  handlePointClick: function handlePointClick() {}
};
PunchcardRow.propTypes = propTypes;
PunchcardRow.defaultProps = defaultProps;
exports.default = styled_components_1.withTheme(PunchcardRow);

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _taggedTemplateLiteral = __webpack_require__(93);

var _templateObject;

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var styled_components_1 = __webpack_require__(4);

var pick_1 = __webpack_require__(21);

var variables_1 = __webpack_require__(19);

var numberUtils_1 = __webpack_require__(20);

var punchcardUtils_1 = __webpack_require__(73);

var BubbleCircle = styled_components_1.default.circle.withConfig({
  displayName: "PunchcardBubble__BubbleCircle",
  componentId: "sc-1jmms9f-0"
})(["fill:", ";fill-opacity:1;opacity:", ";stroke:", ";"], function (props) {
  return props.outline ? pick_1.default({
    // bubbleTextColor
    enterprise: {
      light: variables_1.default.white,
      dark: variables_1.default.contentColorInverted // enterprise.textColor

    },
    prisma: variables_1.default.contentColorActive
  })(props) : props.color;
}, function (props) {
  return props.hover ? 0 : props.fillOpacity;
}, function (props) {
  return props.outline ? props.color : 'none';
});

var pulsateAnimation = function pulsateAnimation(r) {
  return styled_components_1.keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    41% {\n        opacity: 0;\n        r: ", ";\n    }\n    100% {\n        opacity: 0;\n        r: ", ";\n    }\n"])), r + 5, r + 5);
};

var PulsateBubble = styled_components_1.default(BubbleCircle).withConfig({
  displayName: "PunchcardBubble__PulsateBubble",
  componentId: "sc-1jmms9f-1"
})(["animation:", " 2.4s linear 0.4s infinite;"], function (props) {
  return pulsateAnimation(props.r);
});
var BubbleGroup = styled_components_1.default.g.withConfig({
  displayName: "PunchcardBubble__BubbleGroup",
  componentId: "sc-1jmms9f-2"
})(["cursor:pointer;opacity:", ";filter:", ";transition:opacity 0.15s;"], function (props) {
  return props.muted ? 0.15 : 1;
}, function (props) {
  return props.muted ? "url(#".concat(punchcardUtils_1.GRAYSCALE_FILTER_ID, ")") : '';
});
var BubbleLabelText = styled_components_1.default.text.withConfig({
  displayName: "PunchcardBubble__BubbleLabelText",
  componentId: "sc-1jmms9f-3"
})(["dominant-baseline:middle;opacity:", ";fill:", "};font-size:", ";font-weight:", ";text-anchor:middle;"], function (props) {
  return props.displayLabel ? 1 : 0;
}, function (props) {
  return props.hover || props.outline ? pick_1.default({
    // bubbleAltTextColor
    enterprise: variables_1.default.textColor,
    prisma: variables_1.default.contentColorActive
  })(props) : pick_1.default({
    enterprise: {
      dark: variables_1.default.textColor,
      light: variables_1.default.white
    },
    prisma: variables_1.default.contentColorActive
  })(props);
}, function (props) {
  return props.hover ? '12px' : '10px';
}, function (props) {
  return props.hover ? 500 : 'normal';
});
var MIN_BUBBLE_SIZE_TO_DISPLAY_LABEL = 13;
var MAX_DISPLAYABLE_VALUE = 99499999999999;
var VALUE_OVERFLOW_TEXT = '99T+';

var PunchcardBubble = function PunchcardBubble(props) {
  var showBubbleLabel = props.showBubbleLabel,
      color = props.color,
      cx = props.cx,
      cy = props.cy,
      fillOpacity = props.fillOpacity,
      handleMouseEnter = props.handleMouseEnter,
      handleMouseLeave = props.handleMouseLeave,
      hover = props.hover,
      muted = props.muted,
      pulsate = props.pulsate,
      value = props.value,
      r = props.r,
      handlePointClick = props.handlePointClick;
  var outline = value < 0;
  var showPulsateBubble = pulsate && !muted && !hover;
  var displayLabel = hover || showBubbleLabel && r >= MIN_BUBBLE_SIZE_TO_DISPLAY_LABEL;
  var bubbleLabelValueText = value <= MAX_DISPLAYABLE_VALUE ? numberUtils_1.formatNumber(value, 0, {
    useTrendUnits: true
  }) : VALUE_OVERFLOW_TEXT;

  if (hover) {
    bubbleLabelValueText = numberUtils_1.formatNumber(value, 2);
  }

  return React.createElement(BubbleGroup, {
    muted: muted,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: function onClick() {
      return handlePointClick(value);
    }
  }, showPulsateBubble && React.createElement(PulsateBubble, {
    cx: cx,
    cy: cy,
    r: r,
    color: color,
    outline: true,
    hover: null
  }), React.createElement(BubbleCircle, {
    cx: cx,
    cy: cy,
    r: r,
    color: color,
    hover: hover,
    fillOpacity: fillOpacity,
    outline: outline
  }), React.createElement(BubbleLabelText, {
    x: cx,
    y: cy,
    hover: hover,
    outline: outline,
    displayLabel: displayLabel
  }, bubbleLabelValueText));
};

var propTypes = {
  showBubbleLabel: T.bool,
  color: T.string,
  cx: T.number,
  cy: T.number,
  fillOpacity: T.number,
  handleMouseEnter: T.func,
  handleMouseLeave: T.func,
  hover: T.bool,
  muted: T.bool,
  pulsate: T.bool,
  value: T.number,
  r: T.number,
  handlePointClick: T.func
};
var defaultProps = {
  showBubbleLabel: true,
  color: '#46D3BB',
  cx: 0,
  cy: 0,
  fillOpacity: 1,
  handleMouseEnter: function handleMouseEnter() {},
  handleMouseLeave: function handleMouseLeave() {},
  hover: false,
  muted: false,
  pulsate: false,
  r: 1,
  value: undefined,
  handlePointClick: function handlePointClick() {}
};
PunchcardBubble.propTypes = propTypes;
PunchcardBubble.defaultProps = defaultProps;
exports.default = PunchcardBubble;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var styled_components_1 = __webpack_require__(4);

var pick_1 = __webpack_require__(21);

var variables_1 = __webpack_require__(19);

var LEGEND_ITEM_VERTICAL_SPACER = 25;
var LEGEND_ITEM_HORIZONTAL_SPACER = 10;
var LEGEND_RECT_WIDTH = 5;
var LEGEND_RECT_HEIGHT = 10;
var LEGEND_OFFSET_TOP = 7;
var LEGEND_OFFSET_RIGHT = 16;
var LEGEND_OFFSET_BOTTOM = 16;
var LegendGroup = styled_components_1.default.g.withConfig({
  displayName: "PunchcardLegend__LegendGroup",
  componentId: "c2f7we-0"
})(["cursor:pointer;opacity:", ";transition:opacity 0.15s;"], function (props) {
  return props.muted ? 0.15 : 1;
});
var LegendIcon = styled_components_1.default.rect.withConfig({
  displayName: "PunchcardLegend__LegendIcon",
  componentId: "c2f7we-1"
})(["width:", "px;height:", "px;rx:1px;ry:1px;"], LEGEND_RECT_WIDTH, LEGEND_RECT_HEIGHT);
var LegendText = styled_components_1.default.text.withConfig({
  displayName: "PunchcardLegend__LegendText",
  componentId: "c2f7we-2"
})(["dominant-baseline:middle;fill:", ";font-size:12px;"], pick_1.default({
  /* was previously named textColor in themeReg */
  enterprise: variables_1.default.textColor,
  prisma: variables_1.default.contentColorDefault
}));

var PunchcardLegend = function PunchcardLegend(props) {
  var category = props.category,
      colorCategoryMapping = props.colorCategoryMapping,
      handleMouseEnter = props.handleMouseEnter,
      handleMouseLeave = props.handleMouseLeave,
      selected = props.selected,
      startPositionX = props.startPositionX,
      startPositionY = props.startPositionY,
      containerWidth = props.containerWidth,
      containerHeight = props.containerHeight,
      handleLegendClick = props.handleLegendClick;
  var legendWidth = containerWidth - LEGEND_OFFSET_RIGHT - startPositionX;
  var legendHeight = containerHeight - LEGEND_OFFSET_BOTTOM;
  return React.createElement("svg", {
    x: startPositionX,
    y: startPositionY - LEGEND_OFFSET_TOP,
    width: legendWidth,
    height: legendHeight
  }, React.createElement("g", null, category.map(function (c, index) {
    var yValue = index * LEGEND_ITEM_VERTICAL_SPACER;
    return React.createElement(LegendGroup, {
      key: c,
      muted: selected && selected !== c,
      onMouseEnter: function onMouseEnter() {
        return handleMouseEnter(c);
      },
      onMouseLeave: handleMouseLeave,
      onClick: function onClick() {
        return handleLegendClick();
      },
      "data-test": "legend-group"
    }, React.createElement(LegendIcon, {
      x: 0,
      y: yValue,
      fill: colorCategoryMapping(c)
    }), React.createElement(LegendText, {
      x: LEGEND_ITEM_HORIZONTAL_SPACER,
      y: yValue + LEGEND_RECT_HEIGHT / 2 + 2
    }, React.createElement("title", null, c), c));
  })));
};

var propTypes = {
  category: T.arrayOf(T.string),
  colorCategoryMapping: T.func.isRequired,
  handleMouseEnter: T.func,
  handleMouseLeave: T.func,
  selected: T.string,
  startPositionX: T.number,
  startPositionY: T.number,
  containerWidth: T.number,
  containerHeight: T.number,
  handleLegendClick: T.func
};
var defaultProps = {
  category: null,
  colorCategoryMapping: null,
  handleMouseEnter: function handleMouseEnter() {},
  handleMouseLeave: function handleMouseLeave() {},
  selected: null,
  startPositionX: 0,
  startPositionY: 0,
  containerWidth: 100,
  containerHeight: 100,
  handleLegendClick: function handleLegendClick() {}
};
PunchcardLegend.propTypes = propTypes;
PunchcardLegend.defaultProps = defaultProps;
exports.default = PunchcardLegend;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var styled_components_1 = __webpack_require__(4);

var lodash_1 = __webpack_require__(2);

var pick_1 = __webpack_require__(21);

var variables_1 = __webpack_require__(19); // was previously lineColor in themeRegistry


var GridLine = styled_components_1.default.line.withConfig({
  displayName: "PunchcardGridLines__GridLine",
  componentId: "sc-12y1iif-0"
})(["stroke:", ";stroke-width:1px;"], pick_1.default({
  enterprise: {
    light: variables_1.default.gray96,
    dark: variables_1.default.gray25
  },
  prisma: variables_1.default.interactiveColorBackgroundDisabled
}));

var PunchcardGridLines = function PunchcardGridLines(props) {
  var xStartPosition = props.xStartPosition,
      xEndPosition = props.xEndPosition,
      yStartPosition = props.yStartPosition,
      yEndPosition = props.yEndPosition,
      xDelta = props.xDelta,
      yDelta = props.yDelta;
  var yGridLinesXPositions = lodash_1.range(xStartPosition, xEndPosition + 1, xDelta);
  var xGridLinesYPositions = lodash_1.range(yStartPosition, yEndPosition + 1, yDelta);
  return React.createElement("g", {
    "data-test": "data-test-gridlines"
  }, yGridLinesXPositions.map(function (xValue) {
    return React.createElement(GridLine, {
      key: "".concat(xValue, "x").concat(yStartPosition),
      x1: xValue,
      y1: yStartPosition,
      x2: xValue,
      y2: yEndPosition
    });
  }), xGridLinesYPositions.map(function (yValue) {
    return React.createElement(GridLine, {
      key: "".concat(xStartPosition, "x").concat(yValue),
      x1: xStartPosition,
      y1: yValue,
      x2: xEndPosition,
      y2: yValue
    });
  }));
};

var propTypes = {
  xStartPosition: T.number,
  xEndPosition: T.number,
  yStartPosition: T.number,
  yEndPosition: T.number,
  xDelta: T.number,
  yDelta: T.number
};
var defaultProps = {
  xStartPosition: undefined,
  xEndPosition: undefined,
  yStartPosition: undefined,
  yEndPosition: undefined,
  xDelta: 10,
  yDelta: 10
};
PunchcardGridLines.propTypes = propTypes;
PunchcardGridLines.defaultProps = defaultProps;
exports.default = PunchcardGridLines;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToPunchcardProperties = exports.mapToOldKey = exports.punchcardOptionValuesMapping = void 0;

var lodash_1 = __webpack_require__(2);

var chartingUtils_1 = __webpack_require__(45);

var punchcardOptionsMapping = {
  legendDisplay: 'showLegend',
  bubbleLabelDisplay: 'showBubbleLabels',
  showDefaultSort: 'useDefaultSort',
  bubbleSizeMethod: 'bubbleScale',
  showDynamicBubbleSize: 'isBubbleSizeDynamic',
  bubbleRadiusMax: 'maxBubbleRadius',
  bubbleRadiusMin: 'minBubbleRadius',
  bubbleSizeMax: 'maxBubbleSize',
  bubbleSizeMin: 'minBubbleSize'
}; // key value mapping of what options (and their corresponding values) which
// we expose in config.ts to property values PurePunchcard understands

exports.punchcardOptionValuesMapping = {
  showLegend: {
    right: true,
    off: false
  },
  showBubbleLabels: {
    off: 'none'
  },
  colorMode: {
    dynamic: 'sequential'
  }
};
/**
 * Helper method to update the option names which can be mapped to PurePunchcard options
 * @method mapToOldKey
 * @param {Object} options
 * @returns {Object}
 */

var mapToOldKey = function mapToOldKey(options) {
  return lodash_1.mapKeys(options, function (val, key) {
    return punchcardOptionsMapping[key] ? punchcardOptionsMapping[key] : key;
  });
};

exports.mapToOldKey = mapToOldKey;
/**
 * Chained helper for mapping the option properties (and values) we expose in config.ts into property values that PurePunchcard accepts
 * This is for options that has new key name and can not directly be mapped with PurePunchcard props
 * @method convertToPunchcardProperties
 * @param {Object} originalOptions
 * @returns {Object}
 */

var convertToPunchcardProperties = function convertToPunchcardProperties(originalOptions) {
  return lodash_1.chain(exports.mapToOldKey(originalOptions)).thru(chartingUtils_1.mapToValues(exports.punchcardOptionValuesMapping)).value();
};

exports.convertToPunchcardProperties = convertToPunchcardProperties;

/***/ })
/******/ ]);
//# sourceMappingURL=Punchcard.js.map