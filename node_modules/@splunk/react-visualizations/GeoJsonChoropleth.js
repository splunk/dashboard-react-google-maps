/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 51);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 2 */,
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SanitizeProps");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/inherits");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/possibleConstructorReturn");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/getPrototypeOf");

/***/ }),
/* 25 */,
/* 26 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/variables");

/***/ }),
/* 27 */,
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSpaceCompatible = exports.calculatedTargetBounds = exports.visibleSourceBounds = exports.flipBounds = exports.logicalSpace = exports.geoSpace = exports.screenSpace = void 0;

var lodash_1 = __webpack_require__(21);

var lodash_2 = __webpack_require__(21);

exports.screenSpace = {
  x: {
    unit: 'pixel'
  },
  y: {
    unit: 'pixel'
  }
};
exports.geoSpace = {
  lat: {
    unit: '°'
  },
  long: {
    unit: '°'
  }
};
exports.logicalSpace = {
  x: {
    unit: null
  },
  y: {
    unit: null
  }
};

var flipBounds = function flipBounds(bounds, flipAxis) {
  var result = lodash_1.cloneDeep(bounds);
  flipAxis.forEach(function (axis) {
    result[axis].min = bounds[axis].max;
    result[axis].max = bounds[axis].min;
  });
  return result;
};

exports.flipBounds = flipBounds;

var visibleSourceBounds = function visibleSourceBounds(transformation, targetBounds) {
  var minTargetCoordinates = lodash_1.mapValues(targetBounds, function (interval) {
    return interval.min;
  });
  var maxTargetCoordinates = lodash_1.mapValues(targetBounds, function (interval) {
    return interval.max;
  });
  var minSourceCoordinates = transformation.transformBack(minTargetCoordinates);
  var maxSourceCoordinates = transformation.transformBack(maxTargetCoordinates);
  var result = {};
  Object.keys(transformation.sourceSpace).forEach(function (axis) {
    result[axis] = {
      min: minSourceCoordinates[axis],
      max: maxSourceCoordinates[axis]
    };
  });
  return result;
};

exports.visibleSourceBounds = visibleSourceBounds;
/**
 * TODO: this is a suboptimal function name. It should be called transformBoundingBox. It's also a very
 * strange way to go about it. Impl seems counterintuitive
 * @param {ICoordinateTransformation} transformation
 * @param {Bounds} sourceBounds
 * @returns {Bounds}
 */

var calculatedTargetBounds = function visibleSourceBounds(transformation, sourceBounds) {
  var minSourceCoordinates = lodash_1.mapValues(sourceBounds, function (interval) {
    return interval.min;
  });
  var maxSourceCoordinates = lodash_1.mapValues(sourceBounds, function (interval) {
    return interval.max;
  });
  var minTargetCoordinates = transformation.transform(minSourceCoordinates);
  var maxTargetCoordinates = transformation.transform(maxSourceCoordinates);
  var result = {};
  Object.keys(transformation.targetSpace).forEach(function (axis) {
    result[axis] = {
      min: minTargetCoordinates[axis],
      max: maxTargetCoordinates[axis]
    };
  });
  return result;
};

exports.calculatedTargetBounds = calculatedTargetBounds;

function isSpaceCompatible(s1, s2) {
  return lodash_2.isEqual(s1, s2);
}

exports.isSpaceCompatible = isSpaceCompatible;

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/pick");

/***/ }),
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

var _inherits = __webpack_require__(22);

var _possibleConstructorReturn = __webpack_require__(23);

var _getPrototypeOf = __webpack_require__(24);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DATA_ATTRIBUTE = void 0;

var React = __webpack_require__(1);

var lodash_1 = __webpack_require__(21);

var styled_components_1 = __webpack_require__(9);

exports.DATA_ATTRIBUTE = 'data-value';
var StyledSvgChoropleth = styled_components_1.default.div.withConfig({
  displayName: "SvgChoropleth__StyledSvgChoropleth",
  componentId: "sc-17ucmlb-0"
})(["display:flex;flex-direction:column;position:relative;background-color:", ";"], function (props) {
  return props.backgroundColor;
});

var SvgChoropleth = /*#__PURE__*/function (_React$Component) {
  _inherits(SvgChoropleth, _React$Component);

  var _super = _createSuper(SvgChoropleth);

  function SvgChoropleth(props) {
    var _this;

    _classCallCheck(this, SvgChoropleth);

    _this = _super.call(this, props);
    _this.containerRef = React.createRef();
    _this.highlightedCountry = null;

    _this.getLocalCoords = function (clientX, clientY) {
      var rect = _this.containerRef.current.getBoundingClientRect();

      var physX = rect.left;
      var physY = rect.top;
      return {
        x: clientX - physX,
        y: clientY - physY
      };
    };

    _this.handleMapClick = function (event) {
      var clientX = event.clientX,
          clientY = event.clientY;

      var pos = _this.getLocalCoords(clientX, clientY);

      var _this$props = _this.props,
          featureCollection = _this$props.featureCollection,
          onClick = _this$props.onClick;
      var clickedCoords = featureCollection.transformation.transformBack(pos);
      var feature = event.target;
      var wholeFeature = feature.id ? feature : feature.parentNode;

      if (onClick) {
        onClick(clickedCoords, wholeFeature.id);
      }
    };

    _this.handleFeatureEnter = function (ev) {
      var feature = ev.target;

      if (!feature.id && !feature.ownerSVGElement) {
        return;
      }

      var wholeFeature = feature.id ? feature : feature.parentNode; //remove the highlighted country IF we are entering a different country

      if (_this.highlightedCountry && wholeFeature.id !== _this.highlightedCountry.id) {
        _this.unHighlightCountry();
      }

      _this.highlightCountry(wholeFeature);

      if (_this.props.onFeatureHover) {
        _this.props.onFeatureHover({
          featureId: wholeFeature.id,
          label: wholeFeature.getAttribute('label_en'),
          value: wholeFeature.getAttribute(exports.DATA_ATTRIBUTE)
        });
      }
    };

    _this.handleFeatureLeave = function (ev) {
      var feature = ev.target;

      if (!feature.id && !feature.ownerSVGElement) {
        return;
      } // 'wholeFeature' means the SVG <g> (group) of multipolygon features


      var wholeFeature = feature.id ? feature : feature.parentNode; //handling feature leaving should always only deal with the highlighted feature

      if (wholeFeature !== _this.highlightedCountry) {
        return;
      }

      _this.unHighlightCountry(); //wholeFeature.style.stroke = this.lastFeatureStroke;


      if (_this.props.onFeatureHover) {
        _this.props.onFeatureHover({
          featureId: null,
          value: null,
          label: null
        });
      }
    };

    _this.registerSvg = function (el) {
      if (!el) return;
      _this.svgDom = el;
      var _this$props2 = _this.props,
          _this$props2$selector = _this$props2.selector,
          selector = _this$props2$selector === void 0 ? '.feature' : _this$props2$selector,
          strokeColor = _this$props2.strokeColor,
          fillColor = _this$props2.fillColor;
      _this.svgDom.onmouseover = _this.handleFeatureEnter;
      _this.svgDom.onmouseout = _this.handleFeatureLeave;

      _this.svgDom.querySelectorAll(selector).forEach(function (node) {
        node.style.stroke = strokeColor;
        node.style.fill = fillColor;
      });

      _this.updateSvg(_this.props);
    };

    var featureCollection = props.featureCollection;
    _this.state = {
      svgNode: featureCollection.getSvgNode(_this.registerSvg)
    };
    return _this;
  }

  _createClass(SvgChoropleth, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var shouldUpdate = !lodash_1.isEqual(nextState.svgNode, this.state.svgNode) || !lodash_1.isEqual(nextProps, this.props);
      return shouldUpdate;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props !== prevProps) {
        if (prevProps.featureCollection !== this.props.featureCollection) {
          this.setState({
            svgNode: this.props.featureCollection.getSvgNode(this.registerSvg)
          });
        } else {
          this.updateSvg(this.props);
        }
      }
    }
    /**
     * this method renders a copy of the polygon on top of all the others, with a highlighted boundary.
     * Technically we don't render in on top of ALL the others. There are three totally landlocked countries,
     * the first of which in our geojson file is Lesotho. These are also the last three countries in the geojson
     * file. So when we insert the highlight shape into the dom, we inert it *before* these three countries.
     * So the highlight for South Africa will not cover up Lesotho.
     * @param {SVGElement} el
     */

  }, {
    key: "highlightCountry",
    value: function highlightCountry(el) {
      if (this.highlightedCountry) {
        return; // do not add more than one hovered element at a time
      }

      var firstLandlockedCountry = this.svgDom.querySelector("#Lesotho");
      var parent = el.parentNode;
      var clone = el.cloneNode(true);
      var strokeColor = this.props.strokeHighlightColor || '#000';
      clone.style.stroke = strokeColor;
      this.highlightedCountry = clone;
      parent.insertBefore(clone, firstLandlockedCountry);
    }
  }, {
    key: "unHighlightCountry",
    value: function unHighlightCountry() {
      if (this.highlightedCountry) {
        this.svgDom.removeChild(this.highlightedCountry);
      }

      this.highlightedCountry = null;
    }
  }, {
    key: "updateSvg",
    value: function updateSvg(props) {
      var _this2 = this;

      if (!this.svgDom) {
        return;
      }

      var _props$selector = props.selector,
          selector = _props$selector === void 0 ? '.feature' : _props$selector,
          fillColor = props.fillColor,
          data = props.data;

      if (!data) {
        return;
      }

      var dataHashMap = {};
      data.featureIDs.forEach(function (alias, index) {
        var featureId = _this2.getFeatureId(alias);

        dataHashMap[featureId] = {
          fill: data.fill[index],
          value: data.values[index]
        };
      });
      this.svgDom.querySelectorAll(selector).forEach(function (node) {
        var nodeData = dataHashMap[node.id];
        node.style.fill = lodash_1.get(nodeData, 'fill') || fillColor;
        var value = lodash_1.get(nodeData, 'value');

        if (value) {
          node.setAttribute(exports.DATA_ATTRIBUTE, value);
        } else {
          node.removeAttribute(exports.DATA_ATTRIBUTE);
        }
      });
    } //allows a provided alias like 'US-CA' to get mapped to 'California' which is the element id for the SVG shape

  }, {
    key: "getFeatureId",
    value: function getFeatureId(alias) {
      return this.props.featureCollection.resolveAlias(alias);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props$backgroun = this.props.backgroundColor,
          backgroundColor = _this$props$backgroun === void 0 ? 'transparent' : _this$props$backgroun; // note: for some reason, onclick event can't be triggered on dashboard. So change it to onMouseDown

      return React.createElement(StyledSvgChoropleth, {
        "data-test": "styled-svg-choropleth",
        backgroundColor: backgroundColor,
        onMouseDown: this.handleMapClick,
        ref: this.containerRef
      }, this.state.svgNode);
    }
  }]);

  return SvgChoropleth;
}(React.Component);

exports.default = SvgChoropleth;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var ICoordinateTransformation_1 = __webpack_require__(28);

var TransformationChain_1 = __webpack_require__(38);

var CoordinateTransformation = /*#__PURE__*/function () {
  function CoordinateTransformation(sourceSpace, targetSpace) {
    _classCallCheck(this, CoordinateTransformation);

    this.sourceSpace = sourceSpace;
    this.targetSpace = targetSpace;
  }

  _createClass(CoordinateTransformation, [{
    key: "appendTransformation",
    value: function appendTransformation(transformation) {
      if (!ICoordinateTransformation_1.isSpaceCompatible(this.targetSpace, transformation.sourceSpace)) {
        throw new Error(CoordinateTransformation.INCOMPATIBLE_SPACES_ERROR);
      }

      return new TransformationChain_1.default([this, transformation]);
    }
  }]);

  return CoordinateTransformation;
}();

exports.default = CoordinateTransformation;
CoordinateTransformation.INCOMPATIBLE_SPACES_ERROR = "incompatible transformation (appended source space doesn't match chain's output space)";

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/slicedToArray");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(4);

var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var lodash_1 = __webpack_require__(21);

var TransformationChain = /*#__PURE__*/function () {
  function TransformationChain(transformations) {
    _classCallCheck(this, TransformationChain);

    this.transformations = _toConsumableArray(transformations);
    this.sourceSpace = transformations[0].sourceSpace;
    this.targetSpace = lodash_1.last(transformations).targetSpace;
  }

  _createClass(TransformationChain, [{
    key: "appendTransformation",
    value: function appendTransformation(transformation) {
      if (!lodash_1.isEqual(transformation.sourceSpace, lodash_1.last(this.transformations).targetSpace)) {
        throw new Error("Can't chain transformations with incompatible spaces \n            ".concat(JSON.stringify(lodash_1.last(this.transformations).targetSpace), " -> ").concat(JSON.stringify(transformation.sourceSpace)));
      }

      return new TransformationChain([].concat(_toConsumableArray(this.transformations), [transformation]));
    }
  }, {
    key: "transform",
    value: function transform(logicalCoords) {
      var currentCoords = logicalCoords;
      this.transformations.forEach(function (transformation) {
        currentCoords = transformation.transform(currentCoords);
      });
      return currentCoords;
    }
  }, {
    key: "transformBack",
    value: function transformBack(physicalCoords) {
      var currentCoords = physicalCoords;

      for (var idx = this.transformations.length - 1; idx >= 0; idx--) {
        currentCoords = this.transformations[idx].transformBack(currentCoords);
      }

      return currentCoords;
    }
  }]);

  return TransformationChain;
}();

exports.default = TransformationChain;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var BoundsUtils = /*#__PURE__*/function () {
  function BoundsUtils() {
    _classCallCheck(this, BoundsUtils);
  }

  _createClass(BoundsUtils, null, [{
    key: "contains",
    value:
    /**
     * checks if a line segment [dp1, dp2] is fully within a Bounds
     * @param {Bounds} bounds
     * @param {DataPoint} dp1
     * @param {DataPoint} dp2
     * @returns {boolean}
     */
    function contains(bounds, dp1, dp2) {
      return BoundsUtils.withinInterval(bounds, dp1) && BoundsUtils.withinInterval(bounds, dp2);
    }
    /**
     * returns a turf BBox from Bounds.
     * @param {Bounds} bounds Interval keys must be 'lat' and 'long'
     * @returns {number[]} formatted in single array as [long.min, lat.min, long.max, lat.max]
     */

  }, {
    key: "toTurfBBox",
    value: function toTurfBBox(bounds) {
      var long = bounds.long,
          lat = bounds.lat;
      return [long.min, lat.min, long.max, lat.max];
    }
    /**
     * tells if the number is within the inclusive Interval
     * @param {Interval} interval
     * @param {number} v
     * @returns {boolean}
     */

  }, {
    key: "within",
    value: function within(interval, v) {
      return interval.min <= v && interval.max >= v;
    }
    /**
     * returns the distance from interval min to max
     * @param {Interval} interval
     * @returns {number}
     */

  }, {
    key: "distance",
    value: function distance(interval) {
      return interval.max - interval.min;
    }
    /**
     * A very special-purposed utility method that creates CSS style from the Bounds.
     * The 2-dimensional rectangular bounds are converted top, left, width, height
     * @param {Bounds} must use 'x' and 'y' axis and assumes x and y are screen-oriented with zero,zero being the top left
     * @returns {object}
     */

  }, {
    key: "logicalBoundsToCssStyle",
    value: function logicalBoundsToCssStyle(logicalBounds) {
      if (!logicalBounds) {
        return {};
      }

      var xInterval = logicalBounds['x'];
      var yInterval = logicalBounds['y']; // use GeoJsonFeatureGrpup f's Bounds to create a CSS inline style to position the inset using a div

      return {
        position: 'absolute',
        top: yInterval.min,
        left: xInterval.min,
        width: BoundsUtils.distance(xInterval),
        height: BoundsUtils.distance(yInterval),
        border: 'solid 1px'
      };
    }
  }, {
    key: "withinInterval",
    value: function withinInterval(bounds, dp) {
      var axis = Object.keys(dp)[0];
      return BoundsUtils.within(bounds[axis], dp[axis]);
    }
  }]);

  return BoundsUtils;
}();

exports.default = BoundsUtils;

/***/ }),
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = __webpack_require__(16);

var _assertThisInitialized = __webpack_require__(52);

var _inherits = __webpack_require__(22);

var _possibleConstructorReturn = __webpack_require__(23);

var _getPrototypeOf = __webpack_require__(24);

var _classCallCheck = __webpack_require__(17);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFeatureCollections = exports.valueText = exports.estimateTextWidth = exports.round2 = exports.LABEL_FONT_SIZE = void 0;

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(9);

var lodash_1 = __webpack_require__(21);

var pick_1 = __webpack_require__(29);

var variables_1 = __webpack_require__(26);

var SanitizeProps_1 = __webpack_require__(3);

var SvgChoropleth_1 = __webpack_require__(35);

var GeoJsonFeatureCollection_1 = __webpack_require__(53);

var BoundsUtils_1 = __webpack_require__(39);

exports.LABEL_FONT_SIZE = 14;

var round2 = function round2(value) {
  return Math.round(value * 100) / 100;
};

exports.round2 = round2; // todo: maybe can refactor to use `computeTextSize` in @splunk/visualizations-shared/domUtils.js

var estimateTextWidth = function estimateTextWidth(text, fontsize) {
  if (text == null) {
    return 0;
  }

  var avgLowerCaseWidth = 0.55 * fontsize;
  var avgUpperCaseWidth = 0.7 * fontsize;
  var length = 0;

  for (var pos = 0; pos < text.length; pos += 1) {
    var c = text.charAt(pos);

    if (lodash_1.includes('Iij.,;:!lt/', c)) {
      length += 0.2 * fontsize;
    } else if (c === '_') {
      length += 0.8 * fontsize;
    } else {
      length += c === c.toUpperCase() ? avgUpperCaseWidth : avgLowerCaseWidth;
    }
  }

  return length;
};

exports.estimateTextWidth = estimateTextWidth; // todo: maybe can refactor to use `formatNumber` in ../utils/numberUtils

var valueText = function valueText(value) {
  if (value === 0) {
    return '0';
  }

  if (typeof value === 'string') {
    return value;
  }

  var magnitude = Math.floor(Math.log10(Math.abs(value)) / 3);
  var divisor = Math.pow(10, 3 * magnitude);
  var suffixList = ['', 'k', 'm', 'bn', 'tn', 'qn'];
  var suffix = magnitude < 0 ? "/".concat(suffixList[-magnitude]) : suffixList[magnitude];
  return "".concat(exports.round2(value / divisor)).concat(suffix);
};

exports.valueText = valueText;

function createFeatureCollections(props) {
  var sourceBounds = props.sourceBounds,
      logicalBounds = props.logicalBounds,
      projection = props.projection,
      geoJson = props.geoJson,
      geoFeatureGroups = props.geoFeatureGroups;
  var featureCollections = [];

  if (geoFeatureGroups) {
    geoFeatureGroups.forEach(function (g) {
      featureCollections.push(new GeoJsonFeatureCollection_1.default("".concat(props.name, ".").concat(g.name), logicalBounds, projection, geoJson, g, sourceBounds));
    });
  } else {
    featureCollections.push(new GeoJsonFeatureCollection_1.default(props.name, logicalBounds, projection, geoJson, undefined, sourceBounds));
  }

  return featureCollections;
}

exports.createFeatureCollections = createFeatureCollections;

var TTArgType = function TTArgType() {
  _classCallCheck(this, TTArgType);
};

var TooltipBubble = styled_components_1.default.div.attrs(function () {
  return {
    key: 'bubble'
  };
}).withConfig({
  displayName: "GeoJsonChoropleth__TooltipBubble",
  componentId: "sc-2ro2y1-0"
})(["background-color:", ";border-radius:5px;padding:5px;display:flex;flex-direction:column;align-items:center;justify-content:center;box-shadow:0px 5px 14px 0 rgba(0,0,100,0.12);width:", "px;transition:width 100ms;"], pick_1.default({
  enterprise: {
    light: variables_1.default.white,
    dark: '#27292e' // enterpriseBackgroundColor

  },
  prisma: variables_1.default.backgroundColorPopup
}), function (props) {
  return props.maxTextWidth;
});
var TooltipLabel = styled_components_1.default.div.attrs(function () {
  return {
    'data-test': 'geojson-choropleth-tooltip-label'
  };
}).withConfig({
  displayName: "GeoJsonChoropleth__TooltipLabel",
  componentId: "sc-2ro2y1-1"
})(["margin-bottom:2px;width:", "px;text-align:center;color:", ";"], function (props) {
  return props.maxTextWidth;
}, pick_1.default({
  enterprise: {
    // unfortunately cannot access variables.textGray directly colors since variables are theme-aware
    light: 'rgba(0, 0, 0, 0.65)',
    dark: 'rgba(255, 255, 255, 0.7)' // equivalent to enterprise.textGray

  },
  prisma: variables_1.default.contentColorDefault
}));
var ArrowDown = styled_components_1.default.div.withConfig({
  displayName: "GeoJsonChoropleth__ArrowDown",
  componentId: "sc-2ro2y1-2"
})(["position:relative;top:-1px;width:0px;height:0px;border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid ", ";"], pick_1.default({
  enterprise: {
    light: variables_1.default.white,
    dark: '#27292e' // enterpriseBackgroundColor

  },
  prisma: variables_1.default.backgroundColorPopup
}));
var TooltipValue = styled_components_1.default.div.attrs(function () {
  return {
    'data-test': 'geojson-choropleth-tooltip-value'
  };
}).withConfig({
  displayName: "GeoJsonChoropleth__TooltipValue",
  componentId: "sc-2ro2y1-3"
})(["color:", ";"], pick_1.default({
  enterprise: {
    // unfortunately cannot access variables.textGray directly colors since variables are theme-aware
    light: '#2c2c2c',
    dark: 'rgba(255, 255, 255, 0.98)' // equivalent to enterprise.textGray

  },
  prisma: variables_1.default.contentColorActive
}));
var GeoJsonChoroplethContainer = styled_components_1.default.div.attrs(function () {
  return {
    'data-test': 'geojson-choropleth-container'
  };
}).withConfig({
  displayName: "GeoJsonChoropleth__GeoJsonChoroplethContainer",
  componentId: "sc-2ro2y1-4"
})(["background-color:", ";position:relative;"], pick_1.default({
  enterprise: {
    dark: variables_1.default.black,
    light: variables_1.default.backgroundColorSidebar
  },
  prisma: variables_1.default.backgroundColorSidebar
}));

var ToolTip = function ToolTip(arg) {
  var reference = arg.reference,
      left = arg.left,
      top = arg.top,
      label = arg.label,
      value = arg.value;
  var maxTextWidth = Math.max(exports.estimateTextWidth(label, exports.LABEL_FONT_SIZE), exports.estimateTextWidth(value, exports.LABEL_FONT_SIZE)) + 10;
  return React.createElement("div", {
    key: "tooltip",
    ref: reference,
    style: {
      position: 'absolute',
      top: top,
      left: left,
      pointerEvents: 'none',
      visibility: label || value ? 'visible' : 'hidden'
    }
  }, React.createElement("div", {
    style: {
      position: 'relative',
      left: '-50%',
      top: '-56px',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'flex-start',
      fontSize: exports.LABEL_FONT_SIZE
    }
  }, React.createElement(TooltipBubble, {
    maxTextWidth: maxTextWidth
  }, React.createElement(TooltipLabel, {
    maxTextWidth: maxTextWidth
  }, " ", label, " "), React.createElement(TooltipValue, null, exports.valueText(value))), React.createElement(ArrowDown, null)));
};

var GeoJsonChoropleth = /*#__PURE__*/function (_React$Component) {
  _inherits(GeoJsonChoropleth, _React$Component);

  var _super = _createSuper(GeoJsonChoropleth);

  function GeoJsonChoropleth(props) {
    var _this;

    _classCallCheck(this, GeoJsonChoropleth);

    _this = _super.call(this, props);
    _this.containerRef = React.createRef();
    _this.toolTipRef = React.createRef();
    _this.state = {
      featureCollections: createFeatureCollections(props),
      toolTip: null
    };
    _this.cursorPos = {
      x: 0,
      y: 0
    };
    _this.handleMouseMove = _this.handleMouseMove.bind(_assertThisInitialized(_this));
    _this.handleFeatureHover = _this.handleFeatureHover.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(GeoJsonChoropleth, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props = this.props,
          sourceBounds = _this$props.sourceBounds,
          logicalBounds = _this$props.logicalBounds,
          projection = _this$props.projection,
          geoJson = _this$props.geoJson;

      if (prevProps.geoJson !== geoJson || prevProps.sourceBounds !== sourceBounds || prevProps.logicalBounds !== logicalBounds || prevProps.projection !== projection) {
        this.setState({
          featureCollections: createFeatureCollections(this.props)
        });
      }
    }
  }, {
    key: "getLocalCoords",
    value: function getLocalCoords(clientX, clientY) {
      var rect = this.containerRef.current.getBoundingClientRect();
      var physX = rect.left;
      var physY = rect.top;
      var scaleX = this.containerRef.current.offsetWidth / rect.width;
      var scaleY = this.containerRef.current.offsetHeight / rect.height;
      return {
        x: (clientX - physX) * scaleX,
        y: (clientY - physY) * scaleY
      };
    }
  }, {
    key: "handleMouseMove",
    value: function handleMouseMove(ev) {
      this.cursorPos = this.getLocalCoords(ev.clientX, ev.clientY);

      if (this.toolTipRef.current) {
        this.toolTipRef.current.style.left = "".concat(this.cursorPos.x, "px");
        this.toolTipRef.current.style.top = "".concat(this.cursorPos.y, "px");
      }
    }
  }, {
    key: "handleFeatureHover",
    value: function handleFeatureHover(_ref) {
      var featureId = _ref.featureId,
          value = _ref.value,
          label = _ref.label;

      if (featureId) {
        this.setState({
          toolTip: {
            label: label || featureId,
            value: value || '-no data-'
          }
        });
      } else {
        this.setState({
          toolTip: null
        });
      }

      var externalHandler = this.props.onFeatureHover;

      if (externalHandler) {
        externalHandler(featureId);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var children = [];
      var relevantProps = lodash_1.omit(this.props, ['sourceBounds', 'logicalBounds', 'projection']);
      var toolTip = this.state.toolTip; // create one child SvgChoropleth for each GeoJsonFeatureCollection

      this.state.featureCollections.forEach(function (f) {
        var props = Object.assign(Object.assign({}, relevantProps), {
          onFeatureHover: _this2.handleFeatureHover,
          featureCollection: f
        });
        var svgChoropleth = React.createElement(SvgChoropleth_1.default, props);
        var style = {};
        var logicalBounds = lodash_1.get(f, ['group', 'logicalBounds']);

        if (logicalBounds) {
          style = BoundsUtils_1.default.logicalBoundsToCssStyle(logicalBounds);
        }

        children.push(React.createElement('div', {
          key: f.name,
          style: style
        }, svgChoropleth));
      });
      return React.createElement(GeoJsonChoroplethContainer, {
        ref: this.containerRef,
        onMouseMove: this.handleMouseMove
      }, children, React.createElement(ToolTip, {
        reference: this.toolTipRef,
        left: this.cursorPos.x,
        top: this.cursorPos.y,
        label: lodash_1.get(toolTip, 'label'),
        value: lodash_1.get(toolTip, 'value')
      }));
    }
  }]);

  return GeoJsonChoropleth;
}(React.Component);

exports.default = SanitizeProps_1.withSanitizedProps(GeoJsonChoropleth);

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/assertThisInitialized");

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

var _slicedToArray = __webpack_require__(37);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderGeoJsonFeature = exports.polygon = exports.ring = exports.pickLogicalBnds = exports.DEFAULT_LOGICAL_BOUNDS = exports.featureGroupMatcher = exports.MATCH_ALL_FEATUREGROUP_MATCHER = void 0;

var MercatorTransformation_1 = __webpack_require__(54);

var GeometryStreamSVGRenderer_1 = __webpack_require__(55);

var ICoordinateTransformation_1 = __webpack_require__(28);

var LinearTransformation_1 = __webpack_require__(60);

var TransformationChain_1 = __webpack_require__(38);

var lodash_1 = __webpack_require__(21);

var BoundsUtils_1 = __webpack_require__(39);

var bbox_clip_1 = __webpack_require__(62); // eslint-disable-next-line @typescript-eslint/no-unused-vars


var MATCH_ALL_FEATUREGROUP_MATCHER = function MATCH_ALL_FEATUREGROUP_MATCHER(feature) {
  return true;
};

exports.MATCH_ALL_FEATUREGROUP_MATCHER = MATCH_ALL_FEATUREGROUP_MATCHER;

function featureGroupMatcher(g) {
  if (!g || !g.featureMatcher || !g.featureMatcher.regex || !g.featureMatcher.property) {
    // if no matcher things defined, then we are not filtering features, and therefore should match all
    // eslint-disable-next-line
    return exports.MATCH_ALL_FEATUREGROUP_MATCHER;
  }

  var matcher = new RegExp(g.featureMatcher.regex);
  return function (feature) {
    var val = lodash_1.get(feature, ['properties', g.featureMatcher.property]);

    if (!val) {
      return false;
    }

    return matcher.test(val);
  };
}

exports.featureGroupMatcher = featureGroupMatcher;
exports.DEFAULT_LOGICAL_BOUNDS = {
  x: {
    min: 0,
    max: 800
  },
  y: {
    min: 0,
    max: 600
  }
}; // default logical bounds
// same as with sourceBounds, logical bound can be global or local to the FeatureGroup. They also need to have defaults
// which are provided here.

function pickLogicalBnds(globalLogicalBnds, g) {
  if (g && g.logicalBounds) {
    return g.logicalBounds;
  }

  if (globalLogicalBnds) {
    return globalLogicalBnds;
  }

  return exports.DEFAULT_LOGICAL_BOUNDS;
}

exports.pickLogicalBnds = pickLogicalBnds;

function ring(coords, renderer, bounds, props) {
  //polygon coords is array of number array
  renderer.beginNode('polygon', props);

  for (var i = 0; i < coords.length; i++) {
    var _coords$i = _slicedToArray(coords[i], 2),
        long = _coords$i[0],
        lat = _coords$i[1];

    if (bounds && !BoundsUtils_1.default.contains(bounds, {
      long: long
    }, {
      lat: lat
    })) {
      // the polygon is not entirely contained by the bounds. We must cancel (remove) the polygon along with any
      // points that were previously added to it.
      renderer.cancelNode();
      console.warn("out-of-bounds polygon dropped: ".concat(JSON.stringify(props)));
      return; // bail ... we don't need to endNode() since we cancelled it
    } else {
      renderer.addPoint({
        long: long,
        lat: lat
      });
    }
  }

  renderer.endNode();
}

exports.ring = ring;

function polygon(coords, renderer, bounds) {
  //polygon coords is array of number array
  for (var poly = 0; poly < coords.length; poly++) {
    ring(coords[poly], renderer, bounds);
  }
}

exports.polygon = polygon;

function renderGeoJsonFeature(feature, renderer, bounds) {
  var bbox = bounds ? BoundsUtils_1.default.toTurfBBox(bounds) : undefined;
  var type = feature['geometry'].type;

  if (lodash_1.get(feature, ['properties', 'name']) === 'Antarctica') {
    //skip shapes that cannot be mercator projected
    //no-op
    return;
  } // demo hack...


  var props = feature['properties'];

  if (props.iso_3166_2) {
    props.id = props.iso_3166_2;
  } else {
    props.id = props.name;
  }

  props.className = 'feature'; // end demo hack

  switch (type) {
    case 'MultiPolygon':
      {
        renderer.beginNode('g', props); //svg has groups ('g') but no polygon

        feature = bbox ? bbox_clip_1.default(feature, bbox) : feature;
        var multis = lodash_1.get(feature, ['geometry', 'coordinates']);
        multis.forEach(function (multi) {
          return polygon(multi, renderer, bounds);
        });
        renderer.endNode();
        break;
      }

    case 'Polygon':
      {
        feature = bbox ? bbox_clip_1.default(feature, bbox) : feature;
        var rings = lodash_1.get(feature, ['geometry', 'coordinates']);
        rings.forEach(function (r) {
          return ring(r, renderer, bounds, props);
        });
        break;
      }

    default:
      {
        throw new Error('Unsupported geojson type: ' + type);
      }
  }
}

exports.renderGeoJsonFeature = renderGeoJsonFeature;

function computeBounds(geoJson, matcher) {
  //replace the renderer with one that is configured only to compute logicalBounds (for performance)
  var boundsComputer = new GeometryStreamSVGRenderer_1.GeometryStreamSVGRenderer();
  boundsComputer.computeBoundsOnly = true;
  geoJson['features'].forEach(function (feature) {
    if (matcher(feature)) {
      renderGeoJsonFeature(feature, boundsComputer);
    }
  });
  return boundsComputer.getBounds();
} // the source bounds can be provided globally for all feature groups, or they can be provided within a FeatureGroup
// or they can be omitted entirely which means they must be computed by parsing the geoJson


function pickSrcBnds(geoJson, g, globalSrcBnds, featureMatcher) {
  if (g && g.sourceBounds) {
    return g.sourceBounds; // return FeatureGroup "local" sourceBounds if they exist.
  }

  if (globalSrcBnds) {
    return globalSrcBnds; // return global bounds if they exist
  } // ...'auto' compute the source bounds from the data.


  var b = computeBounds(geoJson, featureMatcher); //automatically compute sourceBounds if not provided

  if (!b) {
    throw new Error("Could not determine bounds for geoFeatureGroup name='".concat(this.name, "' (no features matched)"));
  }

  return b;
}

var GeoJsonFeatureCollection = /*#__PURE__*/function () {
  function GeoJsonFeatureCollection(name, globalLogicalBnds, projectionType, geoJson, g, globalSrcBounds) {
    _classCallCheck(this, GeoJsonFeatureCollection);

    this.name = name;
    this.projectionType = projectionType || 'mercator';
    this.geoJson = geoJson;
    this.group = g;
    this.featureMatcher = featureGroupMatcher(g);
    this.logicalBounds = pickLogicalBnds(globalLogicalBnds, g);
    this.sourceBounds = pickSrcBnds(geoJson, g, globalSrcBounds, this.featureMatcher);
    var minLat = this.sourceBounds.lat.min;
    var maxLat = this.sourceBounds.lat.max;
    var projection;

    switch (projectionType) {
      case 'equirectangular':
        projection = new GeometryStreamSVGRenderer_1.IdentityTransform();
        break;

      case 'mercator':
        if (Math.abs(minLat) > 85 || Math.abs(maxLat) > 85) {
          throw new Error("Invalid latitude boundaries for mercator projection : ".concat(minLat, "/").concat(maxLat));
        }

        projection = new MercatorTransformation_1.MercatorTransformation();
        break;

      default:
        {
          throw new Error('Unsupported projection: ' + projectionType);
        }
    }

    var projectedBounds = ICoordinateTransformation_1.calculatedTargetBounds(projection, this.sourceBounds);
    var scaleTransformation = new LinearTransformation_1.default(ICoordinateTransformation_1.logicalSpace, ICoordinateTransformation_1.logicalSpace, ICoordinateTransformation_1.flipBounds(projectedBounds, ['y']), this.logicalBounds, null, true);
    this.transformation = new TransformationChain_1.default([projection, scaleTransformation]);
  }

  _createClass(GeoJsonFeatureCollection, [{
    key: "contains",
    value: function contains(x, y) {
      var bounds = lodash_1.get(this.group, ['logicalBounds']);

      if (!bounds) {
        return true;
      } // return whether or not the x,y mouse screen location is inside this feature collection


      return BoundsUtils_1.default.contains(bounds, {
        x: x
      }, {
        y: y
      });
    }
  }, {
    key: "getSvgNode",
    value: function getSvgNode(ref) {
      var _this = this;

      var features = this.geoJson.features;
      var renderer = new GeometryStreamSVGRenderer_1.GeometryStreamSVGRenderer(this.transformation);
      renderer.beginNode('svg', {
        ref: ref,
        height: BoundsUtils_1.default.distance(this.logicalBounds.y),
        width: BoundsUtils_1.default.distance(this.logicalBounds.x)
      });
      features.forEach(function (feature) {
        if (_this.featureMatcher(feature)) {
          renderGeoJsonFeature(feature, renderer, _this.sourceBounds);
        }
      });
      renderer.endNode();
      return renderer.getRoot();
    }
  }, {
    key: "resolveAlias",
    value: function resolveAlias(alias) {
      if (!this.aliases) {
        this.aliases = GeoJsonFeatureCollection.makeAliasMap(this.geoJson.features); //memoize
      }

      var aliases = this.aliases;

      if (aliases) {
        return aliases.get(alias.toLocaleLowerCase()) || alias;
      }

      return alias;
    }
  }], [{
    key: "makeAliasMap",
    value: function makeAliasMap(features) {
      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
      return features.reduce(function (aliases, feature) {
        var geoJsonProperties = feature['properties'];
        var name = geoJsonProperties.iso_3166_2; // eslint-disable-next-line @typescript-eslint/explicit-function-return-type

        Object.keys(geoJsonProperties).forEach(function (k) {
          k != name && aliases.set(geoJsonProperties[k].toLowerCase(), name); // alias all the other properies to the name property
        });
        return aliases;
      }, new Map());
    }
  }]);

  return GeoJsonFeatureCollection;
}();

exports.default = GeoJsonFeatureCollection;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

var _inherits = __webpack_require__(22);

var _possibleConstructorReturn = __webpack_require__(23);

var _getPrototypeOf = __webpack_require__(24);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MercatorTransformation = void 0;

var ICoordinateTransformation_1 = __webpack_require__(28);

var CoordinateTransformation_1 = __webpack_require__(36); // transform converts degrees to an x,y mercator map whose units are radians. InverseTransform goes from radians on the x,y map back to degrees.


var MercatorTransformation = /*#__PURE__*/function (_CoordinateTransforma) {
  _inherits(MercatorTransformation, _CoordinateTransforma);

  var _super = _createSuper(MercatorTransformation);

  function MercatorTransformation() {
    _classCallCheck(this, MercatorTransformation);

    return _super.call(this, ICoordinateTransformation_1.geoSpace, ICoordinateTransformation_1.logicalSpace);
  }

  _createClass(MercatorTransformation, [{
    key: "transformBack",
    value: function transformBack(coord) {
      var x = coord.x,
          y = coord.y;
      return {
        long: x * 180 / Math.PI,
        lat: (2 * Math.atan(Math.exp(y)) - Math.PI / 2) * 180 / Math.PI
      };
    }
  }, {
    key: "transform",
    value: function transform(coord) {
      var lat = coord.lat,
          long = coord.long;

      if (long > 180) {
        console.warn("Mercator projection: Truncating illegal longitude to 180: long");
        long = 180;
      }

      if (long < -180) {
        console.warn("Mercator projection: Truncating illegal longitude to -180: long");
        long = -180;
      }

      if (lat > 85) {
        console.warn("Mercator projection: Truncating illegal latitude to 85: lat");
        lat = 85;
      }

      if (lat < -85) {
        console.warn("Mercator projection: Truncating illegal latitude to -85: lat");
        lat = -85;
      }

      return {
        x: Math.PI * long / 180,
        y: Math.log(Math.tan(Math.PI / 4 + lat / 180 * Math.PI / 2))
      };
    }
  }]);

  return MercatorTransformation;
}(CoordinateTransformation_1.default);

exports.MercatorTransformation = MercatorTransformation;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _get = __webpack_require__(56);

var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

var _inherits = __webpack_require__(22);

var _possibleConstructorReturn = __webpack_require__(23);

var _getPrototypeOf = __webpack_require__(24);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeometryStreamSVGRenderer = exports.IdentityTransform = void 0;

var ICoordinateTransformation_1 = __webpack_require__(28);

var CoordinateTransformation_1 = __webpack_require__(36);

var BoundsCollector_1 = __webpack_require__(57);

var NodeTreeReactGenerator_1 = __webpack_require__(58); // fixme TODO: should the identity transform really have different source and target spaces? That's a bit confusing
// as one would expect the identity transform could be inserted anywhere in a TransformationChain


var IdentityTransform = /*#__PURE__*/function (_CoordinateTransforma) {
  _inherits(IdentityTransform, _CoordinateTransforma);

  var _super = _createSuper(IdentityTransform);

  function IdentityTransform() {
    _classCallCheck(this, IdentityTransform);

    return _super.call(this, ICoordinateTransformation_1.geoSpace, ICoordinateTransformation_1.logicalSpace);
  }

  _createClass(IdentityTransform, [{
    key: "transform",
    value: function transform(sourceCoords) {
      return {
        x: sourceCoords.long,
        y: sourceCoords.lat
      };
    }
  }, {
    key: "transformBack",
    value: function transformBack(targetCoords) {
      return {
        lat: targetCoords.y,
        long: targetCoords.x
      };
    }
  }]);

  return IdentityTransform;
}(CoordinateTransformation_1.default);

exports.IdentityTransform = IdentityTransform;

var GeometryStreamSVGRenderer = /*#__PURE__*/function (_NodeTreeReactGenerat) {
  _inherits(GeometryStreamSVGRenderer, _NodeTreeReactGenerat);

  var _super2 = _createSuper(GeometryStreamSVGRenderer);

  function GeometryStreamSVGRenderer(transformer) {
    var _this;

    _classCallCheck(this, GeometryStreamSVGRenderer);

    _this = _super2.call(this);
    _this.transformer = new IdentityTransform();
    _this.computeBoundsOnly = false;
    _this.boundsCollector = new BoundsCollector_1.default();

    if (transformer) {
      _this.transformer = transformer;
    }

    return _this;
  }

  _createClass(GeometryStreamSVGRenderer, [{
    key: "addPoint",
    value: function addPoint(p) {
      this.boundsCollector.addPoint(p);

      if (this.computeBoundsOnly) {
        return;
      }

      var el = _get(_getPrototypeOf(GeometryStreamSVGRenderer.prototype), "peek", this).call(this);

      var points = el.attributes['points'];

      if (points) {
        el.attributes['points'] += ' ';
      } else {
        el.attributes['points'] = ''; // initialize
      }

      var _this$transformer$tra = this.transformer.transform(p),
          x = _this$transformer$tra.x,
          y = _this$transformer$tra.y;
      /*
      if(!x || !y){
          throw new Error("DataPoint did not contain an x and y coordinate (cannot be rendered to SVG).: " + JSON.stringify(p));
      }
       */


      el.attributes['points'] += x + ',' + y; // FIXME TODO probably should not look for hard coded x and y in DataPoint
    }
  }, {
    key: "beginNode",
    value: function beginNode(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.computeBoundsOnly) {
        return;
      }

      return _get(_getPrototypeOf(GeometryStreamSVGRenderer.prototype), "beginNode", this).call(this, name, attributes);
    }
  }, {
    key: "endNode",
    value: function endNode() {
      if (this.computeBoundsOnly) {
        return;
      }

      _get(_getPrototypeOf(GeometryStreamSVGRenderer.prototype), "endNode", this).call(this);
    } // automatically compute the logicalBounds based on the points that were added. This is 'auto' style of bounding box.

  }, {
    key: "getBounds",
    value: function getBounds() {
      return this.boundsCollector.getBounds();
    }
  }, {
    key: "clear",
    value: function clear() {
      _get(_getPrototypeOf(GeometryStreamSVGRenderer.prototype), "clear", this).call(this);

      this.boundsCollector = new BoundsCollector_1.default();
    }
  }]);

  return GeometryStreamSVGRenderer;
}(NodeTreeReactGenerator_1.NodeTreeReactGenerator);

exports.GeometryStreamSVGRenderer = GeometryStreamSVGRenderer;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/get");

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var BoundsCollector = /*#__PURE__*/function () {
  function BoundsCollector() {
    _classCallCheck(this, BoundsCollector);

    this.intervals = {};
  }

  _createClass(BoundsCollector, [{
    key: "getBounds",
    value: function getBounds() {
      return Object.keys(this.intervals).length > 0 ? this.intervals : undefined;
    } // expand the Bounds if the added point is outside the Bounds.
    // Since we don't know what they axes will be for a given DataPoint

  }, {
    key: "addPoint",
    value: function addPoint(p) {
      var _this = this;

      Object.keys(p).forEach(function (axis) {
        var interval = _this.intervals[axis];

        if (!interval) {
          interval = {
            min: p[axis],
            max: p[axis]
          };
          _this.intervals[axis] = interval;
        }

        if (p[axis] < interval.min) {
          interval.min = p[axis];
        }

        if (p[axis] > interval.max) {
          interval.max = p[axis];
        }
      });
    }
  }]);

  return BoundsCollector;
}();

exports.default = BoundsCollector;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = __webpack_require__(37);

var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeTreeReactGenerator = exports.ElementStructure = void 0;

var React = __webpack_require__(1);

var camelCase = __webpack_require__(59);
/**
 * This class represents the structure of a React element.
 */


var ElementStructure = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} name - the element's tag name
   * @param {object} attributes - the element's attributes
   * @param {string} textContent - optional text content for a node
   */
  function ElementStructure(name) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var textContent = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck(this, ElementStructure);

    this.attributes = {};
    this.children = [];
    this.name = name;
    this.attributes = ElementStructure.processStyleAttributes(attributes);
    this.textContent = textContent;
  }

  _createClass(ElementStructure, null, [{
    key: "processStyleAttributes",
    value: function processStyleAttributes(a) {
      if (a['style']) {
        a['style'] = ElementStructure.parseStyle(a['style']);
      }

      return a;
    }
    /**
     * In react, the style attribute is an object, not an inline css style string. This function converts inline css
     * style string into discrete key-value object that plays nicely with react.
     * @param {string} style
     * @returns {object}
     */

  }, {
    key: "parseStyle",
    value: function parseStyle(style) {
      var o = {}; // eslint-disable-next-line @typescript-eslint/explicit-function-return-type

      style.split(';').forEach(function (s) {
        var _s$split = s.split(':'),
            _s$split2 = _slicedToArray(_s$split, 2),
            k = _s$split2[0],
            v = _s$split2[1];

        o[camelCase(k)] = v;
      });
      return o;
    }
  }]);

  return ElementStructure;
}();

exports.ElementStructure = ElementStructure;
/**
 * This class is used to build up a node tree. The node tree is turned into a ReactNode when the root node of the
 * tree is closed (aka  the closing tag).
 */

var NodeTreeReactGenerator = /*#__PURE__*/function () {
  function NodeTreeReactGenerator() {
    _classCallCheck(this, NodeTreeReactGenerator);

    this._stack = [];
  }
  /**
   * This method is called to indicate an opening element tag.
   * @param {string} name - the element's tag name
   * @param {object} attributes - the element's attributes
   * @param {string} textContent - optional text content for a node
   */


  _createClass(NodeTreeReactGenerator, [{
    key: "beginNode",
    value: function beginNode(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var textContent = arguments.length > 2 ? arguments[2] : undefined;
      var attrCopy = {
        key: Math.random()
      }; // eslint-disable-next-line @typescript-eslint/explicit-function-return-type

      Object.keys(attributes).forEach(function (k) {
        if (k.startsWith('data-')) {
          attrCopy[k] = attributes[k];
        } else {
          attrCopy[camelCase(k)] = attributes[k];
        }
      });

      this._stack.push(new ElementStructure(name, attrCopy, textContent));
    }
    /**
     * This method closes a tag. When a tag is closed its ElementStructure is converted to a ReactNode and added to the set of
     * child nodes tracked by the parent's ElementStructure. If the tag being closed is the root node, then the _root
     * is set and we are done, having created the ReactNode representing the entire tree.
     */

  }, {
    key: "endNode",
    value: function endNode() {
      var popped = this._stack.pop();

      var name = popped.name,
          attributes = popped.attributes,
          children = popped.children,
          textContent = popped.textContent;
      var el = this.peek();
      var reactNode = null;

      if (children.length === 0) {
        if (textContent) {
          reactNode = React.createElement(name, attributes, textContent);
        } else {
          reactNode = React.createElement(name, attributes);
        }
      } else {
        if (textContent) {
          throw new Error("textContent can't be mixed with children on node ".concat(name));
        }

        reactNode = React.createElement(name, attributes, children);
      }

      if (this.decorator) {
        reactNode = this.decorator(reactNode);
      }

      if (el) {
        el.children.push(reactNode);
      } else {
        this._root = reactNode;
      }
    }
  }, {
    key: "peek",
    value: function peek() {
      if (this._stack.length === 0) {
        return null;
      }

      return this._stack[this._stack.length - 1];
    }
    /**
     * Returns the ReactNode representing the entire tree, or throws Error if tree is not fully processed.
     * @returns {React.ReactElement}
     */

  }, {
    key: "getRoot",
    value: function getRoot() {
      if (this._root) {
        return this._root;
      } else {
        throw new Error("Can't compute ReactElement until root node has been closed. Node stack: ".concat(this._stack));
      }
    }
    /**
     * Clears internal structures so this instance can be used to process a new tree.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._stack = [];
      this._root = null;
    }
    /**
     * Allows the current tag and all its children to be erased.
     */

  }, {
    key: "cancelNode",
    value: function cancelNode() {
      this._stack.pop();
    }
  }]);

  return NodeTreeReactGenerator;
}();

exports.NodeTreeReactGenerator = NodeTreeReactGenerator;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = require("lodash/camelCase");

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

var _inherits = __webpack_require__(22);

var _possibleConstructorReturn = __webpack_require__(23);

var _getPrototypeOf = __webpack_require__(24);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBoundsInfo = void 0;

var lodash_1 = __webpack_require__(21);

var Scale_1 = __webpack_require__(61);

var CoordinateTransformation_1 = __webpack_require__(36);

var sign = Math.sign || function (n) {
  if (n < 0) return -1;
  if (n > 0) return 1;
  return 0;
};

var signedDistance = function distance(interval) {
  return interval.max - interval.min;
};

var direction = function direction(interval) {
  return sign(interval.max - interval.min);
};

var createBoundsInfo = function createBoundsInfo(sourceBounds, transformation) {
  return {
    sourceBounds: sourceBounds,
    scaleFactors: lodash_1.mapValues(transformation.scales, function (scale) {
      return scale.scaleFactor;
    })
  };
};

exports.createBoundsInfo = createBoundsInfo;

var LinearTransformation = /*#__PURE__*/function (_CoordinateTransforma) {
  _inherits(LinearTransformation, _CoordinateTransforma);

  var _super = _createSuper(LinearTransformation);

  function LinearTransformation(sourceDimensions, targetDimensions, sourceBounds, targetBounds, mapping) {
    var _this;

    var preserveAspectRatio = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

    _classCallCheck(this, LinearTransformation);

    _this = _super.call(this, sourceDimensions, targetDimensions);
    _this.targetCoordinate = {};
    _this.sourceCoordinate = {};
    _this.preserveAspectRatio = preserveAspectRatio;
    _this.scales = {};
    Object.keys(sourceDimensions).forEach(function (sourceCoordinate) {
      var targetCoordinate = mapping ? mapping[sourceCoordinate] : sourceCoordinate;
      _this.scales[sourceCoordinate] = new Scale_1.Scale();
      _this.targetCoordinate[sourceCoordinate] = targetCoordinate;
      _this.sourceCoordinate[targetCoordinate] = sourceCoordinate;
    });

    if (sourceBounds && targetBounds) {
      _this.fit(sourceBounds, targetBounds);
    }

    return _this;
  }

  _createClass(LinearTransformation, [{
    key: "fit",
    value: function fit(sourceRanges, targetRanges) {
      if (this.preserveAspectRatio) {
        return this.fitUndistorted(sourceRanges, targetRanges);
      } else {
        return this.fitIndependently(sourceRanges, targetRanges);
      }
    }
  }, {
    key: "fitUndistorted",
    value: function fitUndistorted(sourceRanges, targetRanges) {
      var _this2 = this;

      var minScale = Number.MAX_VALUE;
      Object.keys(sourceRanges).forEach(function (dimension) {
        var targetDimension = _this2.targetCoordinate[dimension];

        if (!targetRanges[targetDimension]) {
          throw new Error("Missing targetRanges for dimension ".concat(targetDimension));
        }

        var range = sourceRanges[dimension];
        var sourceDistance = Math.abs(range.max - range.min);
        var targetBounds = Scale_1.toInterval(targetRanges[targetDimension]);
        minScale = Math.min(minScale, Math.abs(signedDistance(targetBounds)) / sourceDistance);
      });
      Object.keys(sourceRanges).forEach(function (dimension) {
        var targetDimension = _this2.targetCoordinate[dimension];

        _this2.scales[dimension].update(minScale * direction(Scale_1.toInterval(sourceRanges[targetDimension])), sourceRanges[dimension].min);
      });
      return this;
    }
  }, {
    key: "fitIndependently",
    value: function fitIndependently(sourceRanges, targetRanges) {
      var _this3 = this;

      Object.keys(sourceRanges).forEach(function (dimension) {
        var targetDimension = _this3.targetCoordinate[dimension];

        if (!targetRanges[targetDimension]) {
          throw new Error("Missing parameter targetRanges for dimension ".concat(dimension));
        }

        _this3.scales[dimension].fit(sourceRanges[dimension], targetRanges[targetDimension]);
      });
      return this;
    }
  }, {
    key: "transform",
    value: function transform(sourcePoint) {
      var _this4 = this;

      var result = {};
      Object.keys(this.sourceSpace).forEach(function (dimension) {
        return result[_this4.targetCoordinate[dimension]] = _this4.scales[dimension].source2Target(sourcePoint[dimension]);
      });
      return result;
    }
  }, {
    key: "transformBack",
    value: function transformBack(targetPoint) {
      var _this5 = this;

      var result = {};
      Object.keys(this.targetSpace).forEach(function (coordinate) {
        var sourceCoordinate = _this5.sourceCoordinate[coordinate];
        result[sourceCoordinate] = _this5.scales[sourceCoordinate].target2Source(targetPoint[coordinate]);
      });
      return result;
    }
  }, {
    key: "zoomCoordinate",
    value: function zoomCoordinate(dimension, physicalCenter, factor, minScale, maxScale) {
      var scale = this.scales[this.sourceCoordinate[dimension]];
      var currentScale = scale.scaleFactor;
      var newScale = Math.min(maxScale || Number.MAX_VALUE, Math.max(currentScale * factor, minScale || 0));
      var targetCenter = scale.target2Source(physicalCenter);
      scale.zoomAroundSource(targetCenter, newScale);
      return this;
    }
  }, {
    key: "zoomAroundTarget",
    value: function zoomAroundTarget(targetCenter, factor, minScale, maxScale) {
      var _this6 = this;

      var currentScale = this.scales['x'].scaleFactor;
      var newScale = Math.min(maxScale || Number.MAX_VALUE, Math.max(currentScale * factor, minScale || 0));
      var sourceCenter = this.transformBack(targetCenter);
      ['x', 'y'].forEach(function (axis) {
        var dimension = _this6.sourceCoordinate[axis];

        _this6.scales[dimension].zoomAroundSource(sourceCenter[dimension], newScale);
      });
      return this;
    }
  }, {
    key: "moveTargetWindowBy",
    value: function moveTargetWindowBy(delta) {
      var _this7 = this;

      ['x', 'y'].forEach(function (axis) {
        var dimension = _this7.sourceCoordinate[axis];

        if (delta[axis] != null) {
          _this7.scales[dimension].moveTargetBy(delta[axis]);
        }
      });
      return this;
    }
  }, {
    key: "getTransformString",
    value: function getTransformString() {
      var dx = -this.scales.x.offset * this.scales.x.scaleFactor;
      var dy = -this.scales.y.offset * this.scales.y.scaleFactor;
      return "translate(".concat(dx, "px, ").concat(dy, "px) scale(").concat(this.scales.x.scaleFactor, ")");
    }
  }]);

  return LinearTransformation;
}(CoordinateTransformation_1.default);

exports.default = LinearTransformation;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(17);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scale = exports.toInterval = void 0;

var isInterval = function isInterval(object) {
  return object['min'] != null && object['max'] != null;
};

var toInterval = function toInterval(object) {
  if (isInterval(object)) {
    return object;
  }

  return {
    min: 0,
    max: object
  };
};

exports.toInterval = toInterval;

var Scale = /*#__PURE__*/function () {
  function Scale() {
    _classCallCheck(this, Scale);

    this.offset = 0;
    this.scaleFactor = 1;
  }
  /**
   *
   * @param {number} scaleFactor the ratio of target per source
   * @param {number} targetStart The source coordinate for which the target coordinate is 0
   * @return {this}
   */


  _createClass(Scale, [{
    key: "update",
    value: function update(scaleFactor, targetStart) {
      this.offset = targetStart;
      this.scaleFactor = scaleFactor;
      return this;
    }
  }, {
    key: "source2Target",
    value: function source2Target(sourceCoord) {
      return (sourceCoord - this.offset) * this.scaleFactor;
    }
  }, {
    key: "target2Source",
    value: function target2Source(targetCoord) {
      return targetCoord / this.scaleFactor + this.offset;
    }
    /**
     * updates the scale and offset so that the specified source range is mapped to the target range.
     * If a number is specified as the target range, it is interpreted as the width of an interval starting at 0.
     * @param {Interval} sourceRange
     * @param {Interval | number} targetRange
     */

  }, {
    key: "fit",
    value: function fit(sourceRange, targetRange) {
      var targetDistance = sourceRange.max - sourceRange.min;
      var interval = exports.toInterval(targetRange);
      var sourceDistance = interval.max - interval.min;
      var sourceOffset = interval.min;
      var scale = sourceDistance / targetDistance;
      this.update(scale, sourceRange.min - (sourceOffset || 0) / scale);
    }
    /**
     * adjusts scale factor and offset so that the target value for the specified source center does not change
     * @param {number} sourceCenter
     * @param {number} newScale
     */

  }, {
    key: "zoomAroundSource",
    value: function zoomAroundSource(sourceCenter, newScale) {
      this.offset = (sourceCenter * (newScale - this.scaleFactor) + this.offset * this.scaleFactor) / newScale;
      this.scaleFactor = newScale;
    }
    /**
     * moves the target range by the specified amount in target coordinates
     * @param {number} deltaTarget
     */

  }, {
    key: "moveTargetBy",
    value: function moveTargetBy(deltaTarget) {
      this.offset += deltaTarget / this.scaleFactor;
    }
  }]);

  return Scale;
}();

exports.Scale = Scale;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = require("@turf/bbox-clip");

/***/ })
/******/ ]);
//# sourceMappingURL=GeoJsonChoropleth.js.map