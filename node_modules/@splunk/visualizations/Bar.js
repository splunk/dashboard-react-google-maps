/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 136);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VizBehavior = void 0;
var VizBehavior;

(function (VizBehavior) {
  /**
   * Dynamic Options Behavior.
   * This allows visualization options to be powered by data
   *
   * **Example**
   *
   * sparklineValues: ">primary|seriesByIndex(0)"
   * would configure sparklineValues with an array of data points
   * coming from the first series in the primary datasource
   *
   */
  VizBehavior["DYNAMIC_OPTIONS"] = "dynamic-options";
  VizBehavior["EVENTS"] = "events";
  /**
   * Placeholder behavior: visualization will display a placeholder rather than fail if any of the `requiredProps` is
   * missing.
   * @type {string}
   */

  VizBehavior["PLACEHOLDER"] = "placeholder";
  VizBehavior["PAGE_AND_SORT"] = "page-and-sort";
})(VizBehavior = exports.VizBehavior || (exports.VizBehavior = {}));

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/Message");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generatePrecisionValues = exports.getInitialPreset = exports.isDynamicOption = exports.enhanceOptionsSchemaWithDynamicOptions = exports.enhanceConfig = void 0;

var lodash_1 = __webpack_require__(2);

var schemaUtils_1 = __webpack_require__(14);

var VizBehavior_1 = __webpack_require__(5);

var dynamicOptionsDSLType = {
  type: 'string',
  pattern: schemaUtils_1.DYNAMIC_OPTIONS_DSL_PATTERN
};
/**
 * Helper function to extend an options schema with dynamic options DSL
 * @param optionsSchema a visualization's options schema
 * @returns an updated options schema that additionally allows strings starting with > for each option
 */

function enhanceOptionsSchemaWithDynamicOptions(optionsSchema) {
  var enhancedOptionsSchema = {};
  Object.keys(optionsSchema).forEach(function (key) {
    var _a = optionsSchema[key],
        title = _a.title,
        description = _a.description,
        readOnly = _a.readOnly,
        writeOnly = _a.writeOnly,
        examples = _a.examples,
        defaultValue = _a.default,
        type = _a.type,
        properties = _a.properties,
        patternProperties = _a.patternProperties,
        remainingSchemaEntry = __rest(_a, ["title", "description", "readOnly", "writeOnly", "examples", "default", "type", "properties", "patternProperties"]);

    var annotations = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, title !== undefined && {
      title: title
    }), description !== undefined && {
      description: description
    }), readOnly !== undefined && {
      readOnly: readOnly
    }), writeOnly !== undefined && {
      writeOnly: writeOnly
    }), examples !== undefined && {
      examples: examples
    }), defaultValue !== undefined && {
      default: defaultValue
    });

    if (type === 'object') {
      enhancedOptionsSchema[key] = Object.assign(Object.assign(Object.assign(Object.assign({}, remainingSchemaEntry), annotations), {
        type: type
      }), properties && {
        properties: enhanceOptionsSchemaWithDynamicOptions(properties)
      });

      if (patternProperties) {
        var enhancedPatternProperties = {};
        Object.keys(patternProperties).forEach(function (key) {
          enhancedPatternProperties = Object.assign(Object.assign({}, enhancedPatternProperties), enhanceOptionsSchemaWithDynamicOptions(_defineProperty({}, key, patternProperties[key])));
        });
        enhancedOptionsSchema[key].patternProperties = enhancedPatternProperties;
      }
    } else {
      enhancedOptionsSchema[key] = Object.assign(Object.assign({}, annotations), {
        anyOf: [Object.assign(Object.assign({}, type !== undefined && {
          type: type
        }), remainingSchemaEntry), dynamicOptionsDSLType]
      });
    }
  });
  return enhancedOptionsSchema;
}

exports.enhanceOptionsSchemaWithDynamicOptions = enhanceOptionsSchemaWithDynamicOptions;
/**
 * Helper function to enhance a Visualization Config as needed based on behaviors specified in supports block
 * @param vizConfig a Visualization Config
 * @returns an enhanced Visualization Config containing updated config entries based on behaviors it supports
 */

function enhanceConfig(vizConfig) {
  var enhancedConfig = vizConfig;

  if (vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.DYNAMIC_OPTIONS) !== -1) {
    enhancedConfig.optionsSchema = enhanceOptionsSchemaWithDynamicOptions(vizConfig.optionsSchema);
  }

  return enhancedConfig;
}

exports.enhanceConfig = enhanceConfig;

function isDynamicOption(option) {
  return option && typeof option === 'string' && option.trim().startsWith('>') || false;
}

exports.isDynamicOption = isDynamicOption; // private helpers to improve readability of getInitialPreset
// this shouldn't be tested since this util isn't something that we expect to use outside of getInitialPreset

/**
 * this checks to make sure that all values within vizContext are compatible with the given preset's context to determine the initialPreset
 * if a preset has explicitly specified a key as being undefined, the vizContext must also has that key as undefined, or else this CANNOT be the initialPreset
 * the inverse is true; if a preset has key is NOT undefined, it must also be NOT undefined in the corresponding vizContext
 * the internal config contents are irrelevant (as the user could customize them in source), just as long as the presence of `undefined`s match up
 *
 * Since the presetConfigs have explicit undefined keys to override the existing config, we need to explicitly check the undefined values
 */

function hasCompatibleContexts(vizContext, presetContext) {
  var presetContextKeys = Object.keys(presetContext);
  return presetContextKeys.every(function (contextKey) {
    return presetContext[contextKey] === undefined && vizContext[contextKey] === undefined || presetContext[contextKey] !== undefined && vizContext[contextKey] !== undefined;
  });
}
/**
 * Checks to make sure that dynamic (non-dynamic) options in a given preset are also dynamic (non-dynamic) in the vizOptions
 */


function hasCompatibleOptions(vizOptions, presetOptions) {
  var presetOptionKeys = Object.keys(presetOptions);
  return presetOptionKeys.every(function (optionKey) {
    return isDynamicOption(presetOptions[optionKey]) === isDynamicOption(vizOptions[optionKey]);
  });
}
/**
 * Evaluates whether there is an initialPreset that fits the current state of vizContext + vizOptions
 * This function ignores extraneous vizOptions or vizContext keys, as they could be outside the scope of what the preset is intended to configure
 *
 * @param {Object} vizContext - the current vizContext definition
 * @param {Object} vizOptions - the current vizOptions definition
 * @param {PresetEntry[]} presets - the list of presets, one of which can be considered an initialPreset
 */


function getInitialPreset(vizContext, vizOptions, presets) {
  return presets.find(function (preset) {
    var presetContext = lodash_1.get(preset, ['value', 'context'], {});
    var presetOptions = lodash_1.get(preset, ['value', 'options'], {});
    var presetContextKeys = Object.keys(presetContext);
    var presetOptionKeys = Object.keys(presetOptions); // all presets have to explicitly specify which options to reset (i.e. need explicitly undefined keys)
    // if not, then the preset is invalid in config.ts

    if (presetContextKeys.length === 0 || presetOptionKeys.length === 0) return false;
    return hasCompatibleContexts(vizContext, presetContext) && hasCompatibleOptions(vizOptions, presetOptions);
  });
}

exports.getInitialPreset = getInitialPreset;
/**
 * generates number precision values for a Select editor
 *
 * @param {Number} numPrecisionValues - number of integer precision values to generate
 * @returns {{ label: string; value; string  }[]} array of { label, value } tuples
 */

function generatePrecisionValues(numPrecisionValues) {
  return lodash_1.range(0, numPrecisionValues + 1).map(function (i) {
    return {
      label: "".concat(i, " (0").concat(i > 0 ? '.' : '').concat('0'.repeat(i), ")"),
      value: i
    };
  });
}

exports.generatePrecisionValues = generatePrecisionValues;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorUtils");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var SizeAwareWrapper_1 = __webpack_require__(18);

var style_1 = __webpack_require__(13);

var colorUtils_1 = __webpack_require__(10);

var Item = styled_components_1.default.div.attrs(function (_ref) {
  var width = _ref.width;
  return {
    style: {
      width: style_1.toPx(width)
    }
  };
}).withConfig({
  displayName: "FixedSizeContainer__Item",
  componentId: "sc-1yhgpod-0"
})(["position:relative;background-color:", "};"], function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
}); // Use `.attrs()` for highly dynamic styles. Ref: https://github.com/styled-components/styled-components/issues/134#issuecomment-312415291

var FixSizeItem = styled_components_1.default.div.attrs(function (_ref2) {
  var width = _ref2.width,
      height = _ref2.height;
  return {
    style: Object.assign(Object.assign({}, width && {
      width: style_1.toPx(width)
    }), height && {
      height: style_1.toPx(height)
    })
  };
}).withConfig({
  displayName: "FixedSizeContainer__FixSizeItem",
  componentId: "sc-1yhgpod-1"
})(["position:relative;flex-direction:column;flex:1;display:flex;background-color:", "};"], function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
});
var ItemContent = styled_components_1.default.div.withConfig({
  displayName: "FixedSizeContainer__ItemContent",
  componentId: "sc-1yhgpod-2"
})(["position:relative;min-height:100px;width:100%;"]);
var FixSizeItemContent = styled_components_1.default.div.withConfig({
  displayName: "FixedSizeContainer__FixSizeItemContent",
  componentId: "sc-1yhgpod-3"
})(["min-height:0px;flex:1;position:relative;box-sizing:border-box;"]);

var withFixedSizeContainer = function withFixedSizeContainer(Viz) {
  var FixedSizeContainer = function FixedSizeContainer(props) {
    var width = props.width,
        height = props.height,
        backgroundColor = props.backgroundColor;

    if (!height) {
      return React.createElement(Item, {
        "data-test": "item",
        width: width,
        backgroundColor: backgroundColor
      }, React.createElement(ItemContent, null, React.createElement(Viz, Object.assign({}, props))));
    }

    return React.createElement(FixSizeItem, {
      "data-test": "fix-size-item",
      width: width,
      height: height,
      backgroundColor: backgroundColor
    }, React.createElement(FixSizeItemContent, null, React.createElement(SizeAwareWrapper_1.default, null, function (_ref3) {
      var newWidth = _ref3.width,
          newHeight = _ref3.height;
      return React.createElement(Viz, Object.assign({}, props, {
        width: newWidth,
        height: newHeight
      }));
    })));
  };

  FixedSizeContainer.displayName = 'withFixedSizeContainer';
  return FixedSizeContainer;
};

exports.default = withFixedSizeContainer;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extendStaticWrapperProps = void 0;
/**
 * @method extendStaticWrapperProps
 * @param {Object} props
 * @param {DashboardVizType} props.Wrapper
 * @param {DashboardVizType} props.Visualization
 */

var extendStaticWrapperProps = function extendStaticWrapperProps(_ref) {
  var Wrapper = _ref.Wrapper,
      Visualization = _ref.Visualization;
  var extendProperties = ['propTypes', 'defaultProps', 'config'];
  extendProperties.forEach(function (prop) {
    if (Visualization[prop]) {
      Wrapper[prop] = Visualization[prop];
    }
  });
};

exports.extendStaticWrapperProps = extendStaticWrapperProps;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/style");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/schemaUtils");

/***/ }),
/* 15 */,
/* 16 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/propUtils");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SizeAwareWrapper");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/variables");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/pick");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSortingParams = exports.SortParamsPropTypes = void 0;

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var DataSource_1 = __webpack_require__(32);

exports.SortParamsPropTypes = T.shape({
  currentSortKey: T.string,
  currentSortDir: T.oneOf(DataSource_1.validSortDirs),
  onSort: T.func
});

var getSortingParams = function getSortingParams(_ref) {
  var requestParams = _ref.requestParams,
      onRequestParamsChange = _ref.onRequestParamsChange;
  var currentSortKey;
  var currentSortDir;
  var nextSortDirMap = {
    asc: 'desc',
    desc: 'asc',
    none: 'asc'
  };
  var onSort;

  if (lodash_1.isFunction(onRequestParamsChange)) {
    if (requestParams && lodash_1.has(requestParams, 'sort')) {
      currentSortKey = Object.keys(requestParams.sort).shift();
      currentSortDir = requestParams.sort[currentSortKey];
    } // undid memoization since there is a dependency on requestParams, which is a deeply nested object


    onSort = function onSort(e, _ref2) {
      var sortKey = _ref2.sortKey,
          sortDir = _ref2.sortDir;

      if (typeof sortKey === 'string') {
        var nextSortDir = lodash_1.has(nextSortDirMap, sortDir) ? nextSortDirMap[sortDir] : 'none';
        onRequestParamsChange(Object.assign(Object.assign({}, requestParams), {
          offset: 0,
          sort: _defineProperty({}, sortKey, nextSortDir)
        }));
      } else {
        onRequestParamsChange(requestParams);
      }
    };
  }

  return {
    currentSortKey: currentSortKey,
    currentSortDir: currentSortDir,
    onSort: onSort
  };
};

exports.getSortingParams = getSortingParams;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPaginationParams = exports.PaginatorParamsPropTypes = void 0;

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

exports.PaginatorParamsPropTypes = T.shape({
  isPaging: T.bool,
  current: T.number,
  totalPages: T.number,
  onChange: T.func
});

var getPaginationParams = function getPaginationParams(_ref) {
  var requestParams = _ref.requestParams,
      meta = _ref.meta,
      onRequestParamsChange = _ref.onRequestParamsChange;
  var totalCount = meta && meta.totalCount || 0;
  var offset = requestParams && requestParams.offset || 0;
  var count = requestParams && requestParams.count;
  var totalPages = typeof count === 'number' && count > 0 ? Math.ceil(totalCount / count) : 0;
  var current = typeof count === 'number' && count > 0 ? Math.floor(offset / count) + 1 : 0;
  var isPaging = totalPages > 1 && lodash_1.isFunction(onRequestParamsChange);

  var onChangeHandler = function onChangeHandler(e, _ref2) {
    var page = _ref2.page,
        countArg = _ref2.count;
    var newParams = lodash_1.cloneDeep(requestParams);

    if (typeof countArg === 'number') {
      newParams.count = countArg;
      newParams.offset = 0;
    }

    var pageCount = typeof newParams.count === 'number' ? newParams.count : 10;

    if (typeof page === 'number' && page > 0) {
      newParams.count = pageCount;
      newParams.offset = (page - 1) * pageCount;
    }

    onRequestParamsChange(newParams);
  };

  return {
    isPaging: isPaging,
    current: current,
    totalPages: totalPages,
    onChange: lodash_1.isFunction(onRequestParamsChange) ? onChangeHandler : lodash_1.noop
  };
};

exports.getPaginationParams = getPaginationParams;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldShowIconPlaceholder = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var i18n_1 = __webpack_require__(3);

var Message_1 = __webpack_require__(7);

var FixedSizeContainer_1 = __webpack_require__(11);
/**
 * @method shouldShowIconPlaceholder
 * @param {object} dataSources
 * @param {boolean} loading
 * @returns {boolean}
 */


var shouldShowIconPlaceholder = function shouldShowIconPlaceholder(dataSources) {
  var loading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var data = lodash_1.get(dataSources, 'primary.data.columns[0]', undefined);
  var noData = data === undefined;
  var fields = lodash_1.get(dataSources, 'primary.data.fields[0]', undefined);
  var noFields = fields === undefined;
  return loading || noData || noFields;
};

exports.shouldShowIconPlaceholder = shouldShowIconPlaceholder;
var propTypes = {
  icon: T.func,
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  backgroundColor: T.string
};
/**
 * @method IconPlaceholder
 * @param {IconPlaceholderProps} props
 * @returns {React.ReactElement}
 */

var IconPlaceholder = function IconPlaceholder(props) {
  var width = props.width,
      height = props.height,
      icon = props.icon;

  if (icon) {
    return React.createElement(icon, {
      style: {
        left: '50%',
        top: '50%',
        color: 'grey',
        position: 'absolute',
        transform: 'translate(-50%, -50%)'
      },
      width: '50%',
      height: '50%'
    });
  }

  return React.createElement(Message_1.default, {
    width: width,
    height: height,
    level: "warning",
    message: i18n_1._('No DataSource Connected')
  });
};

IconPlaceholder.propTypes = propTypes;
IconPlaceholder.defaultProps = {
  width: '100%',
  height: 250
};
exports.default = FixedSizeContainer_1.default(IconPlaceholder);

/***/ }),
/* 24 */,
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VizCategory = void 0;
var VizCategory;

(function (VizCategory) {
  VizCategory["SINGLE_VALUE"] = "Single Value";
  VizCategory["TRENDS"] = "Trends";
  VizCategory["COMPARISONS"] = "Comparisons";
  VizCategory["TABLE"] = "Table";
  VizCategory["GAUGE"] = "Gauge";
  VizCategory["DISTRIBUTIONS"] = "Distributions";
  VizCategory["CHOROPLETH"] = "Choropleth Maps";
  VizCategory["SHAPES"] = "Shapes";
  VizCategory["MISC"] = "misc";
  VizCategory["FLOW"] = "Flow";
})(VizCategory = exports.VizCategory || (exports.VizCategory = {}));

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);

var getSettingsFromThemedProps_1 = __webpack_require__(27);

var Options_1 = __webpack_require__(28);

var SanitizeProps_1 = __webpack_require__(29);

var styled_components_1 = __webpack_require__(4);

var SplunkVisualization_1 = __webpack_require__(30);

var VizBehavior_1 = __webpack_require__(5);

var getSorting_1 = __webpack_require__(21);

var getPagination_1 = __webpack_require__(22);

var useDeepMemo_1 = __webpack_require__(33);

var JSONSchemaUtils_1 = __webpack_require__(34);

var MissingPropsMessage_1 = __webpack_require__(35);

var withEditModeCover_1 = __webpack_require__(36);

var withPlaceholder_1 = __webpack_require__(37);
/**
 * hoc that wraps a pure react visualization in a Dashboard visualization
 * @param {DashboardVizOpts} opts
 * @returns {HOC}
 */


var withDashboardViz = function withDashboardViz(opts) {
  var ReactViz = opts.ReactViz,
      vizConfig = opts.vizConfig,
      _opts$computeVizProps = opts.computeVizProps,
      computeVizProps = _opts$computeVizProps === void 0 ? function () {} : _opts$computeVizProps,
      useIconPlaceholder = opts.useIconPlaceholder; // sanitizing props before sending them to reactviz.

  var SanitizedReactViz = SanitizeProps_1.withSanitizedProps(ReactViz);
  var defaultOptions = JSONSchemaUtils_1.pickFieldFromJSONSchema(vizConfig.optionsSchema, 'default');

  var DashboardViz = function DashboardViz(props) {
    var mode = props.mode,
        hasEventHandlers = props.hasEventHandlers,
        dataSources = props.dataSources,
        options = props.options,
        _props$context = props.context,
        context = _props$context === void 0 ? {} : _props$context,
        width = props.width,
        height = props.height,
        onComputedProps = props.onComputedProps,
        onEventTrigger = props.onEventTrigger,
        theme = props.theme,
        onRequestParamsChange = props.onRequestParamsChange;

    var themeFunc = function themeFunc(themeVar) {
      var _a, _b;

      return (_b = (_a = vizConfig.themes)[themeVar]) === null || _b === void 0 ? void 0 : _b.call(_a, props);
    };

    var bgColorFromTheme = themeFunc('defaultBackgroundColor');

    var _getSettingsFromTheme = getSettingsFromThemedProps_1.default({
      theme: theme
    }),
        currentThemeFamily = _getSettingsFromTheme.family,
        currentThemeColorScheme = _getSettingsFromTheme.colorScheme,
        currentThemeDensity = _getSettingsFromTheme.density;

    var evaluatedOptions = {}; // evaluatedOptions need to be initialized as an empty object

    evaluatedOptions = useDeepMemo_1.useDeepMemo(function () {
      try {
        return Options_1.Options.evaluate({
          context: lodash_1.defaultsDeep({}, context, vizConfig.defaultContext),
          options: lodash_1.defaultsDeep({}, options, defaultOptions)
        }, dataSources, themeFunc);
      } catch (e) {
        console.error("unexpected error evaluating options:  + ".concat(e.message));
        return {};
      }
    }, [currentThemeFamily, currentThemeColorScheme, currentThemeDensity, options, context, dataSources]); // useEffect hook needs to be initialized before any early returns
    // this is in accordance with the order of hook calls being the same on each render https://reactjs.org/docs/hooks-rules.html#explanation

    React.useEffect(function () {
      onComputedProps(evaluatedOptions);
    }); // present warning message if any required props are missing

    var _vizConfig$requiredPr = vizConfig.requiredProps,
        requiredProps = _vizConfig$requiredPr === void 0 ? [] : _vizConfig$requiredPr,
        supports = vizConfig.supports;
    var missing = MissingPropsMessage_1.missingKeys(requiredProps, evaluatedOptions);

    if (missing.length > 0 && supports.includes(VizBehavior_1.VizBehavior.PLACEHOLDER)) {
      return React.createElement(MissingPropsMessage_1.default, {
        "data-test": "missing-props-message",
        width: width,
        height: height,
        missingProps: missing,
        backgroundColor: bgColorFromTheme
      });
    } // events


    var eventCallbackProps = {};

    if (hasEventHandlers && mode === 'view' && vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.EVENTS) > -1) {
      var supportedEvents = vizConfig.events;
      Object.keys(supportedEvents).forEach(function (eventName) {
        var eventCallbackPropName = lodash_1.camelCase("on.".concat(eventName));
        eventCallbackProps[eventCallbackPropName] = null; // todo: refactor single value and single value icon to send payload from viz
        // then remove these lines

        var payloadKeys = supportedEvents[eventName].payloadKeys;
        var payload = {};

        if (Array.isArray(payloadKeys) && payloadKeys.length) {
          payloadKeys.forEach(function (p) {
            return payload[p] = evaluatedOptions[p];
          });
        }

        eventCallbackProps[eventCallbackPropName] = function (ev) {
          if (ev && ev.payload) {
            payload = ev.payload;
          }

          return onEventTrigger({
            originalEvent: ev,
            payload: payload,
            type: eventName
          });
        };
      });
    } // compute pure viz props which are not from options


    var computedVizProps = computeVizProps(Object.assign(Object.assign(Object.assign(Object.assign({}, props), evaluatedOptions), eventCallbackProps), {
      themeFunc: themeFunc
    }));
    /**
     * PAGE_AND_SORT behavior
     *
     * Some visualizations, like table, requires metadata about the datasource,
     * like total number of results, current count, offset, and sort, for rendering
     * paginator and sorting direction. In this approach, the visualization
     * allow users to set 'paginateDataSourceKey' to select which datasource
     * should the visualization extract the metadata from. It defaults to 'primary' datasource.
     * The visualization config should set the PAGE_AND_SORT behavior to receive
     * 'requestParams', 'meta' and onRequestParams callback as props.
     *
     * In future, we could automatically detect which all datasources are being used
     * and bind those magically to pagination/sorting behavior.
     */

    var dataSourceMetadata = {};
    var OptionKey = 'paginateDataSourceKey';
    var paginateDataSourceKey = lodash_1.has(evaluatedOptions, OptionKey) && evaluatedOptions[OptionKey] || 'primary';

    if (vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.PAGE_AND_SORT) > -1 && lodash_1.has(dataSources, paginateDataSourceKey)) {
      var requestParams = lodash_1.get(dataSources, [paginateDataSourceKey, 'requestParams'], {});
      var meta = lodash_1.get(dataSources, [paginateDataSourceKey, 'meta'], {});

      var handleRequestParamsChange = function handleRequestParamsChange(payload) {
        return onRequestParamsChange(paginateDataSourceKey, payload);
      };

      var sortParams = getSorting_1.getSortingParams({
        requestParams: requestParams,
        meta: meta,
        onRequestParamsChange: handleRequestParamsChange
      });
      var paginatorParams = getPagination_1.getPaginationParams({
        requestParams: requestParams,
        meta: meta,
        onRequestParamsChange: handleRequestParamsChange
      });
      dataSourceMetadata = {
        sortParams: sortParams,
        paginatorParams: paginatorParams
      };
    }

    return React.createElement(SanitizedReactViz, Object.assign({
      mode: mode,
      width: width,
      height: height
    }, evaluatedOptions, computedVizProps, eventCallbackProps, dataSourceMetadata));
  };

  DashboardViz.propTypes = Object.assign(Object.assign({}, SplunkVisualization_1.default.propTypes), ReactViz.propTypes);
  DashboardViz.defaultProps = Object.assign(Object.assign(Object.assign({}, SplunkVisualization_1.default.defaultProps), ReactViz.defaultProps), {
    // using withTheme requires component to receive theme prop. In case the consumer did not provide ThemeProvider, a default empty object will prevent warnings.
    theme: {}
  }); // attach viz config

  DashboardViz.config = vizConfig; // @ts-ignore: TODO fix sc upgrade TS issues

  return styled_components_1.withTheme(withPlaceholder_1.default(withEditModeCover_1.default(DashboardViz), useIconPlaceholder));
};

exports.default = withDashboardViz;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/getSettingsFromThemedProps");

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-encoding/Options");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SanitizeProps");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(9);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INITIAL_HEIGHT = exports.INITIAL_WIDTH = void 0;
/* eslint-disable react/no-unused-prop-types,react/prefer-stateless-function */

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var VizActionHandler_1 = __webpack_require__(31); // this is identical to the initial height and width we use in BaseVisualization in dashboard-visualizations


exports.INITIAL_WIDTH = 250;
exports.INITIAL_HEIGHT = 250;
/**
 * A Splunk visualization
 */

var SplunkVisualization = function SplunkVisualization() {
  _classCallCheck(this, SplunkVisualization);
};

SplunkVisualization.propTypes = {
  /**
   * display mode
   */
  mode: T.oneOf(['view', 'edit', 'export']).isRequired,

  /**
   * width in pixel or string, defaults to 100%
   */
  width: T.oneOfType([T.string, T.number]).isRequired,

  /**
   * height in pixel or string
   */
  height: T.oneOfType([T.string, T.number]).isRequired,

  /**
   * visualization context used for dynamic option evaluation
   */
  context: T.object,

  /**
   * visualization formatting options
   */
  options: T.object,

  /**
   * A callback to update formatting options
   */
  onOptionsChange: T.func,

  /**
   * datasource state which include data and request params, object key indicate the datasource type.
   */
  dataSources: T.objectOf(T.shape({
    /**
     * current request params
     */
    requestParams: T.object,

    /**
     * current dataset
     */
    data: T.shape({
      fields: T.array,
      columns: T.array
    }),

    /**
     * error
     */
    error: T.shape({
      level: T.string,
      message: T.string
    }),

    /**
     * meta data that came with the dataset
     */
    meta: T.object
  })),

  /**
   * A callback to trigger event
   */
  onEventTrigger: T.func,

  /**
   * Inform viz if there are handlers listening to events
   */
  hasEventHandlers: T.bool,

  /**
   * A callback to communicate computed props to a consumer
   */
  onComputedProps: T.func,

  /**
   * A callback to obtain visualization api
   */
  vizActionHandlerRef: T.func,
  loading: T.bool,
  theme: T.object,

  /**
   * A callback to request new data with updated request params
   */
  onRequestParamsChange: T.func
};
/**
 *
 */

SplunkVisualization.defaultProps = {
  // BaseVisualization in dashboard-visualizations uses 100% for width but 250 for height
  width: '100%',
  height: exports.INITIAL_HEIGHT,
  dataSources: {},
  onEventTrigger: function onEventTrigger() {
    return {};
  },
  mode: 'view',
  hasEventHandlers: false,
  options: {},
  context: {},
  onOptionsChange: function onOptionsChange() {
    return {};
  },
  vizActionHandlerRef: function vizActionHandlerRef() {
    return new VizActionHandler_1.DefaultVizActionHandler();
  },
  onComputedProps: function onComputedProps() {
    return {};
  },
  loading: false,
  onRequestParamsChange: lodash_1.noop
};
exports.default = SplunkVisualization;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(9);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultVizActionHandler = void 0;

var DefaultVizActionHandler = /*#__PURE__*/function () {
  function DefaultVizActionHandler() {
    _classCallCheck(this, DefaultVizActionHandler);
  }

  _createClass(DefaultVizActionHandler, [{
    key: "focus",
    value: function focus() {//noop
    }
  }, {
    key: "snapshot",
    value: function snapshot() {
      return null; //noop
    }
  }]);

  return DefaultVizActionHandler;
}();

exports.DefaultVizActionHandler = DefaultVizActionHandler;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validSortDirs = void 0;
exports.validSortDirs = ['asc', 'desc', 'none'];

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDeepMemo = void 0;

var react_1 = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);
/**
 * This hook evaluates and stores the result of a passed function and only
 * re-evaluates the function when passed dependencies change.
 *
 * It is different from the internal React useMemo in the following aspects:
 * - it only stores the last evaluated result
 * - it uses a deep equality check to determine if dependencies have changed
 *
 * Inspired by apollo-client's useDeepMemo
 *
 * @param fn the function to be executed and
 * @param dependencies an array of dependencies
 */


var useDeepMemo = function useDeepMemo(fn, dependencies) {
  var ref = react_1.useRef();

  if (!ref.current || !lodash_1.isEqual(dependencies, ref.current.dependencies)) {
    ref.current = {
      dependencies: dependencies,
      value: fn()
    };
  }

  return ref.current.value;
};

exports.useDeepMemo = useDeepMemo;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickFieldFromJSONSchema = void 0;

var lodash_1 = __webpack_require__(2);

var pickFieldFromJSONSchema = function pickFieldFromJSONSchema(optionsSchema) {
  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  return Object.keys(optionsSchema).reduce(function (accum, k) {
    if (lodash_1.has(optionsSchema[k], fieldName)) {
      accum[k] = optionsSchema[k][fieldName];
    } else if (lodash_1.get(optionsSchema, [k, 'type']) === 'object' && lodash_1.has(optionsSchema[k], 'properties')) {
      var nestedSchema = exports.pickFieldFromJSONSchema(optionsSchema[k].properties, fieldName);

      if (!lodash_1.isEmpty(nestedSchema)) {
        accum[k] = nestedSchema;
      }
    }

    return accum;
  }, {});
};

exports.pickFieldFromJSONSchema = pickFieldFromJSONSchema;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MissingPropsMessage = exports.missingKeys = exports.isMissing = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var i18n_1 = __webpack_require__(3);

var Message_1 = __webpack_require__(7);

var FixedSizeContainer_1 = __webpack_require__(11);
/**
 * @method isMissing
 * @param {any} v
 * @returns {boolean} true if the input value === null or undefined
 */


var isMissing = function isMissing(v) {
  return v === null || v === undefined;
};

exports.isMissing = isMissing;
/**
 * @method misskingKeys
 * @param {string[]} keys
 * @param {object} target
 * @returns {string[]} the keys of missing required props
 */

var missingKeys = function missingKeys(keys, target) {
  return keys.filter(function (k) {
    return exports.isMissing(target[k]);
  });
};

exports.missingKeys = missingKeys;
var propTypes = {
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  backgroundColor: T.string,
  missingProps: T.arrayOf(T.string)
};
/**
 * @method MissingPropsMessage
 * @param {MissingPropsProps} props
 * @returns {React.ReactElement}
 */

var MissingPropsMessage = function MissingPropsMessage(props) {
  var width = props.width,
      height = props.height,
      missingProps = props.missingProps;
  return React.createElement(Message_1.default, {
    "data-test": "message",
    width: width,
    height: height,
    message: i18n_1._("Missing property: ".concat(missingProps.join(', ')))
  });
};

exports.MissingPropsMessage = MissingPropsMessage;
exports.MissingPropsMessage.propTypes = propTypes;
exports.MissingPropsMessage.defaultProps = {
  width: '100%',
  height: 250
};
exports.default = FixedSizeContainer_1.default(exports.MissingPropsMessage);

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var hocUtils_1 = __webpack_require__(12);

var Cover = styled_components_1.default.div.withConfig({
  displayName: "withEditModeCover__Cover",
  componentId: "sc-1gsbnxb-0"
})(["position:absolute;left:0;right:0;top:0;bottom:0;"]);
var Blocker = styled_components_1.default.div.withConfig({
  displayName: "withEditModeCover__Blocker",
  componentId: "sc-1gsbnxb-1"
})(["position:relative;width:100%;height:100%;"]);
/**
 * HOC that renders a cover layer in edit mode
 * @method withEditModeCover
 * @param {ExtendedDashViz} Visualization
 * @returns {ExtendedDashViz} Wrapper
 */

var withEditModeCover = function withEditModeCover(Visualization) {
  var Wrapper = function Wrapper(props) {
    var mode = props.mode;
    return React.createElement(Blocker, null, React.createElement(Visualization, Object.assign({}, props)), mode === 'edit' && React.createElement(Cover, {
      "data-test": "edit-mode-cover"
    }));
  };

  hocUtils_1.extendStaticWrapperProps({
    Wrapper: Wrapper,
    Visualization: Visualization
  });
  return Wrapper;
};

exports.default = withEditModeCover;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var colorUtils_1 = __webpack_require__(10);

var IconPlaceholder_1 = __webpack_require__(23);

var VizBehavior_1 = __webpack_require__(5);

var hocUtils_1 = __webpack_require__(12);

var withPlaceholder = function withPlaceholder(Visualization) {
  var useIconPlaceholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IconPlaceholder_1.shouldShowIconPlaceholder;
  var config = Visualization.config;
  var themes = config.themes;

  var Wrapper = function Wrapper(props) {
    var _a;

    var dataSources = props.dataSources,
        loading = props.loading,
        options = props.options,
        height = props.height,
        width = props.width;
    var showPlaceholder = useIconPlaceholder(dataSources, loading, options);
    var bgColorFromTheme = colorUtils_1.isColor(options === null || options === void 0 ? void 0 : options.backgroundColor) ? options === null || options === void 0 ? void 0 : options.backgroundColor : (_a = themes === null || themes === void 0 ? void 0 : themes.defaultBackgroundColor) === null || _a === void 0 ? void 0 : _a.call(themes, props);

    if (config.supports.includes(VizBehavior_1.VizBehavior.PLACEHOLDER) && showPlaceholder) {
      return React.createElement(IconPlaceholder_1.default, {
        "data-test": "icon-placeholder",
        icon: config.icon,
        width: width,
        height: height,
        backgroundColor: bgColorFromTheme
      });
    }

    return React.createElement(Visualization, Object.assign({}, props));
  };

  hocUtils_1.extendStaticWrapperProps({
    Wrapper: Wrapper,
    Visualization: Visualization
  });
  return Wrapper;
};

exports.default = withPlaceholder;

/***/ }),
/* 38 */,
/* 39 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-icons");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-color-palettes");

/***/ }),
/* 42 */,
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(39);

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constructFieldsAndColumns = exports.toArrayForSeries = exports.isMultiSeriesData = exports.convertOverlayFields = exports.convertY2AxisOptions = exports.mapToValues = exports.truncateData = exports.getAnnotations = void 0;

var lodash_1 = __webpack_require__(2);
/**
 * Get formatted annotations
 * @method getAnnotations
 * @param {Object} options
 * @param {Array} options.annotationX
 * @param {Array} options.annotationColor
 * @param {Array} options.annotationLabel
 * @returns {Array}
 */


var getAnnotations = function getAnnotations(_ref) {
  var annotationX = _ref.annotationX,
      annotationColor = _ref.annotationColor,
      annotationLabel = _ref.annotationLabel;
  return annotationX && annotationX.length ? annotationX.map(function (timestamp, i) {
    return {
      color: annotationColor && annotationColor[i],
      label: annotationLabel && annotationLabel[i],
      time: timestamp
    };
  }) : [];
};

exports.getAnnotations = getAnnotations;
/**
 * Truncate the result set to given limit
 * @method truncateData
 * @param {Object} dataSet - dataSources.primary.data
 * @param {Number|String} truncationLimit - options['chart.resultTruncationLimit']
 * @returns {Object}
 */

var truncateData = function truncateData(dataSet, truncationLimit) {
  if (!dataSet) {
    return null;
  }

  var limit = parseInt(truncationLimit, 10);

  if (!limit || limit <= 0) {
    return dataSet;
  }

  var truncatedData = Object.assign({}, dataSet);
  truncatedData.columns = truncatedData.columns.map(function (columnData) {
    return columnData.slice(0, limit);
  });
  return truncatedData;
};

exports.truncateData = truncateData;
/**
 * Helper method to update the option values into the values that SC accepts
 * @method mapToValues
 * @param {Object} options
 * @returns {Object}
 */

var mapToValues = function mapToValues(optionValuesSCMapping) {
  return function (options) {
    var convertedOptions = Object.assign({}, options);
    Object.keys(optionValuesSCMapping).forEach(function (key) {
      if (lodash_1.has(options, key)) {
        var updatedValue = optionValuesSCMapping[key][options[key]];

        if (!lodash_1.isUndefined(updatedValue)) {
          convertedOptions[key] = updatedValue;
        }
      }
    });
    return convertedOptions;
  };
};

exports.mapToValues = mapToValues;
/**
 * Helper method to process options related to y2Fields
 * @method convertY2AxisOptions
 * @param {Object} originalOptions
 * @returns {Object}
 */

var convertY2AxisOptions = function convertY2AxisOptions(_a) {
  var y2Fields = _a.y2Fields,
      originalOptions = __rest(_a, ["y2Fields"]);

  var convertedOptions = Object.assign({}, originalOptions);

  if (y2Fields) {
    convertedOptions['axisY2.enabled'] = true;
    convertedOptions['axisY2.fields'] = lodash_1.isArray(y2Fields) ? y2Fields.filter(function (name) {
      return name;
    }).join(',') : y2Fields;
  }

  return convertedOptions;
};

exports.convertY2AxisOptions = convertY2AxisOptions;
/**
 * Helper method to format value for overlayFields
 * @method convertOverlayFields
 * @param {Object} originalOptions
 * @returns {Object}
 */

var convertOverlayFields = function convertOverlayFields(originalOptions) {
  var convertedOptions = Object.assign({}, originalOptions);
  var overlayFields = originalOptions.overlayFields;

  if (overlayFields) {
    convertedOptions.overlayFields = Array.isArray(overlayFields) ? overlayFields.filter(function (field) {
      return field;
    }).map(function (field) {
      return field.trim();
    }).join(',') : overlayFields;
  }

  return convertedOptions;
};

exports.convertOverlayFields = convertOverlayFields;
/**
 * checks whether data is multi series data
 * @param {array} data array
 * @return {Boolean}
 */

var isMultiSeriesData = function isMultiSeriesData(data) {
  return Array.isArray(data) && Array.isArray(data[0]);
};

exports.isMultiSeriesData = isMultiSeriesData;
/**
 * checks whether data is multi series data and returns value as array
 * @param {array} data array
 * @param {*} value to return as array
 * @return {array}
 */

var toArrayForSeries = function toArrayForSeries(data, value) {
  return exports.isMultiSeriesData(data) ? value : [value];
};

exports.toArrayForSeries = toArrayForSeries;

var constructFieldsAndColumns = function constructFieldsAndColumns(_ref2) {
  var x = _ref2.x,
      y = _ref2.y,
      xField = _ref2.xField,
      yFields = _ref2.yFields,
      y2 = _ref2.y2,
      y2Fields = _ref2.y2Fields;
  var columns = [x.map(String)].concat(_toConsumableArray(exports.toArrayForSeries(y, y).map(function (series) {
    return series.map(String);
  })));
  var yFieldsArray = exports.toArrayForSeries(y, yFields);
  var fields = [{
    name: xField
  }].concat(_toConsumableArray(yFieldsArray.map(function (field) {
    return {
      name: field
    };
  }))); // splunk-charting requires y2 to be part of columns
  // when y & y2 options are configured with different (mutually exclusive) series
  // y2 columns need to be added to columns

  if (y2Fields) {
    var y2FieldsArray = exports.toArrayForSeries(y2, y2Fields);
    var y2AsArray = exports.toArrayForSeries(y2, y2).map(function (series) {
      return series === null || series === void 0 ? void 0 : series.map(String);
    });
    y2FieldsArray.forEach(function (y2Field, index) {
      if (yFieldsArray.indexOf(y2Field) === -1 && y2AsArray[index]) {
        fields.push({
          name: y2Field
        });
        columns.push(y2AsArray[index]);
      }
    });
  }

  return {
    columns: columns,
    fields: fields
  };
};

exports.constructFieldsAndColumns = constructFieldsAndColumns;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = require("@splunk/charting-bundle");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var i18n_1 = __webpack_require__(3);

var background = function background(_ref) {
  var themes = _ref.themes,
      labelPosition = _ref.labelPosition;
  return [{
    label: i18n_1._('Background'),
    option: 'backgroundColor',
    editor: 'editor.color',
    editorProps: {
      labelPosition: labelPosition || 'top',
      themes: themes
    }
  }];
};

exports.default = background;

/***/ }),
/* 46 */,
/* 47 */,
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _this = this;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateRowPayload = exports.canUpdateInPlace = exports.changedOptions = exports.NO_INPLACE_PROPS = void 0;
/* eslint-disable react/no-unused-prop-types */

var lodash_1 = __webpack_require__(2);

var i18n_1 = __webpack_require__(3);

var visualization_color_palettes_1 = __webpack_require__(41);

var react_1 = __webpack_require__(1);

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var react_event_listener_1 = __webpack_require__(49);

__webpack_require__(50); // fixme, @splunk/charting should be refactor to use locale & timezone instead of i18n functions


var charting_bundle_1 = __webpack_require__(44);

var style_1 = __webpack_require__(13);

var styled_components_1 = __webpack_require__(4);

var Message_1 = __webpack_require__(7);

var useSplunkTheme_1 = __webpack_require__(51);

var themeUtils_1 = __webpack_require__(52);

var ChartingApi_1 = __webpack_require__(53);

exports.NO_INPLACE_PROPS = ['chart', 'chart.orientation', 'layout.splitSeries', 'chart.style', 'legend.placement'];

var changedOptions = function changedOptions(curOptions, nextOptions) {
  return Object.keys(curOptions).filter(function (key) {
    return !(key in nextOptions);
  }).concat(Object.keys(nextOptions).filter(function (key) {
    return !(key in curOptions) || curOptions[key] !== nextOptions[key];
  }));
};

exports.changedOptions = changedOptions;
charting_bundle_1.default.enableScaledEvents();

function usePrevious(value) {
  var ref = react_1.useRef();
  react_1.useEffect(function () {
    ref.current = value;
  });
  return ref.current;
}

var canUpdateInPlace = function canUpdateInPlace(curOptions, nextOptions) {
  // if either of the options are undefined
  // it cannot update in place.
  if (!curOptions || !nextOptions) {
    return false;
  }

  return !exports.NO_INPLACE_PROPS.some(function (p) {
    return curOptions[p] !== nextOptions[p];
  }) && !exports.changedOptions(curOptions, nextOptions).some(function (p) {
    return p.toLowerCase().endsWith('color');
  });
};

exports.canUpdateInPlace = canUpdateInPlace; // create 'row' payloads from 'rowContext' in the flattened format:
// row.<fieldname>.value

var updateRowPayload = function updateRowPayload(chartEventRowContext, payload) {
  Object.keys(chartEventRowContext || {}).forEach(function (key) {
    payload[key + '.value'] = chartEventRowContext[key];
  });
  return payload;
};

exports.updateRowPayload = updateRowPayload;
var VizChartEventType;

(function (VizChartEventType) {
  VizChartEventType["POINT_CLICK"] = "point.click";
  VizChartEventType["POINT_MOUSE_OUT"] = "point.mouseout";
  VizChartEventType["POINT_MOUSE_OVER"] = "point.mouseover";
  VizChartEventType["LEGEND_CLICK"] = "legend.click";
})(VizChartEventType || (VizChartEventType = {})); // @TODO(pwied): remove after HC upgrade to 8+
// .highcharts-a11y-proxy-container rule addresses a HighCharts < 8 bug
// caused by the accessibility plugin
// https://github.com/highcharts/highcharts/issues/12883


var ChartingContainer = styled_components_1.default.div.attrs(function (props) {
  return {
    'data-test': 'charting-container',
    width: props.width,
    height: props.height
  };
}).withConfig({
  displayName: "Charting__ChartingContainer",
  componentId: "sc-3wbgm0-0"
})(["& .highcharts-a11y-proxy-container{pointer-events:none;}overflow:hidden;position:relative;", ";"], function (props) {
  return style_1.toDimension(lodash_1.pick(props, ['width', 'height']));
});
var propTypes = {
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  options: T.object,
  chartData: T.object,
  onEventTrigger: T.func,
  onClick: T.func,
  onSelect: T.func,
  onPointMouseOver: T.func,
  onPointMouseOut: T.func,
  style: T.object,
  colorPalette: T.array,
  visualizationApiRef: T.func,
  themeKey: T.string
};

var Charting = function Charting(props) {
  var container = react_1.useRef(null);
  var needsInit = react_1.useRef(true);
  var chart = react_1.useRef();
  var needsRedraw = react_1.useRef(true);
  var api = react_1.useRef(new ChartingApi_1.ChartingApiFunctional(chart));

  var computeChartingSize = function computeChartingSize() {
    if (container.current) {
      var rect = container.current.getBoundingClientRect();
      return {
        height: rect.height,
        width: rect.width
      };
    }

    return {};
  };

  var splunkTheme = useSplunkTheme_1.default();
  var themeKey = props.themeKey ? props.themeKey : themeUtils_1.getChartingThemeKey({
    splunkThemeV1: splunkTheme
  });
  var width = props.width,
      height = props.height,
      style = props.style,
      chartData = props.chartData,
      options = props.options,
      colorPalette = props.colorPalette,
      onClick = props.onClick,
      onSelect = props.onSelect,
      onPointMouseOut = props.onPointMouseOut,
      onPointMouseOver = props.onPointMouseOver,
      onEventTrigger = props.onEventTrigger;

  var handleClick = function handleClick(chartEvent, type) {
    var payload = lodash_1.pick(chartEvent, 'name2', 'value2', '_span', 'modifierKey');
    payload['name'] = payload['name2'];
    delete payload['name2'];

    if (type === VizChartEventType.POINT_CLICK) {
      payload['value'] = payload['value2'];
      delete payload['value2'];
      payload = exports.updateRowPayload(chartEvent['rowContext'], payload);
    }

    onClick({
      type: type,
      originalEvent: chartEvent,
      payload: payload
    });
  };

  var destroyChart = function destroyChart() {
    if (chart.current) {
      chart.current.destroy();
      chart.current = null;
    }

    needsRedraw.current = true;
    needsInit.current = true;
  };

  var handleSelect = function handleSelect(chartEvent) {
    // todo: need change this after breaking all visualizations
    if (onSelect && typeof onSelect === 'function') {
      onSelect({
        type: 'range.select',
        originalEvent: chartEvent,
        payload: lodash_1.pick(chartEvent, 'startXIndex', 'endXIndex', 'startXValue', 'endXValue')
      });
      return;
    } // the chartEvent here is a jQuery event


    onEventTrigger({
      type: 'range.select',
      originalEvent: chartEvent,
      payload: lodash_1.pick(chartEvent, 'startXIndex', 'endXIndex', 'startXValue', 'endXValue')
    });
  };

  var handlePointMouseOut = function handlePointMouseOut(chartEvent, type) {
    var payload = lodash_1.pick(chartEvent, 'name2', 'value2', '_span', 'modifierKey', 'tooltipContext');
    payload['name'] = payload['name2'];
    delete payload['name2'];
    payload['value'] = payload['value2'];
    delete payload['value2'];
    payload = exports.updateRowPayload(chartEvent['rowContext'], payload);
    onPointMouseOut({
      type: type,
      originalEvent: chartEvent,
      payload: payload
    });
  };

  var handlePointMouseOver = function handlePointMouseOver(chartEvent, type) {
    var payload = lodash_1.pick(chartEvent, 'name2', 'value2', '_span', 'modifierKey', 'tooltipContext');
    payload['name'] = payload['name2'];
    delete payload['name2'];
    payload['value'] = payload['value2'];
    delete payload['value2'];
    payload = exports.updateRowPayload(chartEvent['rowContext'], payload);
    onPointMouseOver({
      type: type,
      originalEvent: chartEvent,
      payload: payload
    });
  };

  var drawChart = function drawChart() {
    var updatedOptions = Object.assign(Object.assign({}, options), {
      shouldColorizeTooltipData: false
    });
    var computedChartSize = computeChartingSize();
    var computedWidth = computedChartSize.width;
    var computedHeight = computedChartSize.height;
    var serializedTimezone = lodash_1.get(_this, ['context', 'serializedTimezone']);
    var ianaTimezone = lodash_1.get(_this, ['context', 'ianaTimezone']);
    var utcOffset = lodash_1.get(_this, ['context', 'utcOffset']);

    if (!computedWidth || !computedHeight) {
      return;
    }

    if (!chartData || !Object.keys(chartData).length) {
      return;
    }

    try {
      if (needsInit.current) {
        destroyChart();
        charting_bundle_1.default.setTheme(themeKey);

        if (colorPalette.length > 0) {
          charting_bundle_1.default.setColorPalette(colorPalette);
        }

        chart.current = charting_bundle_1.default.createChart(container.current, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, updatedOptions), {
          drilldown: 'all'
        }), typeof serializedTimezone === 'string' && {
          'time.serializedTz': serializedTimezone
        }), typeof ianaTimezone === 'string' && {
          'time.ianaTimezone': ianaTimezone
        }), typeof utcOffset === 'number' && {
          'time.timezoneOffset': utcOffset
        })); // bind event handlers

        chart.current.on('pointClick', function (e) {
          handleClick(e, VizChartEventType.POINT_CLICK);
        });
        chart.current.on('pointMouseOver', function (e) {
          handlePointMouseOver(e, VizChartEventType.POINT_MOUSE_OVER);
        });
        chart.current.on('pointMouseOut', function (e) {
          handlePointMouseOut(e, VizChartEventType.POINT_MOUSE_OUT);
        });
        chart.current.on('legendClick', function (e) {
          handleClick(e, VizChartEventType.LEGEND_CLICK);
        });
        chart.current.on('chartRangeSelect', handleSelect);
      }

      if (needsRedraw.current) {
        charting_bundle_1.default.setTheme(themeKey);

        if (colorPalette.length > 0) {
          charting_bundle_1.default.setColorPalette(colorPalette);
        }

        chart.current.prepareAndDraw(chartData, updatedOptions, function () {});
      }

      if (chart.current) {
        chart.current.resize(computedWidth, computedHeight);
      }

      needsInit.current = false;
      needsRedraw.current = false;
    } catch (e) {
      window.console.error('Caught error rendering chart:', e);
    }
  };

  var debouncedDrawChart = lodash_1.debounce(drawChart, 5);

  var onContainerMount = function onContainerMount(chartingContainer) {
    container.current = chartingContainer;
    debouncedDrawChart();
  };

  var prevOptions = usePrevious(options);
  var prevTheme = usePrevious(themeKey);
  react_1.useEffect(function () {
    debouncedDrawChart();
    props.visualizationApiRef(api.current);
    return function () {
      props.visualizationApiRef(null);
      destroyChart();
    };
  }, []);
  react_1.useEffect(function () {
    // TODO: figure out why re-init is needed for functional components (i.e. PlatformViz) when changing theme
    // seems like redraw doesn't suffice to update the background colors
    if (!chart.current || !exports.canUpdateInPlace(prevOptions, options) || !props.themeKey && prevTheme !== themeKey) {
      needsInit.current = true;
    }

    needsRedraw.current = true; // need to immediately call drawChart upon an option or chartData change
    // otherwise a noop would occur if the onContainerMount drawChart is re-invoked when dimensions change

    drawChart();
  }, [JSON.stringify(options), JSON.stringify(chartData.toJSON()), JSON.stringify(chartData.annotations), themeKey]);
  return React.createElement(ChartingContainer, {
    style: style,
    ref: onContainerMount,
    width: width,
    height: height
  }, React.createElement(react_event_listener_1.default, {
    target: window,
    onResize: debouncedDrawChart
  }));
};

var defaultProps = {
  width: '100%',
  height: 250,
  options: {},
  style: {},
  // todo: need remove it
  onEventTrigger: lodash_1.noop,
  onClick: lodash_1.noop,
  onSelect: lodash_1.noop,
  onPointMouseOver: lodash_1.noop,
  onPointMouseOut: lodash_1.noop,
  colorPalette: visualization_color_palettes_1.VIZ_CATEGORICAL,
  visualizationApiRef: lodash_1.noop,
  chartData: null,
  themeKey: null
};
Charting.propTypes = propTypes;
Charting.defaultProps = defaultProps; // allow for early return in case of empty chartData while still following hook rules

var withEmptyChartMessage = function withEmptyChartMessage(Chart) {
  var Wrapper = function Wrapper(props) {
    var chartData = props.chartData;

    if (!chartData) {
      return React.createElement(Message_1.default, {
        message: i18n_1._('No DataSource'),
        level: "warning"
      });
    }

    if (chartData && !Object.keys(chartData).length) {
      return React.createElement(Message_1.default, {
        message: i18n_1._('No Result'),
        level: "info"
      });
    }

    return React.createElement(Chart, Object.assign({}, props));
  };

  Wrapper.displayName = 'ChartingWrapper';
  Wrapper.propTypes = propTypes;
  Wrapper.defaultProps = defaultProps;
  return Wrapper;
}; // export default Charting;


exports.default = withEmptyChartMessage(Charting);

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = require("react-event-listener");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/i18n");

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/useSplunkTheme");

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/themeUtils");

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(9);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChartingApiFunctional = void 0;

var ChartingApiFunctional = /*#__PURE__*/function () {
  function ChartingApiFunctional(chartRef) {
    _classCallCheck(this, ChartingApiFunctional);

    this.chartRef = chartRef;
  }
  /**
   * Allows users to programmatically highlight a point on the chart
   *
   * @memberof ChartingApiFunctional
   */


  _createClass(ChartingApiFunctional, [{
    key: "highlight",
    value: function highlight() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        xValue: '',
        seriesName: ''
      },
          xValue = _ref.xValue,
          seriesName = _ref.seriesName;

      this.getChart().highlight(xValue, seriesName);
    }
    /**
     * Allows users to programmatically unhighlight all points on the chart
     *
     * @memberof ChartingApiFunctional
     */

  }, {
    key: "unHighlight",
    value: function unHighlight() {
      this.getChart().unHighlight();
    } // returns chart object

  }, {
    key: "getChart",
    value: function getChart() {
      var _a;

      return (_a = this.chartRef) === null || _a === void 0 ? void 0 : _a.current;
    }
  }]);

  return ChartingApiFunctional;
}();

exports.ChartingApiFunctional = ChartingApiFunctional;

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/simpleXMLOptions");

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableClickHandler = void 0;

var enableClickHandler = function enableClickHandler(hasEventHandlers, mode) {
  return !!hasEventHandlers && mode === 'view';
};

exports.enableClickHandler = enableClickHandler;

/***/ }),
/* 56 */,
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var i18n_1 = __webpack_require__(3);

var axes = {
  label: i18n_1._('Axes'),
  layout: [[{
    label: i18n_1._('X Axis title'),
    option: 'xAxisTitleText',
    editor: 'editor.text'
  }], [{
    label: i18n_1._('Y Axis title'),
    option: 'yAxisTitleText',
    editor: 'editor.text'
  }]]
};
exports.default = axes;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var i18n_1 = __webpack_require__(3);

var legend = {
  label: i18n_1._('Legend'),
  layout: [[{
    label: i18n_1._('Position'),
    option: 'legendDisplay',
    editor: 'editor.select',
    editorProps: {
      values: [{
        label: i18n_1._('Right'),
        value: 'right'
      }, {
        label: i18n_1._('Left'),
        value: 'left'
      }, {
        label: i18n_1._('Top'),
        value: 'top'
      }, {
        label: i18n_1._('Bottom'),
        value: 'bottom'
      }, {
        label: i18n_1._('Off'),
        value: 'off'
      }]
    }
  }], [{
    label: i18n_1._('Truncation'),
    option: 'legendTruncation',
    editor: 'editor.radioBar',
    editorProps: {
      values: [{
        label: i18n_1._('A...'),
        value: 'ellipsisEnd'
      }, {
        label: i18n_1._('A...Z'),
        value: 'ellipsisMiddle'
      }, {
        label: i18n_1._('...Z'),
        value: 'ellipsisStart'
      }, {
        label: i18n_1._('Off'),
        value: 'ellipsisOff'
      }]
    }
  }]]
};
exports.default = legend;

/***/ }),
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */
/***/ (function(module, exports) {

module.exports = require("@splunk/react-icons/BarBeside");

/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = require("@splunk/react-icons/BarStacked");

/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = require("@splunk/react-icons/BarStacked100");

/***/ }),
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = exports.themes = exports.computeVizProps = void 0;

var lodash_1 = __webpack_require__(2);

var Charting_1 = __webpack_require__(48);

var charting_bundle_1 = __webpack_require__(44);

var simpleXMLOptions_1 = __webpack_require__(54);

var config_1 = __webpack_require__(137);

exports.config = config_1.default;

var withDashboardViz_1 = __webpack_require__(26);

var barUtils_1 = __webpack_require__(138);

var chartingUtils_1 = __webpack_require__(43);

var eventUtils_1 = __webpack_require__(55);

var validOptions = Object.keys(config_1.default.optionsSchema);

var computeVizProps = function computeVizProps(_a) {
  var dataSources = _a.dataSources,
      x = _a.x,
      y = _a.y,
      xField = _a.xField,
      yFields = _a.yFields,
      onEventTrigger = _a.onEventTrigger,
      visualizationApiRef = _a.visualizationApiRef,
      otherOptions = __rest(_a, ["dataSources", "x", "y", "xField", "yFields", "onEventTrigger", "visualizationApiRef"]); // options to be passed as props


  var computedProps = {
    visualizationApiRef: visualizationApiRef
  };
  var y2 = otherOptions.y2,
      y2Fields = otherOptions.y2Fields;
  computedProps.options = lodash_1.chain(otherOptions).pick(validOptions).thru(barUtils_1.convertToBarSCProperties).thru(function (options) {
    return Object.assign(Object.assign({}, simpleXMLOptions_1.getSimpleXMLOptionsForProps(options)), {
      chart: 'bar'
    });
  }).value();
  var truncationLimit = computedProps.options['chart.resultTruncationLimit'];
  var primaryData = Object.assign({}, dataSources.primary.data);

  var _chartingUtils_1$cons = chartingUtils_1.constructFieldsAndColumns({
    x: x,
    y: y,
    xField: xField,
    yFields: yFields,
    y2: y2,
    y2Fields: y2Fields
  }),
      columns = _chartingUtils_1$cons.columns,
      fields = _chartingUtils_1$cons.fields;

  primaryData.columns = columns;
  primaryData.fields = fields;

  if (truncationLimit) {
    primaryData = chartingUtils_1.truncateData(primaryData, truncationLimit);
  }

  computedProps.chartData = charting_bundle_1.default.extractChartReadyData(Object.assign({}, primaryData));

  if (eventUtils_1.enableClickHandler(otherOptions.hasEventHandlers, otherOptions.mode)) {
    computedProps.onClick = onEventTrigger;
    computedProps.onSelect = onEventTrigger;
    computedProps.onPointMouseOver = onEventTrigger;
    computedProps.onPointMouseOut = onEventTrigger;
  }

  return computedProps;
};

exports.computeVizProps = computeVizProps;
var Bar = withDashboardViz_1.default({
  ReactViz: Charting_1.default,
  computeVizProps: exports.computeVizProps,
  vizConfig: config_1.default
});
var themes = null;
exports.themes = themes;
exports.default = Bar;

/***/ }),
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__exportStar(__webpack_require__(108), exports);

var Bar_1 = __webpack_require__(108);

Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return Bar_1.default;
  }
});

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var visualization_icons_1 = __webpack_require__(40);

var schemaUtils_1 = __webpack_require__(14);

var visualization_color_palettes_1 = __webpack_require__(41);

var i18n_1 = __webpack_require__(3);

var BarBeside_1 = __webpack_require__(67);

var BarStacked_1 = __webpack_require__(68);

var BarStacked100_1 = __webpack_require__(69);

var pick_1 = __webpack_require__(20);

var variables_1 = __webpack_require__(19);

var Axes_1 = __webpack_require__(57);

var Legend_1 = __webpack_require__(58);

var BackgroundColor_1 = __webpack_require__(45);

var VizBehavior_1 = __webpack_require__(5);

var VizCategory_1 = __webpack_require__(25);

var configUtils_1 = __webpack_require__(8);

var dataContract = {
  requiredDataSources: [{
    name: 'primary',
    description: 'DataSource that powers the visualization'
  }],
  optionalDataSources: [// Note: SCP-14090 disable ui for optional datasources. We may need to add it back later
    // {
    //     name: 'annotation',
    //     description: 'DataSource that populate event annotations',
    // },
  ],
  initialRequestParams: {
    primary: {
      offset: 0,
      count: 10000
    }
  }
};
var size = {
  initialWidth: 300,
  initialHeight: 300
};
var defaultContext = {};
var optionsSchema = {
  x: {
    default: '> primary | seriesByIndex(0)',
    description: 'Specify the dataSource applied to the x-axis.',
    type: 'array',
    items: {
      type: ['string', 'number']
    }
  },
  y: {
    default: '> primary | frameBySeriesIndexRange(1)',
    description: 'Specify the dataSource applied to the y-axis.',
    type: 'array',
    items: {
      type: ['string', 'number']
    }
  },
  y2: {
    description: 'Specify the dataSource applied to the y2-axis',
    type: 'array',
    items: {
      type: ['string', 'number']
    }
  },
  xField: {
    default: '> x | getField()',
    description: 'Specify the field that should be mapped to the x-axis.',
    type: 'string'
  },
  yFields: {
    default: '> y | getField()',
    description: 'Specify the field that should be mapped to the y-axis.',
    type: 'string'
  },
  y2Fields: {
    default: '> y2 | getField()',
    description: 'Specify field(s) that should be mapped to a second y-axis.',
    type: ['array', 'string'],
    items: {
      type: 'string'
    }
  },
  backgroundColor: {
    default: '> themes.defaultBackgroundColor',
    description: 'Specify the color for the background. You may use a dataSource to apply the color. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
    pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN,
    type: 'string'
  },
  barSpacing: {
    description: 'Specify, in pixels, the spacing between columns in a bar chart.',
    type: 'number'
  },
  dataValuesDisplay: {
    default: 'off',
    description: 'Specify whether chart should display no labels, all labels, or only the min and max labels.',
    pattern: schemaUtils_1.getPattern(['off', 'all', 'minmax']),
    type: 'string'
  },
  legendDisplay: {
    default: 'right',
    description: 'Specify the location of the legend on the panel.',
    pattern: schemaUtils_1.getPattern(['right', 'left', 'top', 'bottom', 'off']),
    type: 'string'
  },
  legendLabels: {
    description: "Specify a list of labels to pre-populate the legend. For example, [\"percent\", \"count\"].",
    type: 'array',
    items: {
      type: 'string'
    }
  },
  legendTruncation: {
    default: 'ellipsisEnd',
    description: 'Specify how to display legend labels when they overflow the layout boundaries by replacing overflow text with an ellipsis.',
    pattern: schemaUtils_1.getPattern(['ellipsisEnd', 'ellipsisMiddle', 'ellipsisStart', 'ellipsisOff']),
    type: 'string'
  },
  lineWidth: {
    default: 2,
    description: 'Specify the line width, in pixels, for chart overlay.',
    type: 'number'
  },
  resultLimit: {
    default: 50000,
    description: 'Specify the number of data points rendered in a chart.',
    type: 'number'
  },
  seriesColors: {
    default: visualization_color_palettes_1.VIZ_CATEGORICAL,
    description: 'Specify the colors used for a series. For example, ["#FF0000", "#0000FF", "#008000"].',
    type: 'array',
    items: {
      type: 'string'
    }
  },
  seriesColorsByField: {
    description: 'Specify the colors used for specific fields in a series. For example, {“count”: “#008000”, “percent”: “#FFA500”}.',
    type: 'object'
  },
  seriesSpacing: {
    description: 'Specify, in pixels, the spacing between clustered series in column and bar charts.',
    type: 'number'
  },
  stackMode: {
    default: 'auto',
    description: 'Specify stack mode.',
    pattern: schemaUtils_1.getPattern(['auto', 'stacked', 'stacked100']),
    type: 'string'
  },
  showIndependentYRanges: {
    default: false,
    description: 'Specify whether split series charts have independent y-ranges.',
    type: 'boolean'
  },
  showSplitSeries: {
    default: false,
    description: 'Set to "true" to split a multi-series chart into separate charts that are stacked from top to bottom; one for each series.',
    type: 'boolean'
  },
  showXMajorGridLines: {
    default: false,
    description: 'Specify whether major grid lines are visible on the x-axis.',
    type: 'boolean'
  },
  showYMajorGridLines: {
    default: true,
    description: 'Specify whether major grid lines are visible on the y-axis.',
    type: 'boolean'
  },
  showY2MajorGridLines: {
    default: false,
    description: 'Specify whether major grid lines are visible on the y2-axis.',
    type: 'boolean'
  },
  showYMinorGridLines: {
    default: false,
    description: 'Specify whether minor grid lines are visible on the y-axis.',
    type: 'boolean'
  },
  showY2MinorGridLines: {
    default: false,
    description: 'Specify whether minor grid lines are visible on y2-axis.',
    type: 'boolean'
  },
  showYAxisExtendedRange: {
    default: true,
    description: 'Specify whether the y-axis should be extended to include whole major tick marks.',
    type: 'boolean'
  },
  showYAxisWithZero: {
    default: false,
    description: 'Specify whether the y-axis range includes zero.',
    type: 'boolean'
  },
  showY2AxisWithZero: {
    default: false,
    description: 'Specify whether the y2-axis range includes zero.',
    type: 'boolean'
  },
  xAxisLabelVisibility: {
    default: 'auto',
    description: 'Specify whether to show or hide labels on the x-axis.',
    pattern: schemaUtils_1.getPattern(['auto', 'show', 'hide']),
    type: 'string'
  },
  yAxisLabelVisibility: {
    default: 'auto',
    description: 'Specify whether to show or hide labels on the y-axis.',
    pattern: schemaUtils_1.getPattern(['auto', 'show', 'hide']),
    type: 'string'
  },
  y2AxisLabelVisibility: {
    default: 'auto',
    description: 'Specify whether to show or hide labels on the y2-axis.',
    pattern: schemaUtils_1.getPattern(['auto', 'show', 'hide']),
    type: 'string'
  },
  xAxisLineVisibility: {
    default: 'hide',
    description: 'Specify whether to show or hide the x-axis line.',
    pattern: schemaUtils_1.getPattern(['show', 'hide']),
    type: 'string'
  },
  yAxisLineVisibility: {
    default: 'hide',
    description: 'Specify whether to show or hide the y-axis line.',
    pattern: schemaUtils_1.getPattern(['show', 'hide']),
    type: 'string'
  },
  y2AxisLineVisibility: {
    default: 'hide',
    description: 'Specify whether to show or hide the y2-axis line.',
    pattern: schemaUtils_1.getPattern(['show', 'hide']),
    type: 'string'
  },
  xAxisMajorTickSize: {
    default: 6,
    description: 'Specify the size, in pixels, of major tick marks on the x-axis.',
    type: 'number'
  },
  yAxisMajorTickSize: {
    default: 6,
    description: 'Specify the size, in pixels, of major tick marks on the y-axis.',
    type: 'number'
  },
  y2AxisMajorTickSize: {
    default: 6,
    description: 'Specify the size, in pixels, of major tick marks on the y2-axis.',
    type: 'number'
  },
  yAxisMinorTickSize: {
    default: 6,
    description: 'Specify the size, in pixels, of minor tick marks on the y-axis.',
    type: 'number'
  },
  y2AxisMinorTickSize: {
    default: 6,
    description: 'Specify the size, in pixels, of minor tick marks on the y2-axis.',
    type: 'number'
  },
  xAxisMajorTickVisibility: {
    default: 'auto',
    description: 'Specify whether to show or hide major tick marks on the x-axis.',
    pattern: schemaUtils_1.getPattern(['auto', 'show', 'hide']),
    type: 'string'
  },
  yAxisMajorTickVisibility: {
    default: 'auto',
    description: 'Specify whether to show or hide major tick marks on the y-axis.',
    pattern: schemaUtils_1.getPattern(['auto', 'show', 'hide']),
    type: 'string'
  },
  y2AxisMajorTickVisibility: {
    default: 'auto',
    description: 'Specify whether to show or hide major tick marks on the y2-axis.',
    pattern: schemaUtils_1.getPattern(['auto', 'show', 'hide']),
    type: 'string'
  },
  yAxisMinorTickVisibility: {
    default: 'auto',
    description: 'Specify whether to show or hide minor tick marks on the y-axis.',
    pattern: schemaUtils_1.getPattern(['auto', 'show', 'hide']),
    type: 'string'
  },
  y2AxisMinorTickVisibility: {
    default: 'auto',
    description: 'Specify whether to show or hide minor tick marks on the y2-axis.',
    pattern: schemaUtils_1.getPattern(['auto', 'show', 'hide']),
    type: 'string'
  },
  xAxisMaxLabelParts: {
    default: 3,
    minimum: 1,
    maximum: 3,
    description: 'Specify the maximum number of time-parts that a tick label will have (the 3 possible parts are year, month, time).',
    type: 'number'
  },
  yAxisScale: {
    default: 'linear',
    description: 'Specify the type of scale that applies to a numerical y-axis.',
    pattern: schemaUtils_1.getPattern(['linear', 'log']),
    type: 'string'
  },
  y2AxisScale: {
    default: 'linear',
    description: 'Specify the type of scale that applies to a numerical y2-axis.',
    pattern: schemaUtils_1.getPattern(['linear', 'log']),
    type: 'string'
  },
  xAxisTitleText: {
    description: 'Specify the title of the x-axis.',
    type: 'string'
  },
  yAxisTitleText: {
    description: 'Specify the title of the y-axis.',
    type: 'string'
  },
  y2AxisTitleText: {
    description: 'Specify the title of the y2-axis.',
    type: 'string'
  },
  xAxisTitleVisibility: {
    default: 'show',
    description: 'Specify whether to show or hide the title of the x-axis.',
    pattern: schemaUtils_1.getPattern(['show', 'hide']),
    type: 'string'
  },
  yAxisTitleVisibility: {
    default: 'show',
    description: 'Specify whether to show or hide the title of the y-axis.',
    pattern: schemaUtils_1.getPattern(['show', 'hide']),
    type: 'string'
  },
  y2AxisTitleVisibility: {
    default: 'show',
    description: 'Specify whether to show or hide the title of the y2-axis.',
    pattern: schemaUtils_1.getPattern(['show', 'hide']),
    type: 'string'
  },
  yAxisAbbreviation: {
    default: 'auto',
    description: 'Specify whether to abbreviate large y-axis values with the closest SI prefix.',
    pattern: schemaUtils_1.getPattern(['off', 'auto']),
    type: 'string'
  },
  y2AxisAbbreviation: {
    default: 'auto',
    description: 'Specify whether to abbreviate large y2-axis values with the closest SI prefix.',
    pattern: schemaUtils_1.getPattern(['off', 'auto']),
    type: 'string'
  },
  yAxisMajorTickInterval: {
    default: 'auto',
    description: 'Specify the spacing unit between major tick marks along the numeric y-axis.',
    type: ['string', 'number']
  },
  y2AxisMajorTickInterval: {
    default: 'auto',
    description: 'Specify the spacing unit between major tick marks along the numeric y2-axis.',
    type: ['string', 'number']
  },
  // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
  yAxisMax: {
    default: 'auto',
    description: 'Specify the maximum number for the visible y-axis range.',
    type: ['string', 'number']
  },
  // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
  y2AxisMax: {
    default: 'auto',
    description: 'Specify the maximum number for the visible y2-axis range.',
    type: ['string', 'number']
  },
  // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
  yAxisMin: {
    default: 'auto',
    description: 'Specify the minimum number for the visible y-axis range.',
    type: ['string', 'number']
  },
  // TODO(SCP-40274): Restrict string value to only 'auto' to achieve precise schema validation
  y2AxisMin: {
    default: 'auto',
    description: 'Specify the minimum number for the visible y2-axis range.',
    type: ['string', 'number']
  },
  overlayFields: {
    description: 'Specify field(s) that should be differentiated on the chart and displayed as chart overlays.',
    type: ['array', 'string']
  },
  showOverlayY2Axis: {
    default: false,
    description: 'Enable a y2-axis for chart overlays. All overlay fields will be mapped to a second y-axis.',
    type: 'boolean'
  },
  showRoundedY2AxisLabels: {
    default: true,
    description: 'Specify whether to round y2-axis values to the nearest integer.',
    type: 'boolean'
  }
};
var themes = {
  defaultBackgroundColor: function defaultBackgroundColor(props) {
    return pick_1.default({
      enterprise: {
        dark: variables_1.default.black(props),
        light: variables_1.default.backgroundColor(props)
      },
      prisma: variables_1.default.backgroundColorSidebar(props)
    })(props);
  }
};
var editorConfig = [{
  label: i18n_1._('General'),
  layout: [BackgroundColor_1.default({
    themes: themes
  }), [{
    label: i18n_1._('Stack Mode'),
    option: 'stackMode',
    editor: 'editor.radioBar',
    editorProps: {
      values: [{
        icon: BarBeside_1.default,
        label: i18n_1._('Not stacked'),
        value: 'auto'
      }, {
        icon: BarStacked_1.default,
        label: i18n_1._('Stacked'),
        value: 'stacked'
      }, {
        icon: BarStacked100_1.default,
        label: i18n_1._('Stacked 100%'),
        value: 'stacked100'
      }]
    }
  }], [{
    label: i18n_1._('Data Values Display'),
    option: 'dataValuesDisplay',
    editor: 'editor.radioBar',
    editorProps: {
      values: [{
        label: i18n_1._('Off'),
        value: 'off'
      }, {
        label: i18n_1._('On'),
        value: 'all'
      }, {
        label: i18n_1._('Min/Max'),
        value: 'minmax'
      }]
    }
  }]]
}, Axes_1.default, Legend_1.default];
/**
 * visualization configuration
 */

var config = {
  /**
   * unique viz key
   */
  key: 'splunk.bar',

  /**
   * viz name
   */
  name: 'Bar',
  category: VizCategory_1.VizCategory.COMPARISONS,

  /**
   * viz icon
   */
  icon: visualization_icons_1.Bar,
  dataContract: dataContract,
  size: size,
  defaultContext: defaultContext,
  optionsSchema: optionsSchema,
  editorConfig: editorConfig,
  events: {
    'legend.click': {
      description: 'triggered when user clicks on chart legend'
    },
    'point.click': {
      description: 'triggered when user clicks on a point in the bar chart'
    },
    'point.mouseover': {
      description: 'triggered when user hovers over a data point'
    },
    'point.mouseout': {
      description: 'triggered when user moves out of a data point'
    }
  },
  supports: [VizBehavior_1.VizBehavior.DYNAMIC_OPTIONS, VizBehavior_1.VizBehavior.PLACEHOLDER, VizBehavior_1.VizBehavior.EVENTS],
  themes: themes
};
exports.default = configUtils_1.enhanceConfig(config);

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToBarSCProperties = exports.mapToOldKey = exports.convertToStringValues = void 0;

var lodash_1 = __webpack_require__(2);

var propUtils_1 = __webpack_require__(17);

var chartingUtils_1 = __webpack_require__(43); // map for key names which are either new or not present in SimpleXML options mapping


var barOptionsSCMapping = {
  yAxisMajorTickInterval: 'yAxisMajorUnit',
  yAxisLabelVisibility: 'yAxisMajorLabelVisibility',
  xAxisLabelVisibility: 'xAxisMajorLabelVisibility',
  y2AxisLabelVisibility: 'y2AxisMajorLabelVisibility',
  y2AxisMajorTickInterval: 'y2AxisMajorUnit',
  showRoundedY2AxisLabels: 'roundY2AxisLabelsToInteger',
  showXMajorGridLines: 'showMajorXGridLines',
  showYMajorGridLines: 'showMajorYGridLines',
  showYMinorGridLines: 'showMinorYGridLines',
  showY2MajorGridLines: 'showMajorY2GridLines',
  showY2MinorGridLines: 'showMinorY2GridLines',
  showYAxisWithZero: 'yAxisIncludeZero',
  showY2AxisWithZero: 'y2AxisIncludeZero',
  showYAxisExtendedRange: 'yAxisExtendsAxisRange',
  showSplitSeries: 'splitSeries',
  showIndependentYRanges: 'allowIndependentYRanges',
  showOverlayY2Axis: 'enableY2Axis',
  dataValuesDisplay: 'showDataLabels',
  legendDisplay: 'legendPlacement',
  legendTruncation: 'legendLabelOverflowMode',
  resultLimit: 'resultTruncationLimit',
  seriesColorsByField: 'fieldColors',
  xAxisLineVisibility: 'xAxisVisibility',
  yAxisLineVisibility: 'yAxisVisibility',
  y2AxisLineVisibility: 'y2AxisVisibility'
}; // key value mapping of what options (and their corresponding values) which we expose in config.ts to property values SC understands

var barOptionValuesSCMapping = {
  xAxisTitleVisibility: {
    show: 'visible',
    hide: 'collapsed'
  },
  yAxisTitleVisibility: {
    show: 'visible',
    hide: 'collapsed'
  },
  y2AxisTitleVisibility: {
    show: 'visible',
    hide: 'collapsed'
  },
  yAxisAbbreviation: {
    off: 'none'
  },
  y2AxisAbbreviation: {
    off: 'none'
  },
  stackMode: {
    auto: 'default'
  },
  showDataLabels: {
    off: 'none'
  },
  legendPlacement: {
    off: 'none'
  },
  legendLabelOverflowMode: {
    ellipsisOff: 'ellipsisNone'
  }
};
/**
 * Helper method to convert option which contains object literal values (e.g. arrays, objects)
 * to strings as SC can only accept their stringified equivalents
 * @method convertToStringValues
 * @param {Object} options
 * @returns {Object}
 */

var convertToStringValues = function convertToStringValues(options) {
  var updatedOptions = propUtils_1.convertPropsToString({
    vizProps: options,
    propNames: ['seriesColors', 'fieldColors', 'legendLabels']
  });
  return Object.assign(Object.assign({}, options), updatedOptions);
};

exports.convertToStringValues = convertToStringValues;
/**
 * Helper method to update the option names which can be mapped to SimpleXML options or
 * can be used directly with SC if don't have a 1-1 mapping in SimpleXML
 * @method mapToOldKey
 * @param {Object} options
 * @returns {Object}
 */

var mapToOldKey = function mapToOldKey(options) {
  return lodash_1.mapKeys(options, function (val, key) {
    return barOptionsSCMapping[key] ? barOptionsSCMapping[key] : key;
  });
};

exports.mapToOldKey = mapToOldKey;
/**
 * Chained helper for mapping the option properties (and values) we expose in config.ts into property values that splunk-charting accepts
 * This is for options that has new key name and can not directly be mapped with SimpleXML or
 * don't have a 1-1 mapping in SimpleXML (i.e. a straightforward name mapping where values are preserved)
 * @method convertToBarSCProperties
 * @param {Object} originalOptions
 * @returns {Object}
 */

var convertToBarSCProperties = function convertToBarSCProperties(originalOptions) {
  return lodash_1.chain(exports.mapToOldKey(originalOptions)).thru(chartingUtils_1.mapToValues(barOptionValuesSCMapping)).thru(chartingUtils_1.convertY2AxisOptions).thru(chartingUtils_1.convertOverlayFields).thru(exports.convertToStringValues).value();
};

exports.convertToBarSCProperties = convertToBarSCProperties;

/***/ })
/******/ ]);
//# sourceMappingURL=Bar.js.map