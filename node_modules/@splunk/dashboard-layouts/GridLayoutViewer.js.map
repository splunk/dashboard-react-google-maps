{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"react\"","webpack:///external \"styled-components\"","webpack:///external \"lodash/get\"","webpack:///./src/utils/edgeUtils.ts","webpack:///external \"@splunk/dashboard-utils/uniqueId\"","webpack:///external \"lodash/findLast\"","webpack:///external \"lodash/isNumber\"","webpack:///external \"lodash/reduce\"","webpack:///./src/utils/layoutUtils.ts","webpack:///external \"lodash/pullAt\"","webpack:///external \"lodash/cloneDeep\"","webpack:///external \"lodash/sortBy\"","webpack:///external \"prop-types\"","webpack:///external \"@splunk/dashboard-utils/console\"","webpack:///./src/BaseLayout.jsx","webpack:///external \"@splunk/dashboard-utils/layout\"","webpack:///external \"@splunk/themes/mixins\"","webpack:///external \"@splunk/dashboard-ui/customThemeVariables\"","webpack:///./src/GridLayoutViewer.tsx","webpack:///./src/components/GridItem.tsx","webpack:///./src/utils/gridLayoutViewerUtils.ts","webpack:///./src/DefaultOptions.ts"],"names":[],"mappings":"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","file":"GridLayoutViewer.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 82);\n","module.exports = require(\"react\");","module.exports = require(\"styled-components\");","module.exports = require(\"lodash/get\");","import { uniqueId } from '@splunk/dashboard-utils/uniqueId';\nimport type {\n    AbsoluteBlockItem,\n    AbsolutePosition,\n    Coordinate,\n} from '@splunk/dashboard-types';\nimport {\n    EdgeItem,\n    VerticalBoundaries,\n    HorizontalBoundaries,\n    EdgeBoundaries,\n} from '../types';\n\nconst nextEdgeId = () => `edge_${uniqueId()}`;\n\n/**\n * generate edge id\n */\nconst getNextEdgeId = () => {\n    return nextEdgeId();\n};\n\ntype Intersections = Record<number, Record<number, AbsoluteBlockItem[]>>;\n\n/**\n * Returns a 2D array of every viz corner, indicating which visualizations touch which node(corner)\n * @param {Object} layoutStructure - Array of visualizations from definition\n * @returns {Object[][]} - {x: { y: [vizList] } }\n */\nconst getNodes = (\n    layoutStructure: AbsoluteBlockItem[]\n): Intersections | null => {\n    if (layoutStructure.length === 0) {\n        return null;\n    }\n\n    const nodes: Intersections = {};\n    layoutStructure.forEach((viz) => {\n        const { x, y, w, h } = viz.position;\n        const corners = [\n            { x, y },\n            { x: x + w, y },\n            { x, y: y + h },\n            { x: x + w, y: y + h },\n        ];\n        corners.forEach((corner) => {\n            if (nodes[corner.x] === undefined) {\n                nodes[corner.x] = {};\n            }\n            if (nodes[corner.x][corner.y] === undefined) {\n                nodes[corner.x][corner.y] = [];\n            }\n            nodes[corner.x][corner.y].push(viz);\n        });\n    });\n    return nodes;\n};\n\nconst isTopEdge = (edge: EdgeItem): boolean =>\n    edge.orientation === 'horizontal' && edge.edgeStart.y === 0;\n\nconst isBottomEdge = (edge: EdgeItem, canvasHeight: number) =>\n    edge.orientation === 'horizontal' && edge.edgeStart.y === canvasHeight;\n\nconst isLeftEdge = (edge: EdgeItem): boolean =>\n    edge.orientation === 'vertical' && edge.edgeStart.x === 0;\n\nconst isRightEdge = (edge: EdgeItem, canvasWidth: number): boolean =>\n    edge.orientation === 'vertical' && edge.edgeStart.x === canvasWidth;\n\n/**\n * Returns all the visualizations along a vertical edge\n * @param {Object} param - Param object needed to traverse along vertical edge\n * @param {num} param.x - x-coordinate of the edge\n * @param {num} param.yStart - y-coordinate of the edge start\n * @param {num} param.yEnd - y-coordinate of the edge end\n * @param {num} param.yCurrent - Current y in recursion\n * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n * @param {num} param.visualizations - the list to add visualizations to, and then return\n * @returns {Set<Object>} - Set of unique visualizations along the edge\n */\nconst findVizAlongVerticalEdge = ({\n    x,\n    yStart,\n    yEnd,\n    yCurrent = yStart,\n    nodes,\n    visualizations = new Set(),\n}: {\n    x: number;\n    yStart: number;\n    yEnd: number;\n    yCurrent?: number;\n    nodes: Intersections;\n    visualizations?: Set<AbsoluteBlockItem>;\n}) => {\n    nodes[x][yCurrent].forEach((viz) => {\n        if (viz.position.y >= yStart && viz.position.y < yEnd) {\n            visualizations.add(viz);\n        }\n        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {\n            findVizAlongVerticalEdge({\n                x,\n                yStart,\n                yEnd,\n                yCurrent: yCurrent + viz.position.h,\n                nodes,\n                visualizations,\n            });\n        }\n    });\n    return visualizations;\n};\n\n/**\n * Returns all the visualizations along a horizontal edge\n * @param {Object} param - Param object needed to traverse along horizontal edge\n * @param {num} param.y - x-coordinate of the edge\n * @param {num} param.xStart - x-coordinate of the edge start\n * @param {num} param.xEnd - x-coordinate of the edge end\n * @param {num} param.xCurrent - Current x in recursion\n * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n * @param {num} param.visualizations - the list to add visualizations to, and then return\n * @returns {Set<Object>} - Set of unique visualizations along the edge\n */\nconst findVizAlongHorizontalEdge = ({\n    y,\n    xStart,\n    xEnd,\n    xCurrent = xStart,\n    nodes,\n    visualizations = new Set(),\n}: {\n    y: number;\n    xStart: number;\n    xEnd: number;\n    xCurrent?: number;\n    nodes: Intersections;\n    visualizations?: Set<AbsoluteBlockItem>;\n}) => {\n    nodes[xCurrent][y].forEach((viz) => {\n        if (viz.position.x >= xStart && viz.position.x < xEnd) {\n            visualizations.add(viz);\n        }\n        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {\n            findVizAlongHorizontalEdge({\n                y,\n                xStart,\n                xEnd,\n                xCurrent: xCurrent + viz.position.w,\n                nodes,\n                visualizations,\n            });\n        }\n    });\n    return visualizations;\n};\n\n/**\n * Add edge to the provided list\n * @param {Object} param - Params containing edge info\n * @param {num} param.edges - the list to add the edge to\n * @param {Object} param.edgeStart - the start of the edge\n * @param {Object} param.edgeEnd - the end of the edge\n * @param {Object[][]} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n */\nconst addEdge = ({\n    edges,\n    edgeStart,\n    edgeEnd,\n    nodes,\n}: {\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    edgeEnd: Coordinate;\n    nodes: Intersections;\n}): void => {\n    const orientation = edgeStart.y === edgeEnd.y ? 'horizontal' : 'vertical';\n\n    // Find all visualizations that are affected by this edge\n    const visualizations =\n        orientation === 'vertical'\n            ? findVizAlongVerticalEdge({\n                  x: edgeStart.x,\n                  yStart: edgeStart.y,\n                  yEnd: edgeEnd.y,\n                  nodes,\n              })\n            : findVizAlongHorizontalEdge({\n                  y: edgeStart.y,\n                  xStart: edgeStart.x,\n                  xEnd: edgeEnd.x,\n                  nodes,\n              });\n\n    edges.push({\n        item: getNextEdgeId(),\n        edgeStart,\n        edgeEnd,\n        visualizations: Array.from(visualizations),\n        orientation,\n    });\n};\n\n/**\n * If there is no incoming edge from the top, return true\n * @param {num} y - Current y position to compare against\n * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @returns {boolean}\n */\nconst shouldTraverseDown = (\n    y: number,\n    visualizations: AbsoluteBlockItem[]\n): boolean => {\n    return visualizations.every((viz) => viz.position.y >= y);\n};\n\n/**\n * If there is no incoming edge from the left, return true\n * @param {num} x - Current x position to compare against\n * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @returns {boolean}\n */\nconst shouldTraverseRight = (\n    x: number,\n    visualizations: AbsoluteBlockItem[]\n): boolean => {\n    return visualizations.every((viz) => viz.position.x >= x);\n};\n\n/**\n * Find the offset to the next node.\n * @param {Object} param - Param object to find offset to next node\n * @param {Number} param.x - The x co-ordinate of the current position to find offset from\n * @param {Number} param.y - The y co-ordinate of the current position to find offset from\n * @param {Object[]} param.visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @param {Object} param.visualizations[].position - Position information of the visualization\n * @param {String} param.type - The type of co-ordinate. One of 'w' or 'h'.\n * @returns {number}\n */\nconst findOffset = ({\n    x,\n    y,\n    visualizations,\n    type,\n}: {\n    x: number;\n    y: number;\n    visualizations: AbsoluteBlockItem[];\n    type: 'w' | 'h';\n}): number => {\n    for (let i = 0; i < visualizations.length; i += 1) {\n        const { position } = visualizations[i];\n        if (position.y === y && position.x === x) {\n            return position[type];\n        }\n    }\n\n    // This for-loop is only for finding the bottom canvas edge and the right canvas edge\n    for (let i = 0; i < visualizations.length; i += 1) {\n        const { position } = visualizations[i];\n        if (type === 'w' && position.x === x) {\n            // horizontal canvas edge\n            return position.w;\n        }\n        if (type === 'h' && position.y === y) {\n            // vertical canvas edge\n            return position.h;\n        }\n    }\n\n    return 0;\n};\n\n/**\n * Traverse right along nodes, creating or extending edges\n * @param {Object} param - Param object to traverse right along layout\n * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].\n * @param {Object[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.x - x coordinate of current node\n * @param {Number} param.y - y coordinate of current node\n * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge\n * @param {Boolean} param.canTraverseDown - Used to prevent loops during indirect recursion\n */\nfunction traverseRight({\n    x,\n    y,\n    nodes,\n    edges,\n    edgeStart,\n    canTraverseDown = true,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    canTraverseDown?: boolean;\n}) {\n    // Check if we should traverse down (if there is no incoming edge)\n    // canTraverseRight must be false to avoid endless loop\n    if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        traverseDown({\n            x,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y }, // Start new edge when changing directions\n            canTraverseRight: false,\n        });\n    }\n\n    // Check if horizontal edge ends here\n    // 'w' signifies we want width offset returned as opposed to height\n    const offset = findOffset({ x, y, visualizations: nodes[x][y], type: 'w' });\n\n    // Case 1 for ending edge: can't go right anymore (hit a viz OR end of dashboard), create edge up to this point.\n    if (!offset) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        return;\n    }\n\n    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window\n    const isWindow = nodes[x][y].length === 4; // 4-way intersection\n    if (isWindow) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        // Continue traversing right, starting with a new edge from current position\n        traverseRight({\n            x: x + offset,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y },\n        });\n        return;\n    }\n\n    // Continue traversing right, merging the past edge with the next\n    traverseRight({\n        x: x + offset,\n        y,\n        nodes,\n        edges,\n        edgeStart,\n    });\n}\n\n/**\n * Traverse right along nodes, creating or extending edges\n * @param {Object} param - Param object to traverse down along layout\n * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].\n * @param {Object[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.x - x coordinate of current node\n * @param {Number} param.y - y coordinate of current node\n * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge\n * @param {Boolean} param.canTraverseRight - Used to prevent loops during indirect recursion\n */\nfunction traverseDown({\n    x,\n    y,\n    nodes,\n    edges,\n    edgeStart,\n    canTraverseRight = true,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    canTraverseRight?: boolean;\n}) {\n    if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {\n        traverseRight({\n            x,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y }, // Start new edge when changing directions\n            canTraverseDown: false,\n        });\n    }\n\n    // Check if vertical edge ends here\n    const offset = findOffset({ x, y, visualizations: nodes[x][y], type: 'h' });\n\n    // Case 1 for ending edge: can't go down anymore (hit a viz OR end of dashboard), create edge up to this point.\n    if (!offset) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        return;\n    }\n\n    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window\n    const isWindow = nodes[x][y].length === 4;\n    if (isWindow) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        // Start a new edge from current position\n        traverseDown({\n            x,\n            y: y + offset,\n            nodes,\n            edges,\n            edgeStart: { x, y },\n        });\n        return;\n    }\n\n    // Continue traversing, thus \"merging\" edges\n    traverseDown({\n        x,\n        y: y + offset,\n        nodes,\n        edges,\n        edgeStart,\n    });\n}\n\n/**\n * Compute the vertical edges for every canvas row - a row that spans the entire width of the canvas\n * @param {Object} param\n * @param {AbsoluteBlockItem[]} param.layout - Layout structure\n * @param {EdgeItem[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.canvasWidth - Canvas width\n */\nconst computeVerticalCanvasEdges = ({\n    edges,\n    canvasWidth,\n    layout,\n}: {\n    edges: EdgeItem[];\n    canvasWidth: number;\n    layout: AbsoluteBlockItem[];\n}): void => {\n    const nodes = getNodes(layout);\n    if (nodes == null) {\n        return;\n    }\n    // get all the horizontal edges that span the entire canvas width\n    const sortedRowEdges = edges\n        .filter(\n            (edge) =>\n                edge.orientation === 'horizontal' &&\n                edge.edgeStart.x === 0 &&\n                edge.edgeEnd.x === canvasWidth\n        )\n        .sort((a, b) => a.edgeStart.y - b.edgeStart.y);\n\n    /**\n     * iterate through the sorted horizontal edges to get their start and end coordinates\n     * vertical edges between canvas row A and canvas row B will span from edgeStartA to edgeStartB and edgeEndA to edgeEndB\n     */\n    for (let i = 0; i < sortedRowEdges.length - 1; i += 1) {\n        const { edgeStart: edgeStartA, edgeEnd: edgeEndA } = sortedRowEdges[i];\n        const { edgeStart: edgeStartB, edgeEnd: edgeEndB } = sortedRowEdges[\n            i + 1\n        ];\n        addEdge({\n            edges,\n            edgeStart: edgeStartA,\n            edgeEnd: edgeStartB,\n            nodes,\n        });\n        addEdge({\n            edges,\n            edgeStart: edgeEndA,\n            edgeEnd: edgeEndB,\n            nodes,\n        });\n    }\n};\n\n/**\n * Gets all the edges given a layout of AbsoluteBlockItems\n * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems\n * @returns {EdgeItem[]} - Array of computed edges\n */\nexport const getAllEdges = (layout: AbsoluteBlockItem[]): EdgeItem[] => {\n    const edges: EdgeItem[] = [];\n    const nodes = getNodes(layout);\n\n    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {\n        // When no visualizations in the layout structure\n        // OR when there is no visualization at (0,0), which this algorithm assumes\n        return [];\n    }\n    // run the algorithm\n    traverseRight({\n        x: 0,\n        y: 0,\n        nodes,\n        edges,\n        edgeStart: { x: 0, y: 0 },\n    });\n\n    return edges;\n};\n\n/**\n * Compute edges given a valid layout, canvasHeight, and canvasWidth\n * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth\n * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition\n * @param {Number} param.canvasHeight - Canvas height\n * @param {Number} param.canvasWidth - Canvas width\n * @returns {Object[]} - Array of computed edges\n */\nexport const computeEdges = ({\n    layout,\n    canvasHeight,\n    canvasWidth,\n}: {\n    layout?: AbsoluteBlockItem[];\n    canvasHeight: number;\n    canvasWidth: number;\n}): EdgeItem[] => {\n    if (layout === undefined) {\n        return [];\n    }\n\n    let edges = getAllEdges(layout);\n\n    // remove the computed left and right vertical canvas edges as they span the entire height of the canvas\n    edges = edges.filter((edge) => {\n        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));\n    });\n\n    // recompute the vertical canvas edges for each canvas row where the row spans the entire width of the canvas\n    computeVerticalCanvasEdges({ edges, layout, canvasWidth });\n\n    // Additionally, the top and bottom edge are there, but set to hidden\n    edges = edges.map((edge) => {\n        let isCanvasEdge = false;\n        if (\n            isTopEdge(edge) ||\n            isRightEdge(edge, canvasWidth) ||\n            isBottomEdge(edge, canvasHeight) ||\n            isLeftEdge(edge)\n        ) {\n            isCanvasEdge = true;\n        }\n        return { ...edge, isCanvasEdge };\n    });\n\n    return edges;\n};\n\n/**\n * Format edge according to a given padding and edge thickness\n * @param {Object} param - Param object containing edge, padding, and edgeThickness\n * @param {Object} param.edge - Edge object\n * @param {Number} param.padding - Layout padding\n * @param {Number} param.edgeThickness - Thickness of edge\n * @returns {Object} - Returns formatted edge object\n */\nexport const formatEdge = ({\n    edge,\n    padding = 0,\n    edgeThickness = 0,\n}: {\n    edge: EdgeItem;\n    padding?: number;\n    edgeThickness?: number;\n}): EdgeItem => {\n    // Formatted edges are centered between visualizations and respect the padding (gutter-size) between them\n    const formattedEdgeStart = { ...edge.edgeStart };\n    const formattedEdgeEnd = { ...edge.edgeEnd };\n    if (edge.orientation === 'horizontal') {\n        formattedEdgeStart.x += padding;\n        formattedEdgeStart.y -= edgeThickness / 2;\n        formattedEdgeEnd.x -= padding;\n        formattedEdgeEnd.y -= edgeThickness / 2;\n    } else {\n        formattedEdgeStart.y += padding;\n        formattedEdgeStart.x -= edgeThickness / 2;\n        formattedEdgeEnd.y -= padding;\n        formattedEdgeEnd.x -= edgeThickness / 2;\n    }\n\n    return {\n        ...edge,\n        edgeStart: formattedEdgeStart,\n        edgeEnd: formattedEdgeEnd,\n    };\n};\n\n/**\n * Format visualization according to a given padding\n * @param {Object} param - Param object containing item and padding\n * @param {Object} param.item - Visualization object\n * @param {Number} param.padding - Layout padding\n * @returns {AbsoluteBlockItem} - Returns formatted edge object\n */\nexport const applyVizPadding = ({\n    item,\n    padding = 0,\n}: {\n    item: AbsoluteBlockItem;\n    padding?: number;\n}): AbsoluteBlockItem => {\n    const { x, y, w, h } = item.position;\n    return {\n        ...item,\n        position: {\n            x: x + padding,\n            y: y + padding,\n            w: w - 2 * padding,\n            h: h - 2 * padding,\n        },\n    };\n};\n\n/**\n * Determines Upper and Lower boundaries of an edge given its visualizations around it\n * @param {Object[]} visualizations - The visualizations surrounding the edge\n * @param {Number} y - The y position of the selected edge\n * @param {Number} minHeight - minimum Item Height Value\n * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width\n * @returns {Object} - returns the boundaries in an object\n */\nexport const getVerticalBoundaries = ({\n    visualizations,\n    y,\n    minHeight,\n    isFullWidthEdge = false,\n}: {\n    visualizations: AbsoluteBlockItem[];\n    y: number;\n    minHeight: number;\n    isFullWidthEdge?: boolean;\n}): VerticalBoundaries => {\n    const boundaries = {\n        upperBoundary: Number.NEGATIVE_INFINITY,\n        lowerBoundary: Number.POSITIVE_INFINITY,\n    };\n\n    const comparePosition = (position: AbsolutePosition) => {\n        // If viz is below of the edge\n        // When the edge is a full width edge, there is no lower boundary\n        //  since dragging down increases canvas size\n        if (position.y >= y && !isFullWidthEdge) {\n            boundaries.lowerBoundary = Math.min(\n                boundaries.lowerBoundary,\n                position.y + position.h - minHeight\n            );\n        }\n        // If viz is above the edge\n        if (position.y < y) {\n            boundaries.upperBoundary = Math.max(\n                boundaries.upperBoundary,\n                position.y + minHeight\n            );\n        }\n    };\n\n    visualizations.forEach((viz) => comparePosition(viz.position));\n    return boundaries;\n};\n\n/**\n * Determines Left and Right boundaries of an edge given its visualizations around it\n * @param {Object[]} visualizations - The visualizations surrounding the edge\n * @param {Number} x - The x position of the selected edge\n * @param {Number} minWidth - minimum Item Width Value\n * @returns {Object} - returns the boundaries in an object\n */\nexport const getHorizontalBoundaries = ({\n    visualizations,\n    x,\n    minWidth,\n}: {\n    visualizations: AbsoluteBlockItem[];\n    x: number;\n    minWidth: number;\n}): HorizontalBoundaries => {\n    const boundaries = {\n        rightBoundary: Number.POSITIVE_INFINITY,\n        leftBoundary: Number.NEGATIVE_INFINITY,\n    };\n\n    const comparePosition = (position: AbsolutePosition) => {\n        if (position.x >= x) {\n            // If viz is to the right of the edge\n            boundaries.rightBoundary = Math.min(\n                boundaries.rightBoundary,\n                position.x + position.w - minWidth\n            );\n        }\n        if (position.x < x) {\n            // If viz is to the left of the edge\n            boundaries.leftBoundary = Math.max(\n                boundaries.leftBoundary,\n                position.x + minWidth\n            );\n        }\n    };\n\n    visualizations.forEach((viz) => comparePosition(viz.position));\n    return boundaries;\n};\n\n/**\n * Determines the next edge position for movement up and down of a horizontal edge\n * @param {Object} edge - the current moving edge\n * @param {Number} offset - offset to move edge\n * @param {Object} options.edgeBoundaries Object with lower/upper boundaries\n * @returns {Object} - returns edge with updated position\n */\nexport const moveHorizontalEdge = ({\n    edge,\n    offset,\n    edgeBoundaries: { upperBoundary, lowerBoundary },\n}: {\n    edge: EdgeItem;\n    offset: number;\n    edgeBoundaries: VerticalBoundaries;\n}): EdgeItem => {\n    // Update edge to either the offset value,\n    // or the defined maximum/minimum based on min viz height/width\n    const updatedY =\n        offset < 0\n            ? Math.max(upperBoundary, edge.edgeStart.y + offset)\n            : Math.min(lowerBoundary, edge.edgeStart.y + offset);\n\n    return {\n        ...edge,\n        edgeStart: {\n            x: edge.edgeStart.x,\n            y: updatedY,\n        },\n        edgeEnd: {\n            x: edge.edgeEnd.x,\n            y: updatedY,\n        },\n    };\n};\n\n/**\n * Determines the next edge position for movement left and right of a vertical edge\n * @param {Object} edge - the current moving edge\n * @param {Number} offset - offset to move edge\n * @param {Object} options.edgeBoundaries Object with left/right boundaries\n * @returns {Object} - returns edge with updated position\n */\nexport const moveVerticalEdge = ({\n    edge,\n    offset,\n    edgeBoundaries: { leftBoundary, rightBoundary },\n}: {\n    edge: EdgeItem;\n    offset: number;\n    edgeBoundaries: HorizontalBoundaries;\n}): EdgeItem => {\n    const updatedX =\n        offset < 0\n            ? Math.max(leftBoundary, edge.edgeStart.x + offset)\n            : Math.min(rightBoundary, edge.edgeStart.x + offset);\n\n    return {\n        ...edge,\n        edgeStart: {\n            x: updatedX,\n            y: edge.edgeStart.y,\n        },\n        edgeEnd: {\n            x: updatedX,\n            y: edge.edgeEnd.y,\n        },\n    };\n};\n\n/**\n * find edges that the given edge should snap to, according to the snap range\n * @param {Object} options\n * @param {Object} options.edge the edge being dragged, edge has the structure\n * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary\n * @param {Number} options.snapRange the range within which that triggers snapping\n * @returns {Object} updatedEdge and snappableEdges\n */\nexport const findSnappableEdges = ({\n    edge,\n    edges,\n    snapRange,\n}: {\n    edge: EdgeItem;\n    edges: EdgeItem[];\n    snapRange: number;\n}): { updatedEdge: EdgeItem; snappableEdges: EdgeItem[] } => {\n    const coordinate = edge.orientation === 'horizontal' ? 'y' : 'x';\n\n    const snappableEdges = edges.reduce<EdgeItem[]>(\n        (currentSnappableEdges, nextEdge) => {\n            const nextEdgeDistance = Math.abs(\n                nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n            );\n\n            // nextEdge is in range\n            if (nextEdgeDistance <= snapRange) {\n                if (currentSnappableEdges.length === 0) {\n                    return [nextEdge];\n                }\n\n                const lastEdge =\n                    currentSnappableEdges[currentSnappableEdges.length - 1];\n                const lastEdgeDistance = Math.abs(\n                    lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n                );\n\n                // find new closest snappable edge\n                if (nextEdgeDistance < lastEdgeDistance) {\n                    return [nextEdge];\n                }\n\n                // it is possible there are several snappable edges having the same x or y value\n                if (nextEdgeDistance === lastEdgeDistance) {\n                    return [...currentSnappableEdges, nextEdge];\n                }\n            }\n\n            // nextEdge is out of range\n            return [...currentSnappableEdges];\n        },\n        []\n    );\n\n    // if no snappable edge, snap to itself\n    const firstSnappableEdge =\n        snappableEdges.length > 0 ? snappableEdges[0] : edge;\n\n    return {\n        updatedEdge: {\n            ...edge,\n            edgeStart: {\n                ...edge.edgeStart,\n                [coordinate]: firstSnappableEdge.edgeStart[coordinate],\n            },\n            edgeEnd: {\n                ...edge.edgeEnd,\n                [coordinate]: firstSnappableEdge.edgeEnd[coordinate],\n            },\n        },\n        snappableEdges,\n    };\n};\n\n/**\n * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.\n * @param {Object} options\n * @param {Object} options.edge the edge being dragged\n * @param {array}  options.edges all the edges on canvas\n * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries\n * @returns {array} the edges that are within the boundary of the edge being moved\n */\nexport const findEdgesInBoundary = ({\n    edge,\n    edges,\n    edgeBoundaries,\n}: {\n    edge: EdgeItem;\n    edges: EdgeItem[];\n    edgeBoundaries: EdgeBoundaries;\n}): EdgeItem[] => {\n    const { orientation } = edge;\n\n    if (orientation === 'horizontal') {\n        return edges.filter(\n            (e) =>\n                e.orientation === 'horizontal' &&\n                e.edgeStart.y >=\n                    (edgeBoundaries as VerticalBoundaries).upperBoundary &&\n                e.edgeStart.y <=\n                    (edgeBoundaries as VerticalBoundaries).lowerBoundary &&\n                e !== edge\n        );\n    }\n    if (orientation === 'vertical') {\n        return edges.filter(\n            (e) =>\n                e.orientation === 'vertical' &&\n                e.edgeStart.x >=\n                    (edgeBoundaries as HorizontalBoundaries).leftBoundary &&\n                e.edgeStart.x <=\n                    (edgeBoundaries as HorizontalBoundaries).rightBoundary &&\n                e !== edge\n        );\n    }\n    // can't match any edge because the orientation is invalid, this shouldn't happen.\n    return [];\n};\n","module.exports = require(\"@splunk/dashboard-utils/uniqueId\");","module.exports = require(\"lodash/findLast\");","module.exports = require(\"lodash/isNumber\");","module.exports = require(\"lodash/reduce\");","import findLast from 'lodash/findLast';\nimport get from 'lodash/get';\nimport isNumber from 'lodash/isNumber';\nimport reduce from 'lodash/reduce';\nimport pullAt from 'lodash/pullAt';\nimport cloneDeep from 'lodash/cloneDeep';\nimport sortBy from 'lodash/sortBy';\nimport console from '@splunk/dashboard-utils/console';\nimport {\n    collides,\n    computeMaxHeight as utilsComputeMaxHeight,\n} from '@splunk/dashboard-utils/layout';\nimport type {\n    Coordinate,\n    ConnectedPosition,\n    AbsolutePosition,\n    Port,\n    ConnectedLineItem,\n    ConnectedLinePosition,\n    AbsoluteLayoutStructure,\n    AbsoluteBlockItem,\n    AbsoluteLayoutItem,\n    GridLayoutStructure,\n} from '@splunk/dashboard-types';\nimport { applyVizPadding, getAllEdges } from './edgeUtils';\nimport type { Offset, LineDirection, HandleDirection } from '../types';\n\n// export for gridLayout/legacyGridLayout\nexport const computeMaxHeight = utilsComputeMaxHeight;\n\n/**\n *  check if a position is valid\n * @param {Object} position\n */\nexport const isBlockPositionValid = (position: AbsolutePosition): boolean =>\n    !!(\n        position &&\n        Number.isInteger(position.x) &&\n        Number.isInteger(position.y) &&\n        Number.isInteger(position.w) &&\n        Number.isInteger(position.h)\n    );\n\nexport const isValidConnection = (\n    connection: Coordinate | ConnectedPosition\n): boolean => {\n    if (\n        'x' in connection &&\n        'y' in connection &&\n        Number.isInteger(connection.x) &&\n        Number.isInteger(connection.y)\n    ) {\n        return true;\n    }\n    if (\n        'item' in connection &&\n        'port' in connection &&\n        connection.item != null &&\n        connection.port != null\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * a line should has from and to\n */\nexport const isLinePositionValid = (\n    position: ConnectedLinePosition\n): boolean => {\n    if (position.from != null && position.to != null) {\n        return (\n            isValidConnection(position.from) && isValidConnection(position.to)\n        );\n    }\n    return false;\n};\n\n/**\n * filter invalid position\n * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)\n * @returns {Object[]} - Returns filtered array\n */\nexport const removeInvalidItems = (\n    layoutStructure: AbsoluteLayoutStructure = []\n): AbsoluteLayoutStructure =>\n    layoutStructure.filter((structure) => {\n        if (structure.type === 'line') {\n            return isLinePositionValid(structure.position);\n        }\n        return isBlockPositionValid(structure.position);\n    });\n\ninterface PositionStyle {\n    width: string;\n    height: string;\n    transform: string;\n}\n\n/**\n * convert position to css object\n */\nexport const positionToStyle = (pos: AbsolutePosition): PositionStyle => ({\n    width: `${pos.w}px`,\n    height: `${pos.h}px`,\n    transform: `translate(${pos.x}px, ${pos.y}px)`,\n});\n\n/**\n * convert position to css string\n */\nexport const positionToStyleString = (pos: AbsolutePosition): string => {\n    const style = positionToStyle(pos);\n    return reduce(style, (result, v, k) => `${result} ${k}:${v};`, '');\n};\n\n/**\n * get client position for given event with scale factor\n */\nexport const getClientPosition = (\n    e: {\n        clientX: number;\n        clientY: number;\n    },\n    scaleFactor = 1\n): Coordinate => ({\n    x: Math.round(e.clientX / scaleFactor),\n    y: Math.round(e.clientY / scaleFactor),\n});\n\n/**\n * compute offset from 2 positions\n */\nexport const getOffset = (\n    currentPosition: Coordinate,\n    startPosition: Coordinate\n): Offset => ({\n    offsetX: currentPosition.x - startPosition.x,\n    offsetY: currentPosition.y - startPosition.y,\n});\n\n/**\n * check if a given offset can be considered as 'move'\n * @param {Object} config\n * @param {Number} config.offsetX\n * @param {Number} config.offsetY\n */\nexport const considerMoved = ({\n    offsetX,\n    offsetY,\n}: {\n    offsetX: number;\n    offsetY: number;\n}): boolean => offsetX !== 0 || offsetY !== 0;\n\n/**\n * return a boundary for 2 positions\n * @param {Coordinate} startPos\n * @param {Coordinate} endPos\n */\nexport const positionsToBoundary = (\n    startPos: Coordinate,\n    endPos: Coordinate\n): AbsolutePosition => ({\n    x: Math.min(startPos.x, endPos.x),\n    y: Math.min(startPos.y, endPos.y),\n    w: Math.abs(startPos.x - endPos.x),\n    h: Math.abs(startPos.y - endPos.y),\n});\n\n/**\n * filter abs items within a boundary\n * @param {Array} items\n * @param {Object} boundary\n */\nexport const filterBlockItemsByBoundary = (\n    items: AbsoluteBlockItem[],\n    boundary: AbsolutePosition\n): AbsoluteBlockItem[] =>\n    items.filter((item) => {\n        const itemPosition = item.position;\n        return !(\n            boundary.x > itemPosition.x + itemPosition.w ||\n            boundary.x + boundary.w < itemPosition.x ||\n            boundary.y > itemPosition.y + itemPosition.h ||\n            boundary.y + boundary.h < itemPosition.y\n        );\n    });\n\n/**\n * find the first item that contains the pos.\n */\nexport const findTopBlockItemByPosition = (\n    items: AbsoluteBlockItem[],\n    pos: Coordinate,\n    padding = 0\n): AbsoluteBlockItem | undefined =>\n    findLast(items, (item) => {\n        const itemPosition = padding\n            ? applyVizPadding({ item, padding }).position\n            : item.position;\n        return (\n            itemPosition.x <= pos.x &&\n            itemPosition.x + itemPosition.w >= pos.x &&\n            itemPosition.y <= pos.y &&\n            itemPosition.y + itemPosition.h >= pos.y\n        );\n    });\n\n/**\n * Compute the new offset so current + new offset will be the multiple of snapTo unit\n * For examples:\n * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5\n * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2\n * (5, 12, 5) => 10\n * (5, 13, 5) => 15\n * @param {Number} current\n * @param {Number} offset\n * @param {Number} snapTo\n */\nexport const snapOffset = (\n    current: number,\n    offset: number,\n    snapTo: number\n): number => {\n    // return a new offset\n    const remainder = (current + offset) % snapTo;\n    const newOffset =\n        remainder > snapTo / 2\n            ? offset + (snapTo - remainder)\n            : offset - remainder;\n    return newOffset;\n};\n\ninterface SnapOffsetToXYArgs {\n    position: AbsolutePosition;\n    offset: Offset;\n    gridWidth: number;\n    gridHeight: number;\n    spacing?: number;\n    padding?: number;\n}\n\n/**\n * snap item with its top-left corner (represent by x, y)\n * @param {Object} position\n * @param {Object} offset\n * @param {Number} gridWidth\n * @param {Number} gridHeight\n * @param {Number} spacing\n */\nexport const snapOffsetToXY = ({\n    position,\n    offset,\n    gridWidth,\n    gridHeight,\n    spacing = 0,\n    padding = 0,\n}: SnapOffsetToXYArgs): Offset => {\n    let { offsetX, offsetY } = offset;\n    offsetX = snapOffset(position.x, offsetX, gridWidth + spacing) + padding;\n    offsetY = snapOffset(position.y, offsetY, gridHeight + spacing) + padding;\n    return {\n        offsetX,\n        offsetY,\n    };\n};\n\ntype SnapOffsetToWHArgs = SnapOffsetToXYArgs;\n\n/**\n * snap item with its size (represent by w, h)\n * @param {Object} position\n * @param {Object} offset\n * @param {Number} gridWidth\n * @param {Number} gridHeight\n * @param {Number} spacing\n */\nexport const snapOffsetToWH = ({\n    position,\n    offset,\n    gridWidth,\n    gridHeight,\n    spacing = 0,\n    padding = 0,\n}: SnapOffsetToWHArgs): Offset => {\n    let { offsetX, offsetY } = offset;\n    offsetX =\n        snapOffset(position.x + position.w, offsetX, gridWidth + spacing) +\n        (padding - spacing);\n    offsetY =\n        snapOffset(position.y + position.h, offsetY, gridHeight + spacing) +\n        (padding - spacing);\n    return {\n        offsetX,\n        offsetY,\n    };\n};\n\ninterface UpdateBlockItemSizeArgs {\n    item: AbsoluteBlockItem;\n    offset: Offset;\n    dir: HandleDirection;\n    options?: {\n        minWidth?: number;\n        minHeight?: number;\n    };\n}\n\n/**\n * Mutate item coordinates and/or dimensions.\n * This mutation's new dimensions and coordinates are bounded within the original block item real estate.\n * @param {Object} item\n * @param {Object} offset\n * @param {String} dir Cartesian direction to shift item towards.\n * @param {Object} options\n */\nexport const updateBlockItemSize = ({\n    item,\n    offset,\n    dir,\n    options: { minWidth = 0, minHeight = 0 } = {},\n}: UpdateBlockItemSizeArgs): AbsoluteBlockItem => {\n    const { w, h } = item.position;\n    const { offsetX, offsetY } = offset;\n    const updatedPosition = { ...item.position };\n\n    // resizing from north\n    if (['n', 'ne', 'nw'].includes(dir)) {\n        updatedPosition.y += Math.min(h - minHeight, offsetY);\n        updatedPosition.h -= offsetY;\n    }\n    // resizing from the south\n    if (['s', 'se', 'sw'].includes(dir)) {\n        updatedPosition.h += offsetY;\n    }\n    // resizing from the east\n    if (['e', 'ne', 'se'].includes(dir)) {\n        updatedPosition.w += offsetX;\n    }\n    // resizing from west\n    if (['w', 'nw', 'sw'].includes(dir)) {\n        updatedPosition.x += Math.min(w - minWidth, offsetX);\n        updatedPosition.w -= offsetX;\n    }\n\n    updatedPosition.w = Math.max(minWidth, updatedPosition.w);\n    updatedPosition.h = Math.max(minHeight, updatedPosition.h);\n    return {\n        ...item,\n        position: updatedPosition,\n    };\n};\n\nexport const updateBlockItemPosition = (\n    item: AbsoluteBlockItem,\n    offset: Offset\n): AbsoluteBlockItem => {\n    const { offsetX, offsetY } = offset;\n    return {\n        ...item,\n        position: {\n            ...item.position,\n            x: item.position.x + offsetX,\n            y: item.position.y + offsetY,\n        },\n    };\n};\n\n/**\n * create offset based on dir, x and y\n * @method createOffset\n * @param {String} dir\n * @param {Number} x\n * @param {Number} y\n * @returns {Object} offset\n */\nexport const createOffset = (\n    dir: HandleDirection,\n    x: number,\n    y: number\n): Offset => {\n    switch (dir) {\n        case 'n':\n            return {\n                offsetX: 0,\n                offsetY: -y,\n            };\n        case 's':\n            return {\n                offsetX: 0,\n                offsetY: y,\n            };\n        case 'w':\n            return {\n                offsetX: -x,\n                offsetY: 0,\n            };\n        case 'e':\n            return {\n                offsetX: x,\n                offsetY: 0,\n            };\n        default:\n            return {\n                offsetX: 0,\n                offsetY: 0,\n            };\n    }\n};\n\n/**\n * compute scale factor\n * @param {Number} actualWidth\n * @param {Number} canvasWidth\n */\n\nexport const computeScaleToFit = (\n    actualWidth: number,\n    canvasWidth: number\n): number => {\n    if (\n        !(\n            isNumber(canvasWidth) &&\n            canvasWidth > 0 &&\n            isNumber(actualWidth) &&\n            actualWidth > 0\n        )\n    ) {\n        console.warn(\n            `Failed to calculate layout scale: containerWidth=${actualWidth}, width=${canvasWidth}; falling back to scale=1`\n        );\n        return 1;\n    }\n    return actualWidth / canvasWidth;\n};\n\n/**\n *\n * @param {Array} items\n * @param {Number} from  target item index\n * @param {Number} to    where does this item move to\n */\nexport const moveLayoutItem = (\n    items: AbsoluteLayoutItem[],\n    from: number,\n    to: number\n): AbsoluteLayoutItem[] => {\n    const structure = [...items];\n    const removed = pullAt(structure, [from]);\n    structure.splice(to, 0, removed[0]);\n    return structure;\n};\n\ninterface IsLineConnectedArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n}\n\n/**\n * check if a line is connected\n */\nexport const isLineConnected = ({ line, dir }: IsLineConnectedArgs): boolean =>\n    'item' in line.position[dir];\n\ninterface DisconnectLineArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    absPos: Coordinate;\n}\n\n/**\n *  disconnect a line from item and set it to abs position\n */\nexport const disconnectLine = ({\n    line,\n    dir,\n    absPos,\n}: DisconnectLineArgs): ConnectedLineItem => {\n    const updatePosition = {\n        ...line.position,\n        [dir]: {\n            ...absPos,\n        },\n    };\n    return {\n        ...line,\n        position: updatePosition,\n    };\n};\n\ninterface ConnectLineArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    itemId: string;\n    port: Port;\n}\n\n/**\n * connect a line with an item and port\n */\nexport const connectLine = ({\n    line,\n    dir,\n    itemId,\n    port,\n}: ConnectLineArgs): ConnectedLineItem => {\n    const { position } = line;\n    const updatedPosition = {\n        ...position,\n        [dir]: {\n            item: itemId,\n            port,\n        },\n    };\n    return {\n        ...line,\n        position: updatedPosition,\n    };\n};\n\ninterface UpdateLineAbsPositionArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    offset: Offset;\n}\n\n/**\n * update line absolute position\n */\nexport const updateLineAbsPosition = ({\n    line,\n    dir,\n    offset,\n}: UpdateLineAbsPositionArgs): ConnectedLineItem => {\n    const { offsetX, offsetY } = offset;\n    const { position } = line;\n\n    if (!('x' in position[dir])) {\n        throw Error(\n            `line item ${line.item} does not have x value for its direction ${dir}`\n        );\n    }\n\n    if (!('y' in position[dir])) {\n        throw Error(\n            `line item ${line.item} does not have y value for its direction ${dir}`\n        );\n    }\n\n    const { x, y } = position[dir] as Coordinate;\n\n    return {\n        ...line,\n        position: {\n            ...position,\n            [dir]: {\n                x: x + offsetX,\n                y: y + offsetY,\n            },\n        },\n    };\n};\n\n/**\n *\n * @param {Object} from\n * @param {Object} to\n */\nexport const computeLineBoxPosition = (\n    from: Coordinate,\n    to: Coordinate\n): Coordinate => ({\n    x: Math.min(from.x, to.x),\n    y: Math.min(from.y, to.y),\n});\n\n/**\n *\n * @param {Object} from\n * @param {Object} to\n * @param {Object} box\n */\nexport const computeLineRelativePosition = (\n    from: Coordinate,\n    to: Coordinate,\n    box: Coordinate\n): {\n    from: {\n        x: number;\n        y: number;\n    };\n    to: {\n        x: number;\n        y: number;\n    };\n} => ({\n    from: {\n        x: from.x - box.x,\n        y: from.y - box.y,\n    },\n    to: {\n        x: to.x - box.x,\n        y: to.y - box.y,\n    },\n});\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport const bottom = (layout: AbsoluteBlockItem[]): number => {\n    return layout.length > 0\n        ? Math.max(\n              ...layout.map(({ position }) => {\n                  return position.y + position.h;\n              })\n          )\n        : 1;\n};\n\n/**\n * Before moving item down, it will check if the movement will cause collisions\n * and move those items down before.\n * @method resolveCompactionCollision\n * @param {Array} layout\n * @param {Object} itemToMove current item which need to be moved to solve the collision\n * @param {Number} moveToCoord the destination coordination of y axis\n * @returns {Array} [newLayout, newItem]\n */\nexport const resolveCompactionCollision = (\n    layout: AbsoluteBlockItem[],\n    itemToMove: AbsoluteBlockItem,\n    moveToCoord: number\n): [AbsoluteBlockItem[], AbsoluteBlockItem] => {\n    let axisVal = itemToMove.position.y;\n    axisVal += 1;\n    let newLayout = cloneDeep(layout);\n    const itemIndex = newLayout.findIndex(\n        (layoutItem) => layoutItem.item === itemToMove.item\n    );\n    const newItem = cloneDeep(itemToMove);\n    newItem.position.y = axisVal;\n    // Go through each item we collide with.\n    // If there is a collision, we will move this collision down, otherwise set y = moveToCoord and return\n    for (let i = itemIndex + 1; i < layout.length; i += 1) {\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (newLayout[i].position.y > newItem.position.y + newItem.position.h) {\n            break;\n        }\n        if (collides(newItem, newLayout[i])) {\n            [newLayout, newLayout[i]] = resolveCompactionCollision(\n                layout,\n                layout[i],\n                moveToCoord + newItem.position.h\n            );\n        }\n    }\n\n    newItem.position.y = moveToCoord;\n    newLayout[itemIndex] = newItem;\n    return [newLayout, newItem];\n};\n\n/**\n * get all collisions given an item and current layout\n * @method getAllCollisions\n * @param {Array} layout\n * @param {Object} layoutItem\n * @returns {Array} sorted layout\n */\nexport const getAllCollisions = (\n    layout: AbsoluteBlockItem[],\n    layoutItem: AbsoluteBlockItem\n): AbsoluteBlockItem[] => {\n    return layout.filter((item) => collides(item, layoutItem));\n};\n\ninterface CloneBlockItemArgs {\n    id: string;\n    item: AbsoluteBlockItem;\n    offsetMultiplier: number;\n}\n\n/**\n * clone a block item\n * @param {Number} id\n * @param {Object} item\n * @param {Number} offsetMultiplier\n */\nexport const cloneBlockItem = ({\n    id,\n    item,\n    offsetMultiplier,\n}: CloneBlockItemArgs): AbsoluteBlockItem => {\n    const copiedPosition = item.position;\n    return {\n        ...item,\n        item: id,\n        position: {\n            x: copiedPosition.x + 20 * offsetMultiplier,\n            y: copiedPosition.y + 20 * offsetMultiplier,\n            w: copiedPosition.w,\n            h: copiedPosition.h,\n        },\n    };\n};\n\ninterface CloneLineArgs {\n    id: string;\n    item: ConnectedLineItem;\n    offsetMultiplier: number;\n}\n\n/**\n * clone an line, it assume the line is not connected\n * @param {Number} id\n * @param {Object} item\n * @param {Number} offsetMultiplier\n */\nexport const cloneLine = ({\n    id,\n    item,\n    offsetMultiplier,\n}: CloneLineArgs): ConnectedLineItem => {\n    const copiedPosition = item.position;\n    return {\n        ...item,\n        item: id,\n        position: {\n            from: {\n                x:\n                    (copiedPosition.from as Coordinate).x +\n                    20 * offsetMultiplier,\n                y:\n                    (copiedPosition.from as Coordinate).y +\n                    20 * offsetMultiplier,\n            },\n            to: {\n                x: (copiedPosition.to as Coordinate).x + 20 * offsetMultiplier,\n                y: (copiedPosition.to as Coordinate).y + 20 * offsetMultiplier,\n            },\n        },\n    };\n};\n\ninterface ShiftViewportOnZoomArgs {\n    scrollLeft: number;\n    scrollTop: number;\n    offsetWidth: number;\n    offsetHeight: number;\n    scaleRatio: number;\n}\n\n/**\n * Calculates new viewport position after a zoom event to keep the previous central point in the center of\n * the scaled canvas. See MR #2030 for algorithm details.\n * @param {Number} scrollLeft viewport left edge offset relative to canvas\n * @param {Number} scrollTop viewport top edge offset relative to canvas\n * @param {Number} offsetWidth viewport width\n * @param {Number} offsetHeight viewport height\n * @param {Number} scaleRatio new scale to old scale ratio\n * @returns {Object} object containing new scrollLeft and scrollTop values\n */\nexport const shiftViewportOnZoom = ({\n    scrollLeft,\n    scrollTop,\n    offsetWidth,\n    offsetHeight,\n    scaleRatio,\n}: ShiftViewportOnZoomArgs): {\n    scrollLeft: number;\n    scrollTop: number;\n} => {\n    const middleOffsetWidth = offsetWidth / 2;\n    const middleOffsetHeight = offsetHeight / 2;\n    return {\n        scrollLeft:\n            (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,\n        scrollTop:\n            (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight,\n    };\n};\n\n/**\n * return position relative to the canvas rect\n */\nexport const computeRelativePosition = (\n    e: {\n        clientX: number;\n        clientY: number;\n    },\n    canvasRef: unknown,\n    scale = 1\n): Coordinate => {\n    const pos = getClientPosition(e, scale);\n    const canvasDomNode = get(canvasRef, ['current']);\n    const rect = canvasDomNode && canvasDomNode.getBoundingClientRect();\n    if (pos && rect) {\n        return {\n            x: pos.x - rect.left / scale,\n            y: pos.y - rect.top / scale,\n        };\n    }\n    return pos;\n};\n\n/**\n * Scales a GridLayout by stretching the width of each item by the scale factor\n * @param {AbsoluteBlockItem[]} items items to scale\n * @param {Number} scale how much to scale\n */\nexport const scaleGridLayoutStructureByWidth = ({\n    layout,\n    scale = 1,\n}: {\n    layout: GridLayoutStructure;\n    scale?: number;\n}): AbsoluteBlockItem[] => {\n    if (scale === 1) {\n        return layout;\n    }\n\n    // Compute the edges of the existing layout. Since we're scaling\n    // just the X and width we only care about vertical edges.\n    const edges = getAllEdges(layout);\n    const verticalEdges = sortBy(\n        edges.filter((edge) => edge.orientation === 'vertical'),\n        ['edgeStart.x']\n    );\n\n    // Scale the vertical edges and than align the\n    // left and right items to the scaled edge position\n    const newLayout: AbsoluteBlockItem[] = [];\n    verticalEdges.forEach((edge) => {\n        const {\n            visualizations,\n            edgeStart: { x },\n        } = edge;\n        const scaledEdgeX = Math.round(x * scale);\n        const left = visualizations.filter((viz) => viz.position.x < x);\n        const right = visualizations.filter((viz) => viz.position.x >= x);\n\n        // Update the Width of the layout items using the difference between the\n        // newly scaled edge and the existing x\n        left.forEach((layoutItem) => {\n            const newLayoutItem = newLayout.find(\n                ({ item: id }) => layoutItem.item === id\n            );\n\n            if (newLayoutItem) {\n                newLayoutItem.position.w =\n                    scaledEdgeX - newLayoutItem.position.x;\n            }\n        });\n\n        // Since we walk the edges from the left to the right we\n        // ALWAYS have to create the new layout item here but won't\n        // ever need to update it.\n        right.forEach((layoutItem) => {\n            newLayout.push({\n                ...layoutItem,\n                position: {\n                    ...layoutItem.position,\n                    x: scaledEdgeX,\n                },\n            });\n        });\n    });\n\n    return newLayout;\n};\n","module.exports = require(\"lodash/pullAt\");","module.exports = require(\"lodash/cloneDeep\");","module.exports = require(\"lodash/sortBy\");","module.exports = require(\"prop-types\");","module.exports = require(\"@splunk/dashboard-utils/console\");","/* eslint-disable react/no-unused-prop-types,react/prefer-stateless-function, no-unused-vars */\nimport { Component } from 'react';\nimport T from 'prop-types';\n\nconst noop = () => {};\nclass BaseLayout extends Component {\n    static propTypes = {\n        /**\n         * dashboard mode\n         */\n        mode: T.string,\n        /**\n         * whether gridlines should be displayed in edit mode\n         */\n        showGrid: T.bool,\n        /**\n         * layout formatting options\n         */\n        options: T.object,\n        /**\n         * layout structure\n         */\n        layoutStructure: T.arrayOf(T.any),\n        /**\n         * container width in pixel\n         */\n        containerWidth: T.number,\n        /**\n         * container height in pixel\n         */\n        containerHeight: T.number,\n        /**\n         * list of selected items\n         */\n        selectedItems: T.arrayOf(\n            T.shape({ id: T.string, type: T.oneOf(['block', 'line', 'input']) })\n        ),\n        /**\n         * layout item render prop\n         */\n        renderLayoutItem: T.func,\n        /**\n         * callback when items are selected\n         */\n        onLayoutItemsSelect: T.func,\n        /**\n         * callback to trigger event\n         */\n        onEventTrigger: T.func,\n        /**\n         * callback when layout structure changed\n         */\n        onLayoutStructureChange: T.func,\n        /**\n         * layoutApi ref\n         */\n        layoutApiRef: T.func,\n        /**\n         * action menus render prop\n         */\n        renderActionMenus: T.func,\n    };\n\n    static defaultProps = {\n        mode: 'view',\n        options: {},\n        showGrid: true,\n        layoutStructure: [],\n        selectedItems: [],\n        renderLayoutItem: noop,\n        renderActionMenus: noop,\n        onEventTrigger: noop,\n        onLayoutStructureChange: noop,\n        onLayoutItemsSelect: noop,\n        layoutApiRef: noop,\n    };\n\n    render() {\n        return null;\n    }\n}\n\nexport default BaseLayout;\n","module.exports = require(\"@splunk/dashboard-utils/layout\");","module.exports = require(\"@splunk/themes/mixins\");","module.exports = require(\"@splunk/dashboard-ui/customThemeVariables\");","import React, { useMemo } from 'react';\nimport styled from 'styled-components';\nimport { reset } from '@splunk/themes/mixins';\nimport type {\n    GridLayoutStructure,\n    GridLayoutOptions,\n} from '@splunk/dashboard-types';\nimport { customThemeVariables } from '@splunk/dashboard-ui/customThemeVariables';\nimport BaseLayout from './BaseLayout';\nimport GridItem from './components/GridItem';\nimport { gridLayoutOptions } from './DefaultOptions';\nimport { removeInvalidItems, computeMaxHeight } from './utils/layoutUtils';\nimport { getCSSGridTemplate } from './utils/gridLayoutViewerUtils';\nimport type { RenderLayoutItem } from './types';\n\ninterface GridCanvasProps {\n    height: number;\n    gutterSize: number;\n    colTemplate: string;\n    rowTemplate: string;\n}\n\nconst GridCanvas = styled.div<GridCanvasProps>`\n    ${reset('grid')};\n    height: ${(props) => props.height}px;\n    width: 100%;\n    padding: ${(props) => props.gutterSize / 2}px;\n    box-sizing: border-box;\n    grid-template-columns: ${(props) => props.colTemplate};\n    grid-template-rows: ${(props) => props.rowTemplate};\n    gap: ${(props) => props.gutterSize}px;\n    background: ${customThemeVariables.dashboardBackgroundColor};\n`;\nGridCanvas.displayName = 'GridCanvas';\n\ninterface GridLayoutViewerProps {\n    /*\n     * The grid layout structure to render.\n     */\n    layoutStructure: GridLayoutStructure;\n    /*\n     * A method to render the items in the layout structure.\n     */\n    renderLayoutItem: RenderLayoutItem;\n    /*\n     * The options for the grid layout.\n     */\n    options: GridLayoutOptions;\n}\n\nconst GridLayoutViewer = ({\n    layoutStructure,\n    renderLayoutItem,\n    options,\n}: GridLayoutViewerProps): JSX.Element => {\n    const { width, gutterSize } = {\n        ...gridLayoutOptions,\n        ...options,\n    };\n\n    const { height, gridItems, rowTemplate, colTemplate } = useMemo(() => {\n        const filteredStructure = removeInvalidItems(\n            layoutStructure\n        ) as GridLayoutStructure;\n        const structureHeight = computeMaxHeight(filteredStructure);\n\n        const { gridRowTemplate, gridColTemplate } = getCSSGridTemplate({\n            layoutStructure: filteredStructure,\n            width,\n            height: structureHeight,\n        });\n\n        const items = filteredStructure.map(({ item: itemId }) => (\n            <GridItem\n                itemId={itemId}\n                key={itemId}\n                renderLayoutItem={renderLayoutItem}\n            />\n        ));\n\n        return {\n            height: structureHeight,\n            gridItems: items,\n            rowTemplate: gridRowTemplate,\n            colTemplate: gridColTemplate,\n        };\n    }, [layoutStructure, width, renderLayoutItem]);\n\n    return (\n        <GridCanvas\n            data-test=\"grid-layout-canvas\"\n            data-layout-type=\"grid\"\n            height={height}\n            gutterSize={gutterSize}\n            rowTemplate={rowTemplate}\n            colTemplate={colTemplate}\n        >\n            {gridItems}\n        </GridCanvas>\n    );\n};\n\nGridLayoutViewer.propTypes = {\n    ...BaseLayout.propTypes,\n};\n\nGridLayoutViewer.defaultProps = {\n    ...BaseLayout.defaultProps,\n};\n\nexport default GridLayoutViewer;\n","import React from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\nimport type { RenderLayoutItem } from '../types';\n\ninterface GridDivProps {\n    id: string;\n}\n\nconst GridDiv = styled.div<GridDivProps>`\n    height: 100%;\n    width: 100%;\n    grid-row: ${(props) => props.id}-start / ${(props) => props.id}-end;\n    grid-column: ${(props) => props.id}-start / ${(props) => props.id}-end;\n    background: transparent;\n`;\n\ninterface GridItemProps {\n    /*\n     * The ID of the item being rendered.\n     */\n    itemId: string;\n    /*\n     * A method to render the items in the layout structure.\n     */\n    renderLayoutItem: RenderLayoutItem;\n}\n\n/**\n * Item positioned on a grid.\n */\nconst GridItem = ({ itemId, renderLayoutItem }: GridItemProps): JSX.Element => (\n    <GridDiv id={itemId} data-test=\"grid-item\">\n        {renderLayoutItem(itemId, { width: '100%', height: '100%' }, 'block')}\n    </GridDiv>\n);\n\nGridItem.propTypes = {\n    itemId: T.string.isRequired,\n    renderLayoutItem: T.func.isRequired,\n};\n\nexport default GridItem;\n","import type { GridLayoutStructure } from '@splunk/dashboard-types';\n\ninterface GridLine {\n    pos: number;\n    names: string[];\n}\n\n/**\n * Returns a template for the rows/columns of a CSS grid given a list of grid lines along an axis\n * with range [0, axisLength].\n */\nconst getTemplateItems = (\n    [currGridLine, nextGridLine, ...rest]: GridLine[],\n    axisLength: number,\n    templateItems: string[] = []\n): string => {\n    // add the names for the current grid line\n    templateItems.push(`[${currGridLine.names.join(' ')}]`);\n\n    if (!nextGridLine) {\n        return templateItems.join(' ');\n    }\n\n    // add the space between the current grid line and the next grid line\n    const gridTrackWidth = Math.round(\n        ((nextGridLine.pos - currGridLine.pos) / axisLength) * 100\n    );\n    templateItems.push(`minmax(0, ${gridTrackWidth}fr)`);\n\n    return getTemplateItems([nextGridLine, ...rest], axisLength, templateItems);\n};\n\n/**\n * Wrapper function for getTemplateItems.\n */\nconst getTemplateItemsFromGridLines = (\n    gridLines: GridLine[],\n    axisLength: number\n): string => {\n    if (gridLines.length === 0) {\n        return '';\n    }\n    return getTemplateItems(gridLines, axisLength);\n};\n\ninterface GetCSSGridTemplateArgs {\n    layoutStructure: GridLayoutStructure;\n    width: number;\n    height: number;\n}\n\n/**\n * Returns strings to be used as the `grid-template-columns` and `grid-layout-rows` properties of\n * a CSS Grid. Derived from the layout structure.\n */\nexport const getCSSGridTemplate = ({\n    layoutStructure,\n    width,\n    height,\n}: GetCSSGridTemplateArgs): {\n    gridRowTemplate: string;\n    gridColTemplate: string;\n} => {\n    const xCoords: string[][] = [];\n    const yCoords: string[][] = [];\n\n    layoutStructure.forEach(({ position: { x, y, w, h }, item }) => {\n        // create an empty list of breakpoints for a given point if it does not exist\n        xCoords[x] = xCoords[x] ?? [];\n        xCoords[x + w] = xCoords[x + w] ?? [];\n        yCoords[y] = yCoords[y] ?? [];\n        yCoords[y + h] = yCoords[y + h] ?? [];\n\n        // add breakpoint to the list of breakpoints for a given point\n        xCoords[x].push(`${item}-start`);\n        xCoords[x + w].push(`${item}-end`);\n        yCoords[y].push(`${item}-start`);\n        yCoords[y + h].push(`${item}-end`);\n    });\n\n    const xGridLines = Object.entries(xCoords).map(([pos, names]) => ({\n        pos: Number(pos),\n        names,\n    }));\n    const yGridLines = Object.entries(yCoords).map(([pos, names]) => ({\n        pos: Number(pos),\n        names,\n    }));\n\n    const gridRowTemplate = getTemplateItemsFromGridLines(yGridLines, height);\n    const gridColTemplate = getTemplateItemsFromGridLines(xGridLines, width);\n\n    return { gridRowTemplate, gridColTemplate };\n};\n","import {\n    DEFAULT_CANVAS_WIDTH,\n    DEFAULT_CANVAS_HEIGHT,\n} from '@splunk/dashboard-utils/layout';\nimport type {\n    AbsoluteLayoutOptions,\n    GridLayoutOptions,\n} from '@splunk/dashboard-types';\n\nexport const absoluteLayoutOptions: Required<\n    Pick<AbsoluteLayoutOptions, 'width' | 'height' | 'display'>\n> = {\n    width: DEFAULT_CANVAS_WIDTH,\n    height: DEFAULT_CANVAS_HEIGHT,\n    display: 'actual-size',\n};\n\nexport const gridLayoutOptions: Required<\n    Pick<GridLayoutOptions, 'width' | 'gutterSize'>\n> = {\n    width: DEFAULT_CANVAS_WIDTH,\n    gutterSize: 8,\n};\n"],"sourceRoot":""}