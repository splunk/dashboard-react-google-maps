{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"react\"","webpack:///external \"@babel/runtime/regenerator\"","webpack:///external \"@babel/runtime/helpers/slicedToArray\"","webpack:///./src/Downloader.ts","webpack:///external \"@babel/runtime/helpers/getPrototypeOf\"","webpack:///external \"@babel/runtime/helpers/classCallCheck\"","webpack:///./src/FileDownloader.tsx","webpack:///external \"@babel/runtime/helpers/createClass\"","webpack:///external \"@splunk/ui-utils/i18n\"","webpack:///external \"@babel/runtime/helpers/inherits\"","webpack:///external \"@babel/runtime/helpers/possibleConstructorReturn\""],"names":[],"mappings":"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","file":"FileDownloader.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 45);\n","module.exports = require(\"react\");","module.exports = require(\"@babel/runtime/regenerator\");","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","import { _ } from '@splunk/ui-utils/i18n';\nimport ImageRegistry from '@splunk/visualization-context/ImageRegistry';\n\nexport interface DownloadProgress {\n    bytesDownloaded: number;\n    contentLength?: number;\n    message: string;\n}\nexport interface IDownloader {\n    downloadWithProgress(\n        url: string,\n        complete: (svg: string) => void,\n        progress?: (p: DownloadProgress) => void,\n        error?: (msg: string, error?: Error) => void\n    ): void;\n}\n\nexport const b64DecodeUnicode = (base64Data: string): string => {\n    //from bytestream, to percent-encoding, to original string.\n    return decodeURIComponent(\n        atob(base64Data)\n            .split('')\n            .map((c: string): string => {\n                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n            })\n            .join('')\n    );\n};\n\nexport class ImageRegistryFetcher implements IDownloader {\n    context: ImageRegistry;\n    constructor(context?: ImageRegistry) {\n        this.context = context;\n    }\n    async downloadWithProgress(\n        url: string,\n        complete: (svg: string) => void,\n        progress?: (p: DownloadProgress) => void,\n        error?: (msg: string, error?: Error) => void\n    ): Promise<void> {\n        const imageRegistry = this.context;\n        if (!imageRegistry) {\n            error(_('Missing Image Context'));\n        }\n        try {\n            const imageData = await imageRegistry.getByURL(url);\n            const [mime, svgBase64] = imageData.dataURI.split('base64,');\n            if (mime && mime.toLowerCase().indexOf('image/svg+xml') > -1) {\n                complete(b64DecodeUnicode(svgBase64));\n            } else {\n                error(_(`Unsupported MIME type ${mime} for url ${url}`));\n            }\n        } catch (e) {\n            error(_(`Error retrieving ${url} from Image Registry, error was '${e.message}'`), e);\n        }\n    }\n}\n\nexport class URLDownloader implements IDownloader {\n    downloadWithProgress(\n        url: string,\n        complete: (svg: string) => void,\n        progress?: (p: DownloadProgress) => void,\n        error?: (msg: string, error?: Error) => void\n    ): void {\n        // Step 1: fetch content from URL, get reader\n        fetch(url)\n            .then(\n                async (response: Response): Promise<void> => {\n                    if (!response.ok) {\n                        const msg = `Fetch not Ok for ${url}, status was '${response.statusText}'`;\n                        console.warn(msg);\n                        error(msg);\n                        return;\n                    }\n                    const reader = response.body.getReader();\n\n                    // Step 2: get total length\n                    const contentLength = +response.headers.get('Content-Length');\n\n                    // Step 3: read the data\n                    let bytesDownloaded = 0; // length at the moment\n                    const chunks = []; // array of received binary chunks (comprises the body)\n                    let done = false;\n                    while (!done) {\n                        const res = await reader.read();\n                        done = res.done;\n                        const { value } = res;\n                        if (value) {\n                            chunks.push(value);\n                            bytesDownloaded += value.length;\n                            progress({\n                                //call the progress callback...can enable the UI to show progress\n                                bytesDownloaded,\n                                contentLength,\n                                message: `Received ${bytesDownloaded} bytes of ${\n                                    contentLength || 'unknown size'\n                                }`,\n                            });\n                        }\n                    }\n\n                    // Step 4: concatenate chunks into single Uint8Array\n                    const chunksAll = new Uint8Array(bytesDownloaded);\n                    let position = 0;\n                    for (const chunk of chunks) {\n                        chunksAll.set(chunk, position);\n                        position += chunk.length;\n                    }\n\n                    progress({\n                        bytesDownloaded,\n                        contentLength,\n                        message: 'decoding chunks',\n                    });\n\n                    // Step 5: decode into a string\n                    const svg = new TextDecoder('utf-8').decode(chunksAll);\n                    complete(svg); //show the downloaded svg back to the caller via its completion callback\n                }\n            )\n            .catch((e: Error): void => {\n                console.error(e.toString());\n                error(`Fetch error for '${url}', error was '${e.toString()}'`, e); // call the supplied error handling function\n            });\n    }\n}\n\nexport default class Downloader {\n    private downloaders = {};\n    constructor(downloaders: { [protocol: string]: IDownloader }) {\n        this.downloaders = downloaders;\n    }\n\n    downloadWithProgress(\n        url: string,\n        complete: (svg: string) => void,\n        progress?: (p: DownloadProgress) => void,\n        error?: (msg: string, error?: Error) => void\n    ): void {\n        // url is the following:\n        // data:image/svg+xml;base64....\n        // http://\n        // https://\n        // local://\n        // or otherwise return errors\n\n        let protocol = '';\n        let isUrl = true;\n        try {\n            protocol = new URL(url).protocol;\n        } catch (e) {\n            isUrl = false;\n        }\n\n        if (isUrl) {\n            try {\n                const [type = ''] = protocol.split(':');\n                if (this.downloaders[type]) {\n                    // data, http(s), local....\n                    this.downloaders[type].downloadWithProgress(url, complete, progress, error);\n                } else {\n                    // unknown type\n                    error(`Unsupported URL protocol '${type}' for SVG download: ${url}`);\n                }\n            } catch (e) {\n                error(`Unexpected error downloading SVG: ${e.message}`);\n            }\n        } else {\n            // the url might be literal content. <svg>...</svg>. This is kindof a hack where if you pass the downloader something\n            // that is literal content, it will just return the content. Makes the code flow cleaner in layers above.\n            complete(url);\n        }\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","import * as React from 'react';\nimport Downloader, { IDownloader, DownloadProgress } from './Downloader';\n\n/**\n * The FileDownloader is passed a URL string, and render prop which allows a caller to control what is rendered\n * When the file is completely downloaded. This FileDownloader also displays basic text showing download progress.\n * If you want to supply your own custom renderer or progress and error you can do so as well.\n *\n */\nexport interface FileDownloaderProps {\n    /**\n     * The URL to download\n     */\n    url: string;\n    /**\n     * The render function that will render when the content is downloaded\n     * @returns {React.Component}\n     */\n    renderContent: (content: string) => React.ReactElement;\n    /**\n     * An optional function to render progress (defaults to basic text display of progress)\n     * @param {DownloadProgress} progress\n     * @returns {React.Component}\n     */\n    renderProgress?: (progress: DownloadProgress) => React.Component;\n    /**\n     * An optional function to render errors (defaults to basic text display of errors)\n     * @param {string} msg\n     * @param {Error} error\n     * @returns {React.Component}\n     */\n    renderError?: (msg: string, error?: Error) => React.Component;\n    /**\n     * A <key>:<Downloader> map for Downloader Component\n     */\n    protocolHandlers: { [key: string]: IDownloader };\n}\n\nexport class FileDownloader extends React.PureComponent<\n    FileDownloaderProps,\n    { content?: string; progress?: DownloadProgress; error?: string }\n> {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n    componentDidMount(): void {\n        this.initiateDownload();\n    }\n\n    initiateDownload(): void {\n        this.setState({});\n        const { url } = this.props;\n\n        const downloader = new Downloader(this.props.protocolHandlers);\n        downloader.downloadWithProgress(\n            url,\n            (content: string): void => this.setState({ content }), //done downloading\n            (progress: DownloadProgress): void => {\n                this.setState({ progress });\n            },\n            (msg: string): void => {\n                this.setState({ error: msg });\n            }\n        );\n    }\n\n    componentDidUpdate(prevProps): void {\n        if (this.props.url !== prevProps.url) {\n            this.initiateDownload();\n        }\n    }\n\n    render(): JSX.Element | React.Component {\n        const {\n            url,\n            renderContent,\n            renderProgress = (p: DownloadProgress): JSX.Element => <div>{p.message}</div>,\n            renderError = (msg: string): JSX.Element => <div>{msg}</div>,\n        } = this.props;\n        const {\n            content,\n            progress = { message: `Downloading ${url}...`, bytesDownloaded: 0 },\n            error,\n        } = this.state;\n        if (content) {\n            return renderContent(content); // render prop\n        } else if (error) {\n            return renderError(error);\n        } else {\n            return renderProgress(progress);\n        }\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"@splunk/ui-utils/i18n\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");"],"sourceRoot":""}