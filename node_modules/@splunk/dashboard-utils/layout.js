/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ({

/***/ 16:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useScrollbarOverlay = exports.computeNewGridStructureItem = exports.computeNewAbsoluteStructureItem = exports.computeMaxHeight = exports.computeNewLinePosition = exports.computeNewBlockItemPosition = exports.computeNextAvailablePosition = exports.getDefaultPosition = exports.getPositionByType = exports.getFirstCollision = exports.sortLayoutItems = exports.convertToBlockItems = exports.convertToBlockItem = exports.convertLineToBlockItem = exports.toCoordinate = exports.computeLocationPort = exports.collides = exports.DEFAULT_CANVAS_HEIGHT = exports.DEFAULT_CANVAS_WIDTH = exports.VIZ_DEFAULT_HEIGHT_PX = exports.DEFAULT_SCALE_FACTOR = void 0;
var cloneDeep_1 = __importDefault(__webpack_require__(17));
exports.DEFAULT_SCALE_FACTOR = 3;
exports.VIZ_DEFAULT_HEIGHT_PX = 400;
exports.DEFAULT_CANVAS_WIDTH = 1200;
exports.DEFAULT_CANVAS_HEIGHT = 900;
/**
 * Given two layout items, check if they collide.
 * @method collides
 * @param {Object} layoutItemA
 * @param {Object} layoutItemB
 * @returns {Boolean} true or false
 */
var collides = function (layoutItemA, layoutItemB) {
    // same element
    if (layoutItemA.item === layoutItemB.item) {
        return false;
    }
    // layoutItemA is left of layoutItemB
    if (layoutItemA.position.x + layoutItemA.position.w <=
        layoutItemB.position.x) {
        return false;
    }
    // layoutItemA is right of layoutItemB
    if (layoutItemA.position.x >=
        layoutItemB.position.x + layoutItemB.position.w) {
        return false;
    }
    // layoutItemA is above layoutItemB
    if (layoutItemA.position.y + layoutItemA.position.h <=
        layoutItemB.position.y) {
        return false;
    }
    // layoutItemA is below layoutItemB
    if (layoutItemA.position.y >=
        layoutItemB.position.y + layoutItemB.position.h) {
        return false;
    }
    // boxes overlap
    return true;
};
exports.collides = collides;
/**
 * compute end position based on port
 * @method computeLocationPort
 * @param {Object} linePosition to or from
 * @param {Array} layout
 * @returns {Object} converted end position
 */
var computeLocationPort = function (endPosition, layout) {
    var id = endPosition.item;
    var index = layout.map(function (item) { return item.item; }).indexOf(id);
    var position;
    if (index >= 0) {
        position = cloneDeep_1.default(layout[index].position);
    }
    else {
        return null;
    }
    switch (endPosition.port) {
        case 'n':
            return { x: position.x + position.w / 2, y: position.y };
        case 'e':
            return {
                x: position.x + position.w,
                y: position.y + position.h / 2,
            };
        case 's':
            return {
                x: position.x + position.w / 2,
                y: position.y + position.h,
            };
        case 'w':
            return { x: position.x, y: position.y + position.h / 2 };
        default:
            return null;
    }
};
exports.computeLocationPort = computeLocationPort;
var toCoordinate = function (itemPosition, layout) {
    var _a;
    var topLeft = { x: 0, y: 0 };
    if (itemPosition.item && itemPosition.port) {
        return ((_a = exports.computeLocationPort({ item: itemPosition.item, port: itemPosition.port }, layout)) !== null && _a !== void 0 ? _a : topLeft);
    }
    if (typeof itemPosition.x === 'number' &&
        typeof itemPosition.y === 'number') {
        return { x: itemPosition.x, y: itemPosition.y };
    }
    return topLeft;
};
exports.toCoordinate = toCoordinate;
/**
 * convert line position to block position
 * @method convertLineToBlockItem
 * @param {Object} itemPosition
 * @param {Array} layout
 * @param {Number} status
 * @returns {Object} converted block position
 */
var convertLineToBlockItem = function (itemPosition, layout) {
    var from = exports.toCoordinate(itemPosition.from, layout);
    var to = exports.toCoordinate(itemPosition.to, layout);
    return {
        x: Math.min(from.x, to.x),
        y: Math.min(from.y, to.y),
        w: Math.abs(from.x - to.x),
        h: Math.abs(from.y - to.y),
    };
};
exports.convertLineToBlockItem = convertLineToBlockItem;
/**
 * convert layout item to block item
 * @method convertToBlockItem
 * @param {Object} item
 * @returns {Object} converted block item
 */
var convertToBlockItem = function (item, layout) {
    var blockItem = {
        item: item.item,
        type: 'block',
        position: {
            x: 0,
            y: 0,
            w: 0,
            h: 0,
        },
    };
    if (item.type === 'line') {
        blockItem.position = exports.convertLineToBlockItem(item.position, layout);
    }
    else {
        // default item type is block
        blockItem.position = cloneDeep_1.default(item.position);
    }
    return blockItem;
};
exports.convertToBlockItem = convertToBlockItem;
/**
 * convert layout items to block items
 * @method convertToBlockItems
 * @param {Array} layout
 * @returns {Array} converted block items
 */
var convertToBlockItems = function (layout) {
    return layout.map(function (item) { return exports.convertToBlockItem(item, layout); });
};
exports.convertToBlockItems = convertToBlockItems;
/**
 * Get layout items sorted from top left to right and down.
 * @method sortLayoutItems
 * @param {Array} layout
 * @returns {Array} sorted layout
 */
var sortLayoutItems = function (layout) {
    return cloneDeep_1.default(layout).sort(function (BlockItem1, BlockItem2) {
        var res = -1;
        if (BlockItem1.position.y > BlockItem2.position.y ||
            (BlockItem1.position.y === BlockItem2.position.y &&
                BlockItem1.position.x > BlockItem2.position.x)) {
            res = 1;
        }
        else if (BlockItem1.position.y === BlockItem2.position.y &&
            BlockItem1.position.x === BlockItem2.position.x) {
            // Without this, we can get different sort results in IE vs. Chrome/FF
            res = 0;
        }
        return res;
    });
};
exports.sortLayoutItems = sortLayoutItems;
/**
 * Returns the first item this layout collides with.
 * @method getFirstCollision
 * @param {Array} layout
 * @param {Object} layoutItem
 * @returns {Object} first collision or undefined
 */
var getFirstCollision = function (layout, layoutItem) {
    return layout.find(function (item) { return exports.collides(item, layoutItem); });
};
exports.getFirstCollision = getFirstCollision;
/**
 * get position based on type
 * @method getPositionByType
 * @param {Object} config
 * @param {Number} config.col
 * @param {Number} config.row
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {String} config.type
 * @returns {Object} new position
 */
var getPositionByType = function (_a) {
    var col = _a.col, row = _a.row, width = _a.width, height = _a.height, type = _a.type;
    if (type === 'line') {
        return {
            from: {
                x: col,
                y: row + height,
            },
            to: {
                x: col + width,
                y: row + height / 2,
            },
        };
    }
    return {
        x: col,
        y: row,
        w: width,
        h: height,
    };
};
exports.getPositionByType = getPositionByType;
/**
 * get the default position based on type (Note: does not support legacy grid)
 * @method getDefaultPosition
 * @param {Object} config
 * @param {Number} config.canvasWidth
 * @param {Number} config.canvasHeight
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {String} config.type
 * @returns {Object} default position
 */
var getDefaultPosition = function (_a) {
    var canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, width = _a.width, height = _a.height, type = _a.type;
    if (type === 'line') {
        var linePos = {
            from: {
                x: Math.round(canvasWidth / exports.DEFAULT_SCALE_FACTOR),
                y: Math.round(canvasHeight / exports.DEFAULT_SCALE_FACTOR),
            },
            to: {
                x: Math.round(canvasWidth / exports.DEFAULT_SCALE_FACTOR + width),
                y: Math.round(canvasHeight / exports.DEFAULT_SCALE_FACTOR + height),
            },
        };
        return linePos;
    }
    var absPos = {
        x: Math.round(canvasWidth / exports.DEFAULT_SCALE_FACTOR),
        y: Math.round(canvasHeight / exports.DEFAULT_SCALE_FACTOR),
        w: width,
        h: height,
    };
    return absPos;
};
exports.getDefaultPosition = getDefaultPosition;
/**
 * compute next available position for new added item (Note: does not support legacy grid)
 * @method computeNextAvailablePosition
 * @param {Object} config
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {Number} config.canvasHeight
 * @param {Number} config.canvasWidth
 * @param {Number} config.items
 * @param {Number} config.type absolute/line
 * @returns {Object} position
 */
var computeNextAvailablePosition = function (_a) {
    var width = _a.width, height = _a.height, canvasHeight = _a.canvasHeight, canvasWidth = _a.canvasWidth, items = _a.items, type = _a.type;
    var rectA = {
        item: '__canvas__',
        position: {
            x: 0,
            y: 0,
            w: width,
            h: height,
        },
    };
    var minHeight;
    var layout = exports.convertToBlockItems(items);
    var sorted = exports.sortLayoutItems(layout);
    // iterate all possible positions from top left to bottom right
    // for each position, we first try to find collision.
    // for each row, we record the minHeight for the collisions in this row.
    // if we can find a collision,  update col to the right boundary of current collision and update minHeight.
    // After each row, we update row to minHeight.
    // In this way, we can skip a lot of meaningless positions.
    // if find a good position, return this position
    // else return default position
    // Time complexity: O(K*K)   K is the number of layout items.
    var row = 0;
    var col;
    for (; row < canvasHeight; row += 1) {
        minHeight = canvasHeight - 1;
        col = 0;
        for (; col < canvasWidth; col += 1) {
            rectA.position.x = col;
            rectA.position.y = row;
            var rightBoundary = rectA.position.x + rectA.position.w - 1;
            var bottomBoundary = rectA.position.y + rectA.position.h - 1;
            // possible position must within canvas on horizontal and vertical side
            if (!(rightBoundary > canvasWidth || bottomBoundary > canvasHeight)) {
                var collision = exports.getFirstCollision(sorted, rectA);
                if (collision) {
                    minHeight = Math.min(minHeight, collision.position.y + collision.position.h - 1);
                    // update col
                    col = collision.position.x + collision.position.w - 1;
                }
                else {
                    return exports.getPositionByType({ col: col, row: row, width: width, height: height, type: type });
                }
            }
            else {
                break;
            }
        }
        // update row
        row = minHeight;
    }
    return exports.getDefaultPosition({
        canvasWidth: canvasWidth,
        canvasHeight: canvasHeight,
        width: width,
        height: height,
        type: type,
    });
};
exports.computeNextAvailablePosition = computeNextAvailablePosition;
/**
 * Given the current absolute layout items, return position that new visualization should locate.
 * @method computeNewBlockItemPosition
 * @param {Object} options
 * @param {Number} options.canvasWidth
 * @param {Number} options.canvasHeight
 * @param {Object} options.vizContract
 * @param {Array} options.items
 * @param {Object} options.config
 * @returns {Object} nextPosition
 */
var computeNewBlockItemPosition = function (_a) {
    var _b, _c, _d, _e, _f, _g, _h, _j;
    var canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, vizContract = _a.vizContract, config = _a.config, items = _a.items;
    var width = (_e = (_c = (_b = vizContract === null || vizContract === void 0 ? void 0 : vizContract.initialDimension) === null || _b === void 0 ? void 0 : _b.width) !== null && _c !== void 0 ? _c : (_d = config === null || config === void 0 ? void 0 : config.size) === null || _d === void 0 ? void 0 : _d.initialWidth) !== null && _e !== void 0 ? _e : Math.round(canvasWidth / 3);
    var height = (_j = (_g = (_f = vizContract === null || vizContract === void 0 ? void 0 : vizContract.initialDimension) === null || _f === void 0 ? void 0 : _f.height) !== null && _g !== void 0 ? _g : (_h = config === null || config === void 0 ? void 0 : config.size) === null || _h === void 0 ? void 0 : _h.initialHeight) !== null && _j !== void 0 ? _j : Math.round(canvasHeight / 3);
    var nextPosition = exports.computeNextAvailablePosition({
        width: width,
        height: height,
        canvasHeight: canvasHeight,
        canvasWidth: canvasWidth,
        items: items,
        type: 'block',
    });
    return nextPosition;
};
exports.computeNewBlockItemPosition = computeNewBlockItemPosition;
/**
 * Given the current absolute layout items, return point position
 * @method computeNewLinePosition
 * @params {Object} config
 * @param {Number} config.canvasWidth
 * @param {Number} config.canvasHeight
 * @param {Array} config.items
 * @returns {*} position
 */
var computeNewLinePosition = function (_a) {
    var canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, items = _a.items;
    // default width and height for line
    var width = 150;
    var height = 20;
    var nextPosition = exports.computeNextAvailablePosition({
        width: width,
        height: height,
        canvasHeight: canvasHeight,
        canvasWidth: canvasWidth,
        items: items,
        type: 'line',
    });
    return nextPosition;
};
exports.computeNewLinePosition = computeNewLinePosition;
/**
 * compute the max height based on current layout items and minimum height
 * @method computeMaxHeight
 * @param {Array} layoutItems
 * @param {Number} minHeight
 * @returns {Number} max height
 */
var computeMaxHeight = function (layoutItems, minHeight) {
    if (minHeight === void 0) { minHeight = 0; }
    return layoutItems.length > 0
        ? Math.max.apply(Math, __spread(layoutItems.map(function (item) { return item.position.y + item.position.h; }), [1])) : minHeight;
};
exports.computeMaxHeight = computeMaxHeight;
/**
 * Computes a new layout item position for the absolute layout
 * @param {Object} options
 * @param {String} options.itemId The identifier for a visualization
 * @param {String} [options.type="block"] The structure type for a viz: must be "line" or "block"
 * @param {Number} options.canvasWidth The width of the canvas
 * @param {Number} options.canvasHeight The height of the canvas
 * @param {Object} options.vizContract Metadata to define the default height/width of a new viz
 * @param {Object} options.config
 * @param {Array} layoutItems List of items in the layout structure
 * @returns {LayoutItem}
 */
var computeNewAbsoluteStructureItem = function (_a) {
    var itemId = _a.itemId, _b = _a.type, type = _b === void 0 ? 'block' : _b, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, vizContract = _a.vizContract, layoutItems = _a.layoutItems, config = _a.config;
    if (type === 'line') {
        return {
            item: itemId,
            type: 'line',
            position: exports.computeNewLinePosition({
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                items: layoutItems,
            }),
        };
    }
    return {
        item: itemId,
        type: 'block',
        position: exports.computeNewBlockItemPosition({
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight,
            vizContract: vizContract,
            config: config,
            items: layoutItems,
        }),
    };
};
exports.computeNewAbsoluteStructureItem = computeNewAbsoluteStructureItem;
/**
 * Computes a new layout item position for the grid layout
 * @param {Object} config
 * @param {String} config.itemId The identifier for a visualization
 * @param {Number} config.canvasWidth The width of the canvas
 * @param {Array} layoutItems List of items in the layout structure
 * @returns {LayoutItem}
 */
var computeNewGridStructureItem = function (_a) {
    var itemId = _a.itemId, layoutItems = _a.layoutItems, canvasWidth = _a.canvasWidth;
    return ({
        item: itemId,
        type: 'block',
        position: {
            x: 0,
            y: exports.computeMaxHeight(layoutItems),
            w: canvasWidth,
            h: exports.VIZ_DEFAULT_HEIGHT_PX,
        },
    });
};
exports.computeNewGridStructureItem = computeNewGridStructureItem;
/**
 * Check if the default scrollbar is obtrusive (uses screen real estate) or not (directly overlayed on content)
 * @returns {Boolean}
 */
var hasObtrusiveDefaultScrollbar = function () {
    var scrollDiv = document.createElement('div');
    scrollDiv.setAttribute('style', 'width:100px;height:100px;overflow:scroll;position:absolute;top:-9999px;');
    document.body.appendChild(scrollDiv);
    // get the scrollbar width
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    // delete the div
    document.body.removeChild(scrollDiv);
    return scrollbarWidth !== 0;
};
/**
 * Determine if scrollbar is required to be overlayed (non obtrusive)
 * @returns {Boolean}
 */
var useScrollbarOverlay = function () {
    /**
     * NOTE: only webkit and blink based browsers support 'overflow:overlay'
     * this fix is for https://jira.splunk.com/browse/SCP-36275 which predominantly exists in Chrome on Windows OS
     * @returns {Boolean}
     */
    return (hasObtrusiveDefaultScrollbar() && CSS.supports('overflow', 'overlay'));
};
exports.useScrollbarOverlay = useScrollbarOverlay;


/***/ }),

/***/ 17:
/***/ (function(module, exports) {

module.exports = require("lodash/cloneDeep");

/***/ })

/******/ });
//# sourceMappingURL=layout.js.map