{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"@babel/runtime/helpers/classCallCheck\"","webpack:///external \"@babel/runtime/helpers/createClass\"","webpack:///./src/DataPoint.ts","webpack:///external \"@babel/runtime/helpers/inherits\"","webpack:///external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack:///external \"@babel/runtime/helpers/getPrototypeOf\"","webpack:///external \"lodash\"","webpack:///./src/Formatter.ts","webpack:///./src/DataSeries.ts","webpack:///./src/TypeSafeValue.ts","webpack:///./src/DataFrame.ts","webpack:///./src/utils/types.ts","webpack:///external \"@splunk/moment\"","webpack:///external \"@splunk/visualizations-shared/colorUtils\"","webpack:///external \"@babel/runtime/helpers/slicedToArray\"","webpack:///./src/formatters/FormatByType.ts","webpack:///external \"numbro\""],"names":[],"mappings":"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","file":"FormatByType.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","import { DataPrimitive, TypedValue, DataType, IDataPoint } from './DataPrimitive';\nimport { TypeSafeValue } from './TypeSafeValue';\n\n/**\n * Base DataPoint class and associated DataPoint selectors\n * @implements {DataPrimitive}\n * @implements {IDataPoint}\n */\nexport class DataPoint<T extends DataType = DataType> implements DataPrimitive<T>, IDataPoint<T> {\n    private value: TypeSafeValue<T>;\n    public field: string;\n\n    static isDataPoint(o: any): o is DataPoint {\n        return o instanceof DataPoint;\n    }\n\n    static fromRaw(value): DataPoint {\n        return new DataPoint('', TypeSafeValue.fromRaw(value));\n    }\n\n    /**\n     *\n     * @param {string} field data field\n     * @param {object} value data value + it's type (number, string, time or color)\n     * @param {object} meta meta data (value + type) associated with the data point\n     */\n    public constructor(field: string, value: TypedValue<T>) {\n        this.field = field;\n        this.setValue(value);\n    }\n\n    getValue(): TypeSafeValue<T> {\n        return this.value;\n    }\n\n    /**\n     * sets the data point's value to a static TypedValue\n     * @param {TypedValue} v\n     */\n    setValue(v: TypedValue<T>): void {\n        this.value = TypeSafeValue.from(v);\n    }\n\n    /**\n     * get only value of the data point\n     * @returns {string|number|null}\n     */\n    getRawValue(): string | number | null {\n        return this.value.toRawValue();\n    }\n\n    /**\n     * Returns the datatype of the point\n     * @public\n     * @returns {DataPoint<'string'>}\n     */\n    getField(): DataPoint<'string'> {\n        return DataPoint.fromRaw(this.field) as DataPoint<'string'>;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"lodash\");","import { DataType, TypedValue, DataPrimitive } from './DataPrimitive';\nimport { IDimension } from './Dimensions';\nimport { DataFrame } from './DataFrame';\nimport { DataSeries } from './DataSeries';\nimport { DataPoint } from './DataPoint';\n\nexport interface DataPrimitiveFormatter<IN extends DataType, OUT extends DataType> {\n    format(dataPrimitive: IDimension<IN>): IDimension<OUT> | Record<string, unknown>;\n}\n\nexport abstract class AbstractFormatter<IN extends DataType = DataType, OUT extends DataType = DataType>\n    implements DataPrimitiveFormatter<IN, OUT> {\n    // use method overload signatures to tell compiler that if we format a DataPoint, we return a DataPoint, etc\n    format(p: DataPoint<IN>): DataPoint<OUT>;\n    format(s: DataSeries<IN>): DataSeries<OUT>;\n    format(f: DataFrame<IN>): DataFrame<OUT>;\n    format(dataPrimitive: IDimension<IN>): IDimension<OUT> {\n        if (dataPrimitive instanceof DataFrame) {\n            const newSeries: DataSeries<OUT>[] = [];\n            dataPrimitive.series.forEach((dataSeries: DataSeries<IN>, i: number) => {\n                newSeries.push(this.formatSeries(dataSeries, i));\n            });\n            return new DataFrame<OUT>(newSeries);\n        } else if (dataPrimitive instanceof DataSeries) {\n            return this.formatSeries(dataPrimitive);\n        } else {\n            return this.formatPoint(dataPrimitive);\n        }\n    }\n\n    protected formatSeries(s: DataSeries<IN>, i = 0): DataSeries<OUT> {\n        const newPoints: DataPoint<OUT>[] = [];\n        s.points.forEach((dataPoint, j) => {\n            newPoints.push(this.formatPoint(dataPoint, s, i, j));\n        });\n        return new DataSeries<OUT>(newPoints); // new DataSeries must have the type of the formatter's output\n    }\n\n    protected formatPoint(p: DataPoint<IN>, s?: DataSeries<IN>, i = 0, j = 0): DataPoint<OUT> {\n        const { field } = p;\n        const tmp = this.formatTypedValue(p, s, i, j);\n        return new DataPoint<OUT>(field, tmp);\n    }\n\n    protected abstract formatTypedValue(\n        p: DataPoint<IN>,\n        s?: DataSeries<IN>,\n        i?: number,\n        j?: number\n    ): TypedValue<OUT>;\n\n    protected makeArrays2D(a: any): any[][] {\n        if (Array.isArray(a)) {\n            if (Array.isArray(a[0])) {\n                return a;\n            } else {\n                return [a];\n            }\n        }\n        throw new Error(\"argument wasn't array\");\n    }\n}\n","import { DataPoint } from './DataPoint';\nimport { DataPrimitive, DataType, IDataSeries, TypedValue } from './DataPrimitive';\n\n/**\n * DataSeries class and associated DataSeries selectors\n * @implements {DataPrimitive}\n */\nexport class DataSeries<T extends DataType = DataType> implements DataPrimitive<T>, IDataSeries<T> {\n    public readonly points: DataPoint<T>[];\n    public readonly field: string;\n\n    static isDataSeries(o: any): o is DataSeries {\n        return o instanceof DataSeries;\n    }\n\n    static fromRaw(pts: any[]): DataSeries {\n        return new DataSeries(pts.map(p => DataPoint.fromRaw(p)));\n    }\n    /**\n     *\n     * @param {array} points list of data points\n     */\n    constructor(points: DataPoint<T>[] = []) {\n        this.points = points;\n        if (points.length > 0) {\n            this.field = points[0].field; // the field is an immutable property of the series\n        }\n    }\n\n    /**\n     * return first dataPoint in series\n     * @public\n     * @returns {DataPoint}\n     */\n    firstPoint(): DataPoint<T> {\n        return this.points[0];\n    }\n\n    /**\n     * return last dataPoint in series\n     * @public\n     * @returns {DataPoint}\n     */\n    lastPoint(): DataPoint<T> {\n        return this.points.slice(-1)[0];\n    }\n\n    /**\n     * finds dataPoint(s) in DataSeries by index(es)\n     * @public\n     * @param {...number} indexes\n     * @returns {DataSeries}\n     */\n    pointsByIndexes(...indexes: number[]): DataSeries<T> {\n        const indexedPoints: DataPoint<T>[] = [];\n        indexes.forEach(index => {\n            const dp = this.points[index]; // should we allow negative indexes?\n            if (dp != null) {\n                indexedPoints.push(dp);\n            }\n        });\n        return new DataSeries(indexedPoints);\n    }\n\n    /**\n     * finds and returns the individual dataPoint at the given index\n     * @public\n     * @param {number} index\n     * @returns {DataPoint}\n     */\n    pointByIndex(index: number): DataPoint<T> {\n        if (index < 0 || index >= this.points.length) {\n            // will handle negative and out-of-range indexes for the time being by returning null\n            return null;\n        }\n        const dp = this.points[index];\n        const field = dp.field;\n        const { type, value } = dp.getValue();\n        return new DataPoint(field, { type, value });\n    }\n\n    /**\n     * finds the delta between the last point and point at the given index.\n     * a negative index can be used, indicating an offset from the end of the sequence\n     * @public\n     * @param {number} index\n     * @returns {DataPoint}\n     */\n    delta(index: number): DataPoint<T> {\n        const dp1 = this.lastPoint();\n        if (dp1 === undefined) {\n            return undefined;\n        }\n        const field = dp1.field;\n\n        const { type, value: val1 } = dp1.getValue();\n        if (type !== 'number') {\n            console.warn(`delta cannot be computed for non-numerical data series of type ${type}`); // Throw an error and catch in pipeline executor?\n        }\n\n        let dp2 = null;\n        // use undefined as default, because null values will be coerced to 0 (thus invalid indexes return a delta of 0)\n        // for aggregate SPL queries like `stats count`, we want no trend value rather than 0 as the trend value\n        let delta;\n        if (index >= 0) {\n            dp2 = this.points[index];\n        } else {\n            dp2 = this.points.slice().reverse()[Math.abs(index) - 1];\n        }\n        if (dp2 == null) {\n            console.warn('invalid index'); // Throw an error and catch in pipeline executor?\n        } else {\n            const { value: val2 } = dp2.getValue();\n            delta = val1 - val2;\n        }\n        return new DataPoint(field, { type, value: delta }); // create a new data point since we don't want meta data to carry over\n    }\n\n    /**\n     * sets all the values in the Data Series to a static TypedValue\n     * @param {TypedValue} v\n     */\n    setValue(v: TypedValue<T>) {\n        this.points.forEach(p => {\n            p.setValue(v);\n        });\n    }\n\n    /**\n     * gets all the values + their type in the Data Series\n     * @returns {TypedValue[]}\n     */\n    getValue(): TypedValue<T>[] {\n        const values: TypedValue<T>[] = [];\n        this.points.forEach(p => {\n            values.push(p.getValue());\n        });\n        return values;\n    }\n\n    /**\n     * gets all the values (only) in the Data Series\n     * @returns {array}\n     */\n    getRawValue(): (string | number)[] {\n        const values: (string | number)[] = [];\n        this.points.forEach(p => {\n            values.push(p.getRawValue());\n        });\n        return values;\n    }\n\n    /**\n     * Returns the uniform type of the series\n     * @public\n     * @returns {DataPoint<'string'>}\n     */\n    getField(): DataPoint<'string'> {\n        const dp1 = this.lastPoint();\n        return dp1.getField();\n    }\n\n    /**\n     * returns the minimum DataPoint in the series or undefined if no numbers in series\n     * @public\n     * @returns {DataPoint<T>}\n     */\n    min(): DataPoint<T> {\n        return this.reduce((v1, v2) => v1 < v2);\n    }\n\n    /**\n     * returns the maximum DataPoint in the series\n     * @public\n     * @returns {DataPoint<T>}\n     */\n    max(): DataPoint<T> {\n        return this.reduce((v1, v2) => v1 > v2);\n    }\n\n    private reduce(comparator: (v1: T, v2: T) => boolean): DataPoint<T> {\n        return this.points.reduce((agg: DataPoint<T>, cur: DataPoint<T>) => {\n            // note: cannot use agg.getRawValue here instead of agg.value.value as that limits returned value to string|number\n            return !agg || comparator(cur.getValue().value, agg.getValue().value) ? cur : agg;\n        }, undefined);\n    }\n}\n","import { isColor } from '@splunk/visualizations-shared/colorUtils';\nimport { DataType, TypedValue } from './DataPrimitive';\nimport { isNumber, isString, isTime, getDataTypeForPoint } from '../src/utils/types';\nimport moment from '@splunk/moment';\n\n/**\n * @implements {TypedValue}\n * TypeSafeValue implements the TypedValue interface, and adds additional methods 'isOk' which can be used to determine\n * if the value was properly coerced into the expected type. When isOk is false, it means that coerced value cannot\n * be relied upon. For example, if the type is 'time' but isOk is false, it is possible that the coerced value could be NaN.\n * A field named originalValue can be used for user-facing error messages in situations where isOk is false. For example:\n * \"'cat' was not an OK value for a 'time' field\". This class's fields are all immutable.\n */\nexport class TypeSafeValue<T extends DataType> implements TypedValue<T> {\n    /**\n     * isTypeSafe. This is a marker field. The presence of this field can be used at runtime to determine if TypedValue is rigorous,\n     * loose. Loose TypedValue such as {type:'number', value:'cat'} are handy for testing, but can lie. Obviously 'cat'\n     * is not a number. If the isTypeSafe field is present then the instance is a TypeSafeValue\n     * @type {boolean}\n     */\n    readonly isTypeSafe: boolean = true;\n    /**\n     * isOk. This field tells if the original value passed into this's constructor honored its type contract.\n     * @type {boolean}\n     */\n    readonly isOk: boolean = true;\n    /**\n     * originalValue. This field retains the original value prior to coercion. It can be used to show a user which values\n     * failed to comply with the expected type.\n     */\n    readonly originalValue: any;\n\n    readonly type: T;\n    readonly value: any;\n\n    constructor(type: T, value: any, isOk: boolean, originalValue: any) {\n        this.type = type;\n        this.value = value;\n        this.isOk = isOk;\n        this.originalValue = originalValue;\n    }\n\n    /**\n     * returns a TypeSafeValue, either by converting the non TypeSafeValue to\n     * a TypeSafeValue, or by simply returning the passed-in TypeSafeValue\n     * @param {TypedValue<T>} typedValue\n     * @returns {TypeSafeValue<T>}\n     */\n    public static from<T extends DataType = DataType>(typedValue: TypedValue<T>): TypeSafeValue<T> {\n        if ((typedValue as any).isTypeSafe) {\n            return typedValue as TypeSafeValue<T>; // just return what was passed in since it is already TypeSafeValue\n        } else {\n            const { value: originalValue, type } = typedValue;\n            const [value, isOk] = TypeSafeValue.coerceValue<T>(typedValue);\n            return new TypeSafeValue<T>(type, value, isOk, originalValue);\n        }\n    }\n\n    /**\n     * Creates a TypeSafeValue from a raw value\n     * @param value\n     * @returns {TypeSafeValue<DataType>}\n     */\n    public static fromRaw(value): TypeSafeValue<DataType> {\n        const type: DataType = getDataTypeForPoint(value);\n        return new TypeSafeValue(type, value, true, value);\n    }\n\n    /**\n     * attempts to coerce the provided value to the provided type. Returns tuple\n     * of the coerced value and a boolean telling if the coercion was clean (true)\n     * or if the coercion was likely produced an unusable result, such as NaN for\n     * a number, or '' for a color.\n     * @param {TypedValue<T>} typedValue\n     * @returns {[any, boolean]}\n     */\n    private static coerceValue<T extends DataType = DataType>(typedValue: TypedValue<T>): [any, boolean] {\n        const { type, value } = typedValue;\n        let coercedVal = null;\n        let isOk: boolean;\n        let acceptableType = true;\n        try {\n            switch (type) {\n                case 'number': {\n                    isOk = isNumber(value);\n                    coercedVal = Number(value);\n                    break;\n                }\n                case 'time': {\n                    isOk = isTime(value);\n                    if (value instanceof Date) {\n                        coercedVal = value;\n                    } else {\n                        // for case like `VM-203`, It will be convereted to a Date.\n                        coercedVal = isOk ? new Date(value) : 'Invalid Date';\n                    }\n\n                    break;\n                }\n                case 'string': {\n                    isOk = isString(value);\n                    coercedVal = value.toString();\n                    break;\n                }\n                case 'color': {\n                    isOk = isColor(value);\n                    coercedVal = value;\n                    break;\n                }\n                case 'sparkline': {\n                    isOk = Array.isArray(value) && value[0] === '##__SPARKLINE__##';\n                    coercedVal = value;\n                    break;\n                }\n                case 'array': {\n                    isOk = Array.isArray(value);\n                    coercedVal = value;\n                    break;\n                }\n                case 'null': {\n                    isOk = value === null;\n                    coercedVal = value;\n                    break;\n                }\n                default: {\n                    acceptableType = false;\n                }\n            }\n        } catch (e) {\n            isOk = false;\n        }\n        if (!acceptableType) {\n            throw new Error(`unknown type: '${type}'`);\n        }\n        return [coercedVal, isOk];\n    }\n\n    toRawValue(): string | number | null {\n        switch (this.type) {\n            case 'time':\n                return moment(this.value).format();\n            case 'sparkline':\n            case 'array':\n            case 'number':\n            case 'string':\n            case 'color':\n            default:\n                return this.value;\n        }\n    }\n}\n","import { DataPoint } from './DataPoint';\nimport { DataSeries } from './DataSeries';\nimport { inferDataTypeFromData, getDataTypeForPoint } from './utils/types';\nimport { DataPrimitive, TypedValue, DataType, IDataFrame } from './DataPrimitive';\nimport { IDimension } from './Dimensions';\n\nexport type ColumnVal = number | string | string[];\nexport interface ColumnarData {\n    data: {\n        fields: { name: string }[] | string[];\n        columns: ColumnVal[][];\n    };\n}\n\n/**\n * Base DataFrame class and associated DataFrame selectors\n * @implements {DataPrimitive}\n */\nexport class DataFrame<T extends DataType = DataType> implements IDataFrame<DataType>, DataPrimitive<T> {\n    /**\n     * List of series comprising the DataFrame\n     * @public\n     * @instance\n     */\n    public series: DataSeries<T>[];\n\n    /**\n     * @param {any} o\n     * @returns {boolean}\n     */\n    static isDataFrame(o: any): o is DataFrame {\n        return o instanceof DataFrame;\n    }\n\n    /**\n     * @param {array} series list of data series\n     */\n    constructor(series: DataSeries<T>[]) {\n        this.series = Array.isArray(series) ? series : [series];\n    }\n\n    /**\n     * Loads ColumnarData into a DataFrame\n     * @param {ColumnarData} columnarData\n     * @returns {DataFrame<T>}\n     */\n    static fromJsonCols<T extends DataType = DataType>(columnarData: ColumnarData): DataFrame<T> {\n        if (!columnarData || columnarData.data === null) {\n            return new DataFrame<T>([]);\n        }\n        // fixme todo why do we expect an object like {data:{fields, columns}}? Why don't we just expect something like {fields, columns}? The nesting inside 'data' feels useless\n        const {\n            data: { fields: fields = [], columns: columns = [] },\n        } = columnarData;\n        if (columns.length !== fields.length) {\n            throw new Error(\n                `number of columns (${columns.length}) does not match number of fields (${fields.length})`\n            );\n        }\n        const dataSeries = [];\n        columns.forEach((data: ColumnVal[], idx): void => {\n            const dataPoints = [];\n            const fieldInfo: any = fields[idx];\n            const fieldName: string = fieldInfo.name || fieldInfo;\n            data.forEach((value): void => {\n                const dataType: DataType = getDataTypeForPoint(value, { fieldName });\n                dataPoints.push(new DataPoint(fieldName, { value: value, type: dataType }));\n            });\n            dataSeries.push(new DataSeries(dataPoints));\n        });\n        return new DataFrame<T>(dataSeries);\n    }\n\n    static fromRaw(f: any[][]): DataFrame {\n        const series: DataSeries[] = [];\n        f.forEach((s: any[]): void => {\n            series.push(DataSeries.fromRaw(s));\n        });\n        return new DataFrame(series);\n    }\n\n    static fromDataPrimitive(dp: IDimension): DataFrame {\n        if (DataFrame.isDataFrame(dp)) {\n            return dp;\n        } else if (DataSeries.isDataSeries(dp)) {\n            return new DataFrame([dp]);\n        } else if (DataPoint.isDataPoint(dp)) {\n            return new DataFrame([new DataSeries([dp])]);\n        }\n    }\n\n    /**\n     * finds series in DataFrame by index(es)\n     * @public\n     * @param {number[]} indexes\n     * @returns {DataFrame}\n     */\n    frameBySeriesIndexes(...indexes: number[]): DataFrame<T> {\n        const indexedSeries: DataSeries<T>[] = [];\n        indexes.forEach((index): void => {\n            const ds = this.series[index]; // should we allow negative indexes?\n            if (ds != null) {\n                indexedSeries.push(ds);\n            }\n        });\n        return new DataFrame<T>(indexedSeries);\n    }\n\n    /**\n     *  Returns the data series at the given index\n     * @public\n     * @param {number} index\n     * @returns {DataSeries<T>}\n     */\n    seriesByIndex(index: number): DataSeries<T> {\n        return this.series[index];\n    }\n\n    /**\n     * Returns a DataFrame that is a slice of this DataFrame's series from  [start, end)\n     * @public\n     * @param {int} start (inclusive)\n     * @param {int} end (optional, exclusive)\n     * @returns {DataFrame<T>}\n     */\n    frameBySeriesIndexRange(start: number, end?: number): DataFrame<T> {\n        return new DataFrame<T>(this.series.slice(start, end));\n    }\n\n    /**\n     * Returns a DataFrame having only the DataSeries matching the provided names\n     * @public\n     * @param {string[]} names\n     * @returns {DataFrame<T>}\n     */\n    frameBySeriesNames(...names: string[]): DataFrame<T> {\n        const namedSeries: DataSeries<T>[] = [];\n        names.forEach((name): void => {\n            const found = this.seriesByName(name);\n            found && namedSeries.push(found);\n        });\n        return new DataFrame<T>(namedSeries);\n    }\n\n    /**\n     * Returns a DataFrame having the DataSeries matching provided names or indexes\n     * @public\n     * @param {...(string|number)} namesOrIndexes\n     * @returns {DataFrame<T>}\n     */\n    frameBySeriesNamesOrIndexes(...mixed: (string | number)[]): DataFrame<T> {\n        const mixedSeries: DataSeries<T>[] = [];\n        mixed.forEach((nameOrIndex: string | number): void => {\n            const asNumber = Number(nameOrIndex);\n            if (Number.isNaN(asNumber)) {\n                const found = this.seriesByName(nameOrIndex as string);\n                found && mixedSeries.push(found);\n            } else {\n                const found = this.series[asNumber];\n                found && mixedSeries.push(found);\n            }\n        });\n        return new DataFrame<T>(mixedSeries);\n    }\n\n    /**\n     * Returns a DataFrame containing DataSeries that match only the provided types\n     * @public\n     * @param {T[]} types\n     * @returns {DataFrame<T>}\n     */\n    frameBySeriesTypes(...types: T[]): DataFrame<T> {\n        return (new DataFrame<T>(\n            this.series.filter((s: DataSeries<T>): boolean => types.includes(s.firstPoint().getValue().type)) //fixme todo we should have a getType() method on a series. SHould not make 'decision' about what type the series is from outside the series\n        ) as unknown) as DataFrame<T>;\n    }\n\n    /**\n     * finds series in DataFrame by field name\n     * @public\n     * @param {string} field\n     * @returns {DataSeries<T>}\n     */\n    seriesByName(field: string): DataSeries<T> {\n        return this.series.find((dataSeries): boolean => field === dataSeries.field);\n    }\n\n    /**\n     * finds series in DataFrame by first data type match\n     * @public\n     * @param {T} type\n     * @returns {DataSeries<T>}\n     */\n    seriesByType(type: T): DataSeries<T> {\n        return this.series.find(dataSeries => {\n            const dataType: DataType = inferDataTypeFromData(dataSeries.points);\n            return dataType === type;\n        });\n    }\n\n    /**\n     * finds series in DataFrame with the providing prioritized types\n     * @public\n     * @param {T[]} types T extends from DataType, which is 'number' | 'string' | 'color' | 'time' | 'unknown' | 'sparkline' | 'array' | 'null'\n     * @returns {DataSeries<T>}\n     */\n    seriesByPrioritizedTypes(...types: T[]): DataSeries<T> {\n        for (const type of types) {\n            const matchedSeries: DataSeries<T> = this.seriesByType(type);\n            if (Array.isArray(matchedSeries?.points) && matchedSeries?.points?.length) {\n                return matchedSeries;\n            }\n        }\n        return this.series[0];\n    }\n\n    /**\n     * sets all the values in the DataFrame to a static TypedValue\n     * @public\n     * @param {TypedValue} v\n     */\n    setValue(v: TypedValue<T>): void {\n        this.series.forEach((s): void => s.setValue(v));\n    }\n\n    /**\n     * gets all the values (only) in the Data Frame\n     * @public\n     * @returns {array}\n     */\n    getRawValue(): (string | number)[][] {\n        const values: (string | number)[][] = [];\n        this.series.forEach((s): void => {\n            values.push(s.getRawValue());\n        });\n        return values;\n    }\n\n    /**\n     * gets all the values + their types in the Data Frame\n     * @public\n     * @returns {TypedValue[][]}\n     */\n    getValue(): TypedValue<T>[][] {\n        const values: TypedValue<T>[][] = [];\n        this.series.forEach((s): void => {\n            values.push(s.getValue());\n        });\n        return values;\n    }\n\n    /**\n     * Get the field names of each series in frame\n     * @public\n     * @returns {DataSeries<'string'>}\n     */\n    getField(): DataSeries<'string'> {\n        const points = this.series.map((s): DataPoint<'string'> => s.getField());\n        return new DataSeries<'string'>(points);\n    }\n\n    /**\n     * finds the global minimum value (from all numerical series) in the Data Frame\n     * @public\n     * @returns {number}\n     */\n    min(): DataPoint<T> {\n        return this.minOrMax('min');\n    }\n\n    /**\n     * finds the global maximum value (from all numerical series) in the Data Frame\n     * @public\n     * @returns {number}\n     */\n    max(): DataPoint<T> {\n        return this.minOrMax('max');\n    }\n\n    /**\n     * runs result of min or max function over all the series and returns the data point\n     * points\n     * @param {string} aggName\n     * @returns {DataPoint<T>}\n     */\n    private minOrMax(funcName: 'min' | 'max'): DataPoint<T> {\n        const overallSeries = new DataSeries<T>();\n        this.series.forEach((s): void => {\n            const m = s[funcName]();\n            m && overallSeries.points.push(m);\n        });\n        return overallSeries[funcName]();\n    }\n}\n","import moment from '@splunk/moment';\nimport { isNumber as lodashIsNumber, isBoolean, isFinite, isObject, isEmpty, memoize } from 'lodash';\nimport { isColor } from '@splunk/visualizations-shared/colorUtils';\nimport { DataType } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\n\n/**\n * returns true if this dataPoint is a finite number\n * @param dataPoint\n * @returns {*}\n */\nexport function isNumber(dataPoint): boolean {\n    return (\n        dataPoint !== null &&\n        !isBoolean(dataPoint) &&\n        dataPoint !== '' &&\n        isFinite(+dataPoint) &&\n        lodashIsNumber(+dataPoint)\n    );\n}\n\n/**\n *returns OK if data is time\n * @param dataPoint\n * @returns {boolean}\n */\nexport function isTime(dataPoint): boolean {\n    if (!dataPoint) {\n        return false;\n    }\n\n    // only support time string in following format: https://www.w3.org/TR/NOTE-datetime\n    const supportedDateFormats = [\n        'YYYY-MM-DD', // HTML5 date\n        moment.ISO_8601,\n        'YYYY-MM-DDTHH:mm', // HTML5 date local\n        'YYYY-MM-DDTHH:mm:ss.SSS', // HTML5 date local milliseconds\n        'YYYY-MM-DDTHH:mm:ss', // HTML5 date local seconds\n        'YYYY-MM-DD HH:MM',\n        'YYYY-MM-DD HH:MM:SS',\n        'YYYY-MM-DD HH:MM:SS.SSS',\n    ];\n    return typeof dataPoint === 'string'\n        ? moment(dataPoint, supportedDateFormats, true).isValid()\n        : moment(dataPoint).isValid();\n}\n\n/**\n * returns OK if data is string\n * @param dataPoint\n * @returns {boolean}\n */\nexport function isString(dataPoint): boolean {\n    return typeof dataPoint === 'string';\n}\n\n/**\n * getDataTypeForPoint\n * naive implementation of checking for the data type of a single data point\n * number > time > string > unknown\n * starting with number because a Date.parse(number) is a valid date\n *\n * @param {any} dataPoint\n * @param {object} metaData meta data about the data field\n * @return {string} type\n */\nexport const getDataTypeForPoint = <T>(dataPoint?: T, metaData?: { fieldName: string }): DataType => {\n    if (canInferTypeFromMeta(metaData)) {\n        return getDataTypeForMeta(metaData);\n    }\n    return memoizedGetDataTypeForValue(dataPoint);\n};\n\nconst getDataTypeForValue = <T>(dataPoint?: T): DataType => {\n    if (Array.isArray(dataPoint)) {\n        if (dataPoint.length > 1 && dataPoint[0] === '##__SPARKLINE__##') {\n            return 'sparkline';\n        }\n        return 'array';\n    } else if (isObject(dataPoint)) {\n        return 'unknown';\n    } else if (isNumber(dataPoint)) {\n        return 'number';\n    } else if (isColor(dataPoint)) {\n        return 'color';\n    } else if (isTime(dataPoint)) {\n        return 'time';\n    } else if (isString(dataPoint)) {\n        return 'string';\n    } else if (dataPoint === null) {\n        return 'null';\n    }\n    // objects, etc\n    return 'unknown';\n};\nconst memoizedGetDataTypeForValue = memoize(getDataTypeForValue);\n\nexport interface MetaData {\n    fieldName?: string;\n}\n/**\n * canInferTypeFromMeta\n * verifies whether a data type can be inferred from meta data\n * @param {object} metaData\n * @return {boolean} whether the data type can be inferred from meta\n */\nexport const canInferTypeFromMeta = (metaData: MetaData = {}): boolean => {\n    const { fieldName } = metaData;\n    return fieldName === '_time';\n};\n/**\n * getDataTypeForMeta\n * returns a data type based on meta data\n * @param {object} metaData\n * @return {string} type\n */\nexport const getDataTypeForMeta = (metaData: MetaData = {}): DataType => {\n    const { fieldName } = metaData;\n    if (fieldName === '_time') {\n        return 'time';\n    }\n    // this case should never be reached\n    return 'unknown';\n};\n\n/**\n * inferDataTypeFromSample\n * based on a number of data points this function determines the data type for all of them\n * and returns the most common data type (naive type inference)\n *\n * @param {Array} dataSample an array of arbitrary size containing data points of any data type\n * @return {string} type the most common type in the sample\n */\nexport const inferDataTypeFromSample = <T>(dataSample: T[]): DataType => {\n    const typeMatches: { [k in DataType]: number } = {\n        time: 0,\n        number: 0,\n        string: 0,\n        color: 0,\n        unknown: 0,\n        array: 0,\n        sparkline: 0,\n        null: 0,\n    };\n    dataSample.forEach((point): void => {\n        typeMatches[getDataTypeForPoint(point)] += 1;\n    });\n    let typeCount = 0;\n    let returnType = 'unknown';\n    Object.keys(typeMatches).forEach((key: DataType): void => {\n        if (typeMatches[key] > typeCount) {\n            typeCount = typeMatches[key];\n            returnType = key;\n        }\n    });\n    return returnType as DataType;\n};\n\n/**\n * based on a data array (e.g. one data column) this function returns a tiny sample of it\n * @TODO: very naive approach. there's papers with more advanced techniques but for now this should be very fast\n *\n * @param {Array} data to draw a sample from\n * @return {Array} a sample of the passed data\n */\nexport const drawSample = <T>(data: T[]): T[] => {\n    let sampleData: T[] = [];\n    if (data.length > 2) {\n        sampleData = [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];\n    } else {\n        sampleData = data;\n    }\n    return sampleData.map((point: T) =>\n        DataPoint.isDataPoint(point) ? point.getValue().originalValue : point\n    );\n};\n\n/**\n *\n * @param {*} data\n */\nexport const inferDataTypeFromData = <T>(data: T[]): DataType => inferDataTypeFromSample(drawSample(data));\n","module.exports = require(\"@splunk/moment\");","module.exports = require(\"@splunk/visualizations-shared/colorUtils\");","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","import { isEmpty, defaultsDeep, omit, omitBy, isUndefined } from 'lodash';\nimport numbro from 'numbro';\n// There is a mismatch between typedefinition of numbro and numbro export.\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst numbrofn = require('numbro');\nimport moment from '@splunk/moment';\n\nimport { AbstractFormatter } from '../Formatter';\nimport { DataType, TypedValue } from '../DataPrimitive';\nimport { TypeSafeValue } from '../TypeSafeValue';\nimport { DataPoint } from '../DataPoint';\n\nconst validUnitPositions = ['before', 'after'] as const;\ninterface NumberConfig extends numbro.Format {\n    unit?: string;\n    unitPosition?: typeof validUnitPositions[number];\n    precision?: number;\n}\n\ninterface StringConfig {\n    unit?: string;\n    unitPosition?: typeof validUnitPositions[number];\n}\n\ninterface TimeConfig {\n    format?: string;\n}\ninterface FormatByTypeConfig {\n    number: Partial<NumberConfig>;\n    string: Partial<StringConfig>;\n    time: Partial<TimeConfig>;\n}\n\nconst formatNumber = (number: number | string, config: NumberConfig): string => {\n    const mappedConfig = {\n        prefix: !isEmpty(config.unit) && config.unitPosition === 'before' ? `${config.unit} ` : undefined,\n        postfix: !isEmpty(config.unit) && config.unitPosition !== 'before' ? ` ${config.unit}` : undefined,\n        mantissa: typeof config.precision === 'number' ? config.precision : undefined,\n    };\n    const c: numbro.Format = defaultsDeep(\n        {},\n        omitBy(mappedConfig, isUndefined),\n        omit(config, ['unit', 'unitPosition', 'precision'])\n    );\n    return numbrofn(number).format(c);\n};\n\nconst formatString = (string: number | string, config: StringConfig): string => {\n    if (!isEmpty(config.unit)) {\n        return config.unitPosition === 'before' ? `${config.unit} ${string}` : `${string} ${config.unit}`;\n    }\n    return `${string}`;\n};\n\nconst timeToMoment = (time: any): typeof moment => {\n    // if splunk time zone is set, create time in splunk timezone and locale\n    if (moment.getDefaultSplunkTimezone()) {\n        return moment.newSplunkTime({ time: time.toString() });\n    }\n    // fallback to moment default\n    return moment(time);\n};\n\nconst formatTime = (dateObject: Date, defaultValue: number | string, config: TimeConfig): string => {\n    if (typeof config.format === 'string' && !isEmpty(config.format)) {\n        return timeToMoment(dateObject).format(config.format);\n    }\n    return defaultValue.toString();\n};\n\n/**\n * @class FormatByType\n * \n * Formats the value based on the value type and the provided config. For example \n * \n * ```js\n <Table\n    context = {{\n        formattedConfig: {\n            number: {\n                unit: '$',\n                unitPosition: 'before',\n                precision: 2,\n                thousandSeparated: true,\n            },\n        },\n    }}\n\n    options = {{\n        columnFormat: {\n            formatted: {\n                data: '> table | seriesByName(\"formatted\") | formatByType(formattedConfig)',\n            },\n        },\n    }}\n\n    dataSources = {{\n        primary: {\n            requestParams: { offset: 0, count: 20 },\n            data: {\n                fields: [\n                    { name: 'number' },\n                    { name: 'formatted' },\n                ],\n                columns: [\n                    [-927916.96, -924916.9, -654089.75],\n                    [-927916.96, -924916.9, -654089.75],\n                ],\n            },\n            meta: { totalCount: 100 },\n        },\n    }}\n />\n * ```\n *  \n *  ## Config Object\n * \n *  ### number\n * \n *  * **unit?**: `string` to be appended or prepended to the value\n *  * **unitPosition?**: `{\"before\" | \"after\"}` where should the `unit` be placed. Maps to numbro `prefix` or `postfix`\n *  * **numberPrecision?**: `number` maps to numbro `mantissa`\n *  * **mantissa?**: `number` number of decimal points to show\n *  * **trimMantissa?**: `boolean` ending 0s in decimal points will be trimmed\n *  * **thousandSeparated?**: `boolean` should show `,` for thousands\n *  * **output?**: `\"currency\" | \"percent\" | \"byte\" | \"time\" | \"ordinal\" | \"number\"` value will be converted to one of thse formats\n *  * **base?**: `\"decimal\" | \"binary\" | \"general\"` used for converting value to bytes\n *  * **prefix?**: `string` string to be added in front of the value\n *  * **postfix?**: `string` string to be appended to the value\n *  * **forceAverage?**: `\"trillion\" | \"billion\" | \"million\" | \"thousand\"` can be used to force one the selected average\n *  * **average?**: `boolean` rounds up the value to the closed average\n *  * **totalLength?**: `number` used only for `average`. The number length to format data in\n *  * **spaceSeparated?**: `boolean` used with `average` to introduce space between number and average\n *  * **abbreviations?**: `{\n        thousand?: string;\n        million?: string;\n        billion?: string;\n        trillion?: string;\n    }` abbreviation values for averages.\n *  * **negative?**: `\"sign\" | \"parenthesis\"` display sign or parenthesis for negative numbers\n *  * **forceSign?**: `boolean` always show + or - sign\n * \n * \n *  * For examples, refer [Numbro](https://numbrojs.com/format.html#format) or [tests](https://cd.splunkdev.com/devplat/vision/-/blob/main/packages/visualization-encoding/src/formatters/FormatByType.test.ts)\n * \n * #### time\n * \n *  * **format**: valid moment format string.  Refer - [moment display](https://momentjs.com/docs/#/displaying/)\n * \n * \n * \n \n */\nexport class FormatByType extends AbstractFormatter {\n    private config: FormatByTypeConfig = { number: {}, string: {}, time: { format: '' } };\n\n    constructor(config: Record<string, unknown>) {\n        super();\n        this.config = defaultsDeep({}, config, this.config);\n    }\n\n    protected formatTypedValue(p: DataPoint): TypedValue<DataType> {\n        const { number: numberConfig, string: stringConfig, time: timeConfig } = this.config;\n        const value = p.getValue();\n        switch (value.type) {\n            case 'number':\n                return new TypeSafeValue(\n                    'string',\n                    formatNumber(p.getRawValue(), numberConfig),\n                    true,\n                    value.originalValue\n                );\n            case 'string':\n                return new TypeSafeValue(\n                    'string',\n                    formatString(value.value, stringConfig),\n                    true,\n                    value.originalValue\n                );\n            case 'time':\n                return new TypeSafeValue(\n                    'string',\n                    formatTime(value.value, value.originalValue, timeConfig),\n                    true,\n                    value.originalValue\n                );\n            default:\n                return p.getValue();\n        }\n    }\n}\n","module.exports = require(\"numbro\");"],"sourceRoot":""}