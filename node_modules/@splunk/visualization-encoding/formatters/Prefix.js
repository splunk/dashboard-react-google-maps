/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 29);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _construct = __webpack_require__(19);

var _toConsumableArray = __webpack_require__(13);

var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var lodash_1 = __webpack_require__(7);

var AST_1 = __webpack_require__(40);

var FormatterPresets_1 = __webpack_require__(20);

var DataPrimitive_1 = __webpack_require__(18);

var TypeSafeValue_1 = __webpack_require__(10);

var DataPoint_1 = __webpack_require__(3);

var OptionScopes_1 = __webpack_require__(43);

var DslParser_1 = __webpack_require__(22);

var EncodingParser_1 = __webpack_require__(46);

var Helper_1 = __webpack_require__(16);
/**
 * Class with static methods used to execute DSL expressions
 */


var EncodingExecutor = /*#__PURE__*/function () {
  function EncodingExecutor() {
    _classCallCheck(this, EncodingExecutor);
  }

  _createClass(EncodingExecutor, [{
    key: "executeOptions",
    value: function executeOptions(optionsStanza, frames, themeFunc) {
      var ret = lodash_1.cloneDeep(optionsStanza); // evaluate DSL expressions, in place, in ret object

      var scopes = new OptionScopes_1.OptionScopes(ret, frames, themeFunc);
      this.eval(ret, scopes);
      return EncodingExecutor.rawTree(ret.options);
    }
    /**
     * o is what we are evaluating. If it is an array or an object that its parts are recursively
     * evaluated. Any DSL expressions encountered are evaluated. The scopes object is uses by the
     * DSL expression to resolve any identifiers. The scope object's 'local' scope is updated by
     * pushLocalScope as the eval method moves through the tree. The path array for a path "context.a.b.c"
     * will be ['context', 'a', 'b','c']. As eval moves through the tree, the scopes add the current
     * path its visited list. If the current path is found in the visited list, then a circular reference
     * error is thrown.
     * current 'path' in the
     * @param o
     * @param {OptionScopes} scopes
     * @param {string[]} path
     * @returns {any}
     */

  }, {
    key: "eval",
    value: function _eval(o, scopes) {
      var _this = this;

      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      scopes.pushLocalScope(o);
      scopes.addToVisitedList(path); // evaluate array or option fields, and write the resulting value back into object o

      if (Array.isArray(o)) {
        //evaluate each array element
        o.forEach(function (v, i) {
          path.push(i.toString());
          o[i] = _this.eval(o[i], scopes, path);
          path.pop();
        });
      } else if (lodash_1.isPlainObject(o)) {
        //evaluate each object field
        Object.keys(o).forEach(function (k) {
          path.push(k);
          o[k] = _this.eval(o[k], scopes, path);
          path.pop();
        });
      } else if (EncodingParser_1.default.isDslString(o)) {
        scopes.popLocalScope();
        var tmp = this.evalDsl(o, scopes);
        scopes.removeFromVisitedList(path);
        return tmp;
      } //if here then o is js primitive value or DataPrimitive.


      scopes.popLocalScope();
      scopes.removeFromVisitedList(path);
      return o;
    }
  }, {
    key: "evalDsl",
    value: function evalDsl(dsl, scopes) {
      try {
        var parsedDsl = DslParser_1.DslParser.parse(EncodingParser_1.default.withoutArrow(dsl));
        return this.execOptionsPipeline(parsedDsl, scopes, scopes.frames['primary']);
      } catch (e) {
        console.log("dsl error: ".concat(e.message));
        return undefined;
      }
    }
    /**
     * Takes anything that can have DSL embedded in it, such as tree or array, and insures
     * that all DataPrimitive have been converted to their 'raw' equivalents
     * @param {object} o
     * @returns {any}
     */

  }, {
    key: "execOptionsPipeline",
    value:
    /**
     * Executes sequence of pipe delimited expressions that constitute a DSL
     * @param {Expr[]} pipeline
     * @param {OptionScopes} scopes
     * @param {DataPrimitive<DataType>} origin
     * @param {ExecutedOptions} executedOptions
     * @returns {{location: string; val: Option | DataPrimitive}}
     */
    function execOptionsPipeline(pipeline, scopes, origin // meta fields default to the value DataPrimitve as origin. Value field default to frames.primary as their origin
    ) {
      var _this2 = this;

      var subject = origin; //process each expression in pipeline expr|expr|expr...

      pipeline.forEach(function (expr, i) {
        if (expr.type === 'method') {
          subject = _this2.executeMethod(expr, subject, scopes.context);
        } else if (expr.type === 'identifier') {
          //When an identifier exists in the pipeline line like delta in 'delta|foo(bar)' it can refer to
          //either a DataPrimitive or a SimpleOption.
          subject = scopes.resolve(expr.v.toString()).val;
        } else if (AST_1.LITERAL_TYPES.includes(expr.type)) {
          var tsv = TypeSafeValue_1.TypeSafeValue.from({
            type: expr.type,
            value: expr.v
          });
          subject = new DataPoint_1.DataPoint('', tsv);
        }

        var isLastInPipeline = i === pipeline.length - 1; //if the subject will pass forward through another pipe, we must convert it to a DataPrimtive

        if (!isLastInPipeline && !DataPrimitive_1.isDataPrimitive(subject)) {
          try {
            subject = Helper_1.Helper.dataPrimitiveFromRaw(subject);
          } catch (e) {
            var exprStr = expr['v'] ? expr['v'] : expr['name'];
            throw new Error("Output of '".concat(exprStr, "' cannot be piped because it is not a DataFrame, DataPoint, or DataSeries"));
          }
        }
      });
      return subject;
    }
    /**
     * Methods are either selector methods that built-ins such as
     * 'selectSeriesByPosition(...)",or they are formatter calls like 'rangeValue(...)'
     * @param {Method} expr
     * @param {DataPrimitive} subject
     * @param {Scopes} scopes
     * @param {string} metaName
     * @returns {DataPrimitive}
     */

  }, {
    key: "executeMethod",
    value: function executeMethod(expr, subject, context) {
      var m = expr;

      if (!subject) {
        throw new Error("Pipeline composition error: method ".concat(m.name, " has no subject"));
      }

      var args = this.args(m.args, context);
      var method = subject[m.name];

      if (method) {
        subject = method.apply(subject, args); //'built in' DataPrimitive selectors like selectSeriesByPosition
      } else {
        subject = this.applyFormatter(subject, m.name, args);
      }

      return subject;
    }
    /**
     * Applies the Formatter to either metaData or value
     * @param {DataPrimitive} subject
     * @param {string} funcName
     * @param {ResolvedValue[]} args
     * @param {string} metaName
     */

  }, {
    key: "applyFormatter",
    value: function applyFormatter(subject, funcName, args) {
      var formatterClass = FormatterPresets_1.formatterClasses[funcName];

      if (formatterClass) {
        return _construct(formatterClass, _toConsumableArray(args)).format(subject);
      } else {
        throw Error("No such method or formatter function: '".concat(funcName, "'"));
      }
    }
    /**
     * Sometimes when invoking a pipeline we may find degenerate pipelines like
     * '42' that simply set the metadata to a literal. Or, we may perhaps in
     * a value pipeline, we set the value to 'hello' after w perform selection
     * like "selectByPosition(0)|'hello'"
     * @param {DataPrimitive} subject
     * @param {LiteralSymbol} symbol
     */

  }, {
    key: "applyLiteral",
    value: function applyLiteral(subject, symbol) {
      var type = symbol.type,
          value = symbol.v;
      subject.setValue({
        type: type,
        value: value
      });
    }
    /**
     * reduces method call arguments (ParserSymbols) to actual values
     * @param {ParserSymbol[]} args
     * @param {Scopes} scopes
     * @returns {any[]}
     */

  }, {
    key: "args",
    value: function args(_args, context) {
      var _this3 = this;

      return _args.reduce(function (acc, cur) {
        var v = _this3.getArg(cur, context);

        acc.push(v);
        return acc;
      }, []);
    }
    /**
     * Returns either the literal value from the symbol, or a value from context.
     * Throws error if identifier not found in context.
     * @param {ParserSymbol} s
     * @param {object} context
     * @returns {any}
     */

  }, {
    key: "getArg",
    value: function getArg(s, context) {
      if (s.type === 'identifier') {
        //fixme todo this should use a proper 'resolve' not just look into context
        var val = context[s.v];

        if (!val) {
          throw Error("Could not resolve ".concat(s.v, " in context. Did you mean one of '[").concat(Object.keys(context).toString(), "]'"));
        }

        return val;
      } else {
        return s.v;
      }
    }
    /**
     * Simple method to tell if the argument is an object or primitive.
     * @param opt
     * @returns {boolean}
     */

  }], [{
    key: "rawTree",
    value: function rawTree(o) {
      // evaluate array or option fields, and write the resulting value back into object o
      if (Array.isArray(o)) {
        //evaluate each array element
        o.forEach(function (v, i) {
          o[i] = EncodingExecutor.rawTree(o[i]);
        });
        return o;
      } else if (lodash_1.isPlainObject(o)) {
        // use isPlainObject to avoid traversing fields of funky options like IconComponent that have methods and circular reference graph
        //evaluate each object field. Such objects would never expect to have DSL embedded in them and will cause a stack overflow due to cycles
        Object.keys(o).forEach(function (k) {
          o[k] = EncodingExecutor.rawTree(o[k]);
        });
        return o;
      } else {
        var tmp = DataPrimitive_1.isDataPrimitive(o) ? o.getRawValue() : o;
        return tmp;
      }
    }
  }, {
    key: "isObject",
    value: function isObject(opt) {
      return Object(opt) === opt;
    }
  }]);

  return EncodingExecutor;
}();

exports.default = EncodingExecutor;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataPoint = void 0;

var TypeSafeValue_1 = __webpack_require__(10);
/**
 * Base DataPoint class and associated DataPoint selectors
 * @implements {DataPrimitive}
 * @implements {IDataPoint}
 */


var DataPoint = /*#__PURE__*/function () {
  /**
   *
   * @param {string} field data field
   * @param {object} value data value + it's type (number, string, time or color)
   * @param {object} meta meta data (value + type) associated with the data point
   */
  function DataPoint(field, value) {
    _classCallCheck(this, DataPoint);

    this.field = field;
    this.setValue(value);
  }

  _createClass(DataPoint, [{
    key: "getValue",
    value: function getValue() {
      return this.value;
    }
    /**
     * sets the data point's value to a static TypedValue
     * @param {TypedValue} v
     */

  }, {
    key: "setValue",
    value: function setValue(v) {
      this.value = TypeSafeValue_1.TypeSafeValue.from(v);
    }
    /**
     * get only value of the data point
     * @returns {string|number|null}
     */

  }, {
    key: "getRawValue",
    value: function getRawValue() {
      return this.value.toRawValue();
    }
    /**
     * Returns the datatype of the point
     * @public
     * @returns {DataPoint<'string'>}
     */

  }, {
    key: "getField",
    value: function getField() {
      return DataPoint.fromRaw(this.field);
    }
  }], [{
    key: "isDataPoint",
    value: function isDataPoint(o) {
      return o instanceof DataPoint;
    }
  }, {
    key: "fromRaw",
    value: function fromRaw(value) {
      return new DataPoint('', TypeSafeValue_1.TypeSafeValue.fromRaw(value));
    }
  }]);

  return DataPoint;
}();

exports.DataPoint = DataPoint;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/inherits");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/possibleConstructorReturn");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/getPrototypeOf");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractFormatter = void 0;

var DataFrame_1 = __webpack_require__(11);

var DataSeries_1 = __webpack_require__(9);

var DataPoint_1 = __webpack_require__(3);

var AbstractFormatter = /*#__PURE__*/function () {
  function AbstractFormatter() {
    _classCallCheck(this, AbstractFormatter);
  }

  _createClass(AbstractFormatter, [{
    key: "format",
    value: function format(dataPrimitive) {
      var _this = this;

      if (dataPrimitive instanceof DataFrame_1.DataFrame) {
        var newSeries = [];
        dataPrimitive.series.forEach(function (dataSeries, i) {
          newSeries.push(_this.formatSeries(dataSeries, i));
        });
        return new DataFrame_1.DataFrame(newSeries);
      } else if (dataPrimitive instanceof DataSeries_1.DataSeries) {
        return this.formatSeries(dataPrimitive);
      } else {
        return this.formatPoint(dataPrimitive);
      }
    }
  }, {
    key: "formatSeries",
    value: function formatSeries(s) {
      var _this2 = this;

      var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var newPoints = [];
      s.points.forEach(function (dataPoint, j) {
        newPoints.push(_this2.formatPoint(dataPoint, s, i, j));
      });
      return new DataSeries_1.DataSeries(newPoints); // new DataSeries must have the type of the formatter's output
    }
  }, {
    key: "formatPoint",
    value: function formatPoint(p, s) {
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var j = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var field = p.field;
      var tmp = this.formatTypedValue(p, s, i, j);
      return new DataPoint_1.DataPoint(field, tmp);
    }
  }, {
    key: "makeArrays2D",
    value: function makeArrays2D(a) {
      if (Array.isArray(a)) {
        if (Array.isArray(a[0])) {
          return a;
        } else {
          return [a];
        }
      }

      throw new Error("argument wasn't array");
    }
  }]);

  return AbstractFormatter;
}();

exports.AbstractFormatter = AbstractFormatter;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataSeries = void 0;

var DataPoint_1 = __webpack_require__(3);
/**
 * DataSeries class and associated DataSeries selectors
 * @implements {DataPrimitive}
 */


var DataSeries = /*#__PURE__*/function () {
  /**
   *
   * @param {array} points list of data points
   */
  function DataSeries() {
    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, DataSeries);

    this.points = points;

    if (points.length > 0) {
      this.field = points[0].field; // the field is an immutable property of the series
    }
  }

  _createClass(DataSeries, [{
    key: "firstPoint",
    value:
    /**
     * return first dataPoint in series
     * @public
     * @returns {DataPoint}
     */
    function firstPoint() {
      return this.points[0];
    }
    /**
     * return last dataPoint in series
     * @public
     * @returns {DataPoint}
     */

  }, {
    key: "lastPoint",
    value: function lastPoint() {
      return this.points.slice(-1)[0];
    }
    /**
     * finds dataPoint(s) in DataSeries by index(es)
     * @public
     * @param {...number} indexes
     * @returns {DataSeries}
     */

  }, {
    key: "pointsByIndexes",
    value: function pointsByIndexes() {
      var _this = this;

      var indexedPoints = [];

      for (var _len = arguments.length, indexes = new Array(_len), _key = 0; _key < _len; _key++) {
        indexes[_key] = arguments[_key];
      }

      indexes.forEach(function (index) {
        var dp = _this.points[index]; // should we allow negative indexes?

        if (dp != null) {
          indexedPoints.push(dp);
        }
      });
      return new DataSeries(indexedPoints);
    }
    /**
     * finds and returns the individual dataPoint at the given index
     * @public
     * @param {number} index
     * @returns {DataPoint}
     */

  }, {
    key: "pointByIndex",
    value: function pointByIndex(index) {
      if (index < 0 || index >= this.points.length) {
        // will handle negative and out-of-range indexes for the time being by returning null
        return null;
      }

      var dp = this.points[index];
      var field = dp.field;

      var _dp$getValue = dp.getValue(),
          type = _dp$getValue.type,
          value = _dp$getValue.value;

      return new DataPoint_1.DataPoint(field, {
        type: type,
        value: value
      });
    }
    /**
     * finds the delta between the last point and point at the given index.
     * a negative index can be used, indicating an offset from the end of the sequence
     * @public
     * @param {number} index
     * @returns {DataPoint}
     */

  }, {
    key: "delta",
    value: function delta(index) {
      var dp1 = this.lastPoint();

      if (dp1 === undefined) {
        return undefined;
      }

      var field = dp1.field;

      var _dp1$getValue = dp1.getValue(),
          type = _dp1$getValue.type,
          val1 = _dp1$getValue.value;

      if (type !== 'number') {
        console.warn("delta cannot be computed for non-numerical data series of type ".concat(type)); // Throw an error and catch in pipeline executor?
      }

      var dp2 = null; // use undefined as default, because null values will be coerced to 0 (thus invalid indexes return a delta of 0)
      // for aggregate SPL queries like `stats count`, we want no trend value rather than 0 as the trend value

      var delta;

      if (index >= 0) {
        dp2 = this.points[index];
      } else {
        dp2 = this.points.slice().reverse()[Math.abs(index) - 1];
      }

      if (dp2 == null) {
        console.warn('invalid index'); // Throw an error and catch in pipeline executor?
      } else {
        var _dp2$getValue = dp2.getValue(),
            val2 = _dp2$getValue.value;

        delta = val1 - val2;
      }

      return new DataPoint_1.DataPoint(field, {
        type: type,
        value: delta
      }); // create a new data point since we don't want meta data to carry over
    }
    /**
     * sets all the values in the Data Series to a static TypedValue
     * @param {TypedValue} v
     */

  }, {
    key: "setValue",
    value: function setValue(v) {
      this.points.forEach(function (p) {
        p.setValue(v);
      });
    }
    /**
     * gets all the values + their type in the Data Series
     * @returns {TypedValue[]}
     */

  }, {
    key: "getValue",
    value: function getValue() {
      var values = [];
      this.points.forEach(function (p) {
        values.push(p.getValue());
      });
      return values;
    }
    /**
     * gets all the values (only) in the Data Series
     * @returns {array}
     */

  }, {
    key: "getRawValue",
    value: function getRawValue() {
      var values = [];
      this.points.forEach(function (p) {
        values.push(p.getRawValue());
      });
      return values;
    }
    /**
     * Returns the uniform type of the series
     * @public
     * @returns {DataPoint<'string'>}
     */

  }, {
    key: "getField",
    value: function getField() {
      var dp1 = this.lastPoint();
      return dp1.getField();
    }
    /**
     * returns the minimum DataPoint in the series or undefined if no numbers in series
     * @public
     * @returns {DataPoint<T>}
     */

  }, {
    key: "min",
    value: function min() {
      return this.reduce(function (v1, v2) {
        return v1 < v2;
      });
    }
    /**
     * returns the maximum DataPoint in the series
     * @public
     * @returns {DataPoint<T>}
     */

  }, {
    key: "max",
    value: function max() {
      return this.reduce(function (v1, v2) {
        return v1 > v2;
      });
    }
  }, {
    key: "reduce",
    value: function reduce(comparator) {
      return this.points.reduce(function (agg, cur) {
        // note: cannot use agg.getRawValue here instead of agg.value.value as that limits returned value to string|number
        return !agg || comparator(cur.getValue().value, agg.getValue().value) ? cur : agg;
      }, undefined);
    }
  }], [{
    key: "isDataSeries",
    value: function isDataSeries(o) {
      return o instanceof DataSeries;
    }
  }, {
    key: "fromRaw",
    value: function fromRaw(pts) {
      return new DataSeries(pts.map(function (p) {
        return DataPoint_1.DataPoint.fromRaw(p);
      }));
    }
  }]);

  return DataSeries;
}();

exports.DataSeries = DataSeries;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = __webpack_require__(23);

var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeSafeValue = void 0;

var colorUtils_1 = __webpack_require__(15);

var types_1 = __webpack_require__(12);

var moment_1 = __webpack_require__(14);
/**
 * @implements {TypedValue}
 * TypeSafeValue implements the TypedValue interface, and adds additional methods 'isOk' which can be used to determine
 * if the value was properly coerced into the expected type. When isOk is false, it means that coerced value cannot
 * be relied upon. For example, if the type is 'time' but isOk is false, it is possible that the coerced value could be NaN.
 * A field named originalValue can be used for user-facing error messages in situations where isOk is false. For example:
 * "'cat' was not an OK value for a 'time' field". This class's fields are all immutable.
 */


var TypeSafeValue = /*#__PURE__*/function () {
  function TypeSafeValue(type, value, isOk, originalValue) {
    _classCallCheck(this, TypeSafeValue);

    /**
     * isTypeSafe. This is a marker field. The presence of this field can be used at runtime to determine if TypedValue is rigorous,
     * loose. Loose TypedValue such as {type:'number', value:'cat'} are handy for testing, but can lie. Obviously 'cat'
     * is not a number. If the isTypeSafe field is present then the instance is a TypeSafeValue
     * @type {boolean}
     */
    this.isTypeSafe = true;
    /**
     * isOk. This field tells if the original value passed into this's constructor honored its type contract.
     * @type {boolean}
     */

    this.isOk = true;
    this.type = type;
    this.value = value;
    this.isOk = isOk;
    this.originalValue = originalValue;
  }
  /**
   * returns a TypeSafeValue, either by converting the non TypeSafeValue to
   * a TypeSafeValue, or by simply returning the passed-in TypeSafeValue
   * @param {TypedValue<T>} typedValue
   * @returns {TypeSafeValue<T>}
   */


  _createClass(TypeSafeValue, [{
    key: "toRawValue",
    value: function toRawValue() {
      switch (this.type) {
        case 'time':
          return moment_1.default(this.value).format();

        case 'sparkline':
        case 'array':
        case 'number':
        case 'string':
        case 'color':
        default:
          return this.value;
      }
    }
  }], [{
    key: "from",
    value: function from(typedValue) {
      if (typedValue.isTypeSafe) {
        return typedValue; // just return what was passed in since it is already TypeSafeValue
      } else {
        var originalValue = typedValue.value,
            type = typedValue.type;

        var _TypeSafeValue$coerce = TypeSafeValue.coerceValue(typedValue),
            _TypeSafeValue$coerce2 = _slicedToArray(_TypeSafeValue$coerce, 2),
            value = _TypeSafeValue$coerce2[0],
            isOk = _TypeSafeValue$coerce2[1];

        return new TypeSafeValue(type, value, isOk, originalValue);
      }
    }
    /**
     * Creates a TypeSafeValue from a raw value
     * @param value
     * @returns {TypeSafeValue<DataType>}
     */

  }, {
    key: "fromRaw",
    value: function fromRaw(value) {
      var type = types_1.getDataTypeForPoint(value);
      return new TypeSafeValue(type, value, true, value);
    }
    /**
     * attempts to coerce the provided value to the provided type. Returns tuple
     * of the coerced value and a boolean telling if the coercion was clean (true)
     * or if the coercion was likely produced an unusable result, such as NaN for
     * a number, or '' for a color.
     * @param {TypedValue<T>} typedValue
     * @returns {[any, boolean]}
     */

  }, {
    key: "coerceValue",
    value: function coerceValue(typedValue) {
      var type = typedValue.type,
          value = typedValue.value;
      var coercedVal = null;
      var isOk;
      var acceptableType = true;

      try {
        switch (type) {
          case 'number':
            {
              isOk = types_1.isNumber(value);
              coercedVal = Number(value);
              break;
            }

          case 'time':
            {
              isOk = types_1.isTime(value);

              if (value instanceof Date) {
                coercedVal = value;
              } else {
                // for case like `VM-203`, It will be convereted to a Date.
                coercedVal = isOk ? new Date(value) : 'Invalid Date';
              }

              break;
            }

          case 'string':
            {
              isOk = types_1.isString(value);
              coercedVal = value.toString();
              break;
            }

          case 'color':
            {
              isOk = colorUtils_1.isColor(value);
              coercedVal = value;
              break;
            }

          case 'sparkline':
            {
              isOk = Array.isArray(value) && value[0] === '##__SPARKLINE__##';
              coercedVal = value;
              break;
            }

          case 'array':
            {
              isOk = Array.isArray(value);
              coercedVal = value;
              break;
            }

          case 'null':
            {
              isOk = value === null;
              coercedVal = value;
              break;
            }

          default:
            {
              acceptableType = false;
            }
        }
      } catch (e) {
        isOk = false;
      }

      if (!acceptableType) {
        throw new Error("unknown type: '".concat(type, "'"));
      }

      return [coercedVal, isOk];
    }
  }]);

  return TypeSafeValue;
}();

exports.TypeSafeValue = TypeSafeValue;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataFrame = void 0;

var DataPoint_1 = __webpack_require__(3);

var DataSeries_1 = __webpack_require__(9);

var types_1 = __webpack_require__(12);
/**
 * Base DataFrame class and associated DataFrame selectors
 * @implements {DataPrimitive}
 */


var DataFrame = /*#__PURE__*/function () {
  /**
   * @param {array} series list of data series
   */
  function DataFrame(series) {
    _classCallCheck(this, DataFrame);

    this.series = Array.isArray(series) ? series : [series];
  }
  /**
   * @param {any} o
   * @returns {boolean}
   */


  _createClass(DataFrame, [{
    key: "frameBySeriesIndexes",
    value:
    /**
     * finds series in DataFrame by index(es)
     * @public
     * @param {number[]} indexes
     * @returns {DataFrame}
     */
    function frameBySeriesIndexes() {
      var _this = this;

      var indexedSeries = [];

      for (var _len = arguments.length, indexes = new Array(_len), _key = 0; _key < _len; _key++) {
        indexes[_key] = arguments[_key];
      }

      indexes.forEach(function (index) {
        var ds = _this.series[index]; // should we allow negative indexes?

        if (ds != null) {
          indexedSeries.push(ds);
        }
      });
      return new DataFrame(indexedSeries);
    }
    /**
     *  Returns the data series at the given index
     * @public
     * @param {number} index
     * @returns {DataSeries<T>}
     */

  }, {
    key: "seriesByIndex",
    value: function seriesByIndex(index) {
      return this.series[index];
    }
    /**
     * Returns a DataFrame that is a slice of this DataFrame's series from  [start, end)
     * @public
     * @param {int} start (inclusive)
     * @param {int} end (optional, exclusive)
     * @returns {DataFrame<T>}
     */

  }, {
    key: "frameBySeriesIndexRange",
    value: function frameBySeriesIndexRange(start, end) {
      return new DataFrame(this.series.slice(start, end));
    }
    /**
     * Returns a DataFrame having only the DataSeries matching the provided names
     * @public
     * @param {string[]} names
     * @returns {DataFrame<T>}
     */

  }, {
    key: "frameBySeriesNames",
    value: function frameBySeriesNames() {
      var _this2 = this;

      var namedSeries = [];

      for (var _len2 = arguments.length, names = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        names[_key2] = arguments[_key2];
      }

      names.forEach(function (name) {
        var found = _this2.seriesByName(name);

        found && namedSeries.push(found);
      });
      return new DataFrame(namedSeries);
    }
    /**
     * Returns a DataFrame having the DataSeries matching provided names or indexes
     * @public
     * @param {...(string|number)} namesOrIndexes
     * @returns {DataFrame<T>}
     */

  }, {
    key: "frameBySeriesNamesOrIndexes",
    value: function frameBySeriesNamesOrIndexes() {
      var _this3 = this;

      var mixedSeries = [];

      for (var _len3 = arguments.length, mixed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        mixed[_key3] = arguments[_key3];
      }

      mixed.forEach(function (nameOrIndex) {
        var asNumber = Number(nameOrIndex);

        if (Number.isNaN(asNumber)) {
          var found = _this3.seriesByName(nameOrIndex);

          found && mixedSeries.push(found);
        } else {
          var _found = _this3.series[asNumber];
          _found && mixedSeries.push(_found);
        }
      });
      return new DataFrame(mixedSeries);
    }
    /**
     * Returns a DataFrame containing DataSeries that match only the provided types
     * @public
     * @param {T[]} types
     * @returns {DataFrame<T>}
     */

  }, {
    key: "frameBySeriesTypes",
    value: function frameBySeriesTypes() {
      for (var _len4 = arguments.length, types = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        types[_key4] = arguments[_key4];
      }

      return new DataFrame(this.series.filter(function (s) {
        return types.includes(s.firstPoint().getValue().type);
      }) //fixme todo we should have a getType() method on a series. SHould not make 'decision' about what type the series is from outside the series
      );
    }
    /**
     * finds series in DataFrame by field name
     * @public
     * @param {string} field
     * @returns {DataSeries<T>}
     */

  }, {
    key: "seriesByName",
    value: function seriesByName(field) {
      return this.series.find(function (dataSeries) {
        return field === dataSeries.field;
      });
    }
    /**
     * finds series in DataFrame by first data type match
     * @public
     * @param {T} type
     * @returns {DataSeries<T>}
     */

  }, {
    key: "seriesByType",
    value: function seriesByType(type) {
      return this.series.find(function (dataSeries) {
        var dataType = types_1.inferDataTypeFromData(dataSeries.points);
        return dataType === type;
      });
    }
    /**
     * finds series in DataFrame with the providing prioritized types
     * @public
     * @param {T[]} types T extends from DataType, which is 'number' | 'string' | 'color' | 'time' | 'unknown' | 'sparkline' | 'array' | 'null'
     * @returns {DataSeries<T>}
     */

  }, {
    key: "seriesByPrioritizedTypes",
    value: function seriesByPrioritizedTypes() {
      var _a;

      for (var _len5 = arguments.length, types = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        types[_key5] = arguments[_key5];
      }

      for (var _i = 0, _types = types; _i < _types.length; _i++) {
        var type = _types[_i];
        var matchedSeries = this.seriesByType(type);

        if (Array.isArray(matchedSeries === null || matchedSeries === void 0 ? void 0 : matchedSeries.points) && ((_a = matchedSeries === null || matchedSeries === void 0 ? void 0 : matchedSeries.points) === null || _a === void 0 ? void 0 : _a.length)) {
          return matchedSeries;
        }
      }

      return this.series[0];
    }
    /**
     * sets all the values in the DataFrame to a static TypedValue
     * @public
     * @param {TypedValue} v
     */

  }, {
    key: "setValue",
    value: function setValue(v) {
      this.series.forEach(function (s) {
        return s.setValue(v);
      });
    }
    /**
     * gets all the values (only) in the Data Frame
     * @public
     * @returns {array}
     */

  }, {
    key: "getRawValue",
    value: function getRawValue() {
      var values = [];
      this.series.forEach(function (s) {
        values.push(s.getRawValue());
      });
      return values;
    }
    /**
     * gets all the values + their types in the Data Frame
     * @public
     * @returns {TypedValue[][]}
     */

  }, {
    key: "getValue",
    value: function getValue() {
      var values = [];
      this.series.forEach(function (s) {
        values.push(s.getValue());
      });
      return values;
    }
    /**
     * Get the field names of each series in frame
     * @public
     * @returns {DataSeries<'string'>}
     */

  }, {
    key: "getField",
    value: function getField() {
      var points = this.series.map(function (s) {
        return s.getField();
      });
      return new DataSeries_1.DataSeries(points);
    }
    /**
     * finds the global minimum value (from all numerical series) in the Data Frame
     * @public
     * @returns {number}
     */

  }, {
    key: "min",
    value: function min() {
      return this.minOrMax('min');
    }
    /**
     * finds the global maximum value (from all numerical series) in the Data Frame
     * @public
     * @returns {number}
     */

  }, {
    key: "max",
    value: function max() {
      return this.minOrMax('max');
    }
    /**
     * runs result of min or max function over all the series and returns the data point
     * points
     * @param {string} aggName
     * @returns {DataPoint<T>}
     */

  }, {
    key: "minOrMax",
    value: function minOrMax(funcName) {
      var overallSeries = new DataSeries_1.DataSeries();
      this.series.forEach(function (s) {
        var m = s[funcName]();
        m && overallSeries.points.push(m);
      });
      return overallSeries[funcName]();
    }
  }], [{
    key: "isDataFrame",
    value: function isDataFrame(o) {
      return o instanceof DataFrame;
    }
    /**
     * Loads ColumnarData into a DataFrame
     * @param {ColumnarData} columnarData
     * @returns {DataFrame<T>}
     */

  }, {
    key: "fromJsonCols",
    value: function fromJsonCols(columnarData) {
      if (!columnarData || columnarData.data === null) {
        return new DataFrame([]);
      } // fixme todo why do we expect an object like {data:{fields, columns}}? Why don't we just expect something like {fields, columns}? The nesting inside 'data' feels useless


      var _columnarData$data = columnarData.data,
          _columnarData$data$fi = _columnarData$data.fields,
          fields = _columnarData$data$fi === void 0 ? [] : _columnarData$data$fi,
          _columnarData$data$co = _columnarData$data.columns,
          columns = _columnarData$data$co === void 0 ? [] : _columnarData$data$co;

      if (columns.length !== fields.length) {
        throw new Error("number of columns (".concat(columns.length, ") does not match number of fields (").concat(fields.length, ")"));
      }

      var dataSeries = [];
      columns.forEach(function (data, idx) {
        var dataPoints = [];
        var fieldInfo = fields[idx];
        var fieldName = fieldInfo.name || fieldInfo;
        data.forEach(function (value) {
          var dataType = types_1.getDataTypeForPoint(value, {
            fieldName: fieldName
          });
          dataPoints.push(new DataPoint_1.DataPoint(fieldName, {
            value: value,
            type: dataType
          }));
        });
        dataSeries.push(new DataSeries_1.DataSeries(dataPoints));
      });
      return new DataFrame(dataSeries);
    }
  }, {
    key: "fromRaw",
    value: function fromRaw(f) {
      var series = [];
      f.forEach(function (s) {
        series.push(DataSeries_1.DataSeries.fromRaw(s));
      });
      return new DataFrame(series);
    }
  }, {
    key: "fromDataPrimitive",
    value: function fromDataPrimitive(dp) {
      if (DataFrame.isDataFrame(dp)) {
        return dp;
      } else if (DataSeries_1.DataSeries.isDataSeries(dp)) {
        return new DataFrame([dp]);
      } else if (DataPoint_1.DataPoint.isDataPoint(dp)) {
        return new DataFrame([new DataSeries_1.DataSeries([dp])]);
      }
    }
  }]);

  return DataFrame;
}();

exports.DataFrame = DataFrame;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inferDataTypeFromData = exports.drawSample = exports.inferDataTypeFromSample = exports.getDataTypeForMeta = exports.canInferTypeFromMeta = exports.getDataTypeForPoint = exports.isString = exports.isTime = exports.isNumber = void 0;

var moment_1 = __webpack_require__(14);

var lodash_1 = __webpack_require__(7);

var colorUtils_1 = __webpack_require__(15);

var DataPoint_1 = __webpack_require__(3);
/**
 * returns true if this dataPoint is a finite number
 * @param dataPoint
 * @returns {*}
 */


function isNumber(dataPoint) {
  return dataPoint !== null && !lodash_1.isBoolean(dataPoint) && dataPoint !== '' && lodash_1.isFinite(+dataPoint) && lodash_1.isNumber(+dataPoint);
}

exports.isNumber = isNumber;
/**
 *returns OK if data is time
 * @param dataPoint
 * @returns {boolean}
 */

function isTime(dataPoint) {
  if (!dataPoint) {
    return false;
  } // only support time string in following format: https://www.w3.org/TR/NOTE-datetime


  var supportedDateFormats = ['YYYY-MM-DD', moment_1.default.ISO_8601, 'YYYY-MM-DDTHH:mm', 'YYYY-MM-DDTHH:mm:ss.SSS', 'YYYY-MM-DDTHH:mm:ss', 'YYYY-MM-DD HH:MM', 'YYYY-MM-DD HH:MM:SS', 'YYYY-MM-DD HH:MM:SS.SSS'];
  return typeof dataPoint === 'string' ? moment_1.default(dataPoint, supportedDateFormats, true).isValid() : moment_1.default(dataPoint).isValid();
}

exports.isTime = isTime;
/**
 * returns OK if data is string
 * @param dataPoint
 * @returns {boolean}
 */

function isString(dataPoint) {
  return typeof dataPoint === 'string';
}

exports.isString = isString;
/**
 * getDataTypeForPoint
 * naive implementation of checking for the data type of a single data point
 * number > time > string > unknown
 * starting with number because a Date.parse(number) is a valid date
 *
 * @param {any} dataPoint
 * @param {object} metaData meta data about the data field
 * @return {string} type
 */

var getDataTypeForPoint = function getDataTypeForPoint(dataPoint, metaData) {
  if (exports.canInferTypeFromMeta(metaData)) {
    return exports.getDataTypeForMeta(metaData);
  }

  return memoizedGetDataTypeForValue(dataPoint);
};

exports.getDataTypeForPoint = getDataTypeForPoint;

var getDataTypeForValue = function getDataTypeForValue(dataPoint) {
  if (Array.isArray(dataPoint)) {
    if (dataPoint.length > 1 && dataPoint[0] === '##__SPARKLINE__##') {
      return 'sparkline';
    }

    return 'array';
  } else if (lodash_1.isObject(dataPoint)) {
    return 'unknown';
  } else if (isNumber(dataPoint)) {
    return 'number';
  } else if (colorUtils_1.isColor(dataPoint)) {
    return 'color';
  } else if (isTime(dataPoint)) {
    return 'time';
  } else if (isString(dataPoint)) {
    return 'string';
  } else if (dataPoint === null) {
    return 'null';
  } // objects, etc


  return 'unknown';
};

var memoizedGetDataTypeForValue = lodash_1.memoize(getDataTypeForValue);
/**
 * canInferTypeFromMeta
 * verifies whether a data type can be inferred from meta data
 * @param {object} metaData
 * @return {boolean} whether the data type can be inferred from meta
 */

var canInferTypeFromMeta = function canInferTypeFromMeta() {
  var metaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fieldName = metaData.fieldName;
  return fieldName === '_time';
};

exports.canInferTypeFromMeta = canInferTypeFromMeta;
/**
 * getDataTypeForMeta
 * returns a data type based on meta data
 * @param {object} metaData
 * @return {string} type
 */

var getDataTypeForMeta = function getDataTypeForMeta() {
  var metaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fieldName = metaData.fieldName;

  if (fieldName === '_time') {
    return 'time';
  } // this case should never be reached


  return 'unknown';
};

exports.getDataTypeForMeta = getDataTypeForMeta;
/**
 * inferDataTypeFromSample
 * based on a number of data points this function determines the data type for all of them
 * and returns the most common data type (naive type inference)
 *
 * @param {Array} dataSample an array of arbitrary size containing data points of any data type
 * @return {string} type the most common type in the sample
 */

var inferDataTypeFromSample = function inferDataTypeFromSample(dataSample) {
  var typeMatches = {
    time: 0,
    number: 0,
    string: 0,
    color: 0,
    unknown: 0,
    array: 0,
    sparkline: 0,
    null: 0
  };
  dataSample.forEach(function (point) {
    typeMatches[exports.getDataTypeForPoint(point)] += 1;
  });
  var typeCount = 0;
  var returnType = 'unknown';
  Object.keys(typeMatches).forEach(function (key) {
    if (typeMatches[key] > typeCount) {
      typeCount = typeMatches[key];
      returnType = key;
    }
  });
  return returnType;
};

exports.inferDataTypeFromSample = inferDataTypeFromSample;
/**
 * based on a data array (e.g. one data column) this function returns a tiny sample of it
 * @TODO: very naive approach. there's papers with more advanced techniques but for now this should be very fast
 *
 * @param {Array} data to draw a sample from
 * @return {Array} a sample of the passed data
 */

var drawSample = function drawSample(data) {
  var sampleData = [];

  if (data.length > 2) {
    sampleData = [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];
  } else {
    sampleData = data;
  }

  return sampleData.map(function (point) {
    return DataPoint_1.DataPoint.isDataPoint(point) ? point.getValue().originalValue : point;
  });
};

exports.drawSample = drawSample;
/**
 *
 * @param {*} data
 */

var inferDataTypeFromData = function inferDataTypeFromData(data) {
  return exports.inferDataTypeFromSample(exports.drawSample(data));
};

exports.inferDataTypeFromData = inferDataTypeFromData;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/moment");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorUtils");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Helper = void 0;

var DataFrame_1 = __webpack_require__(11);

var DataSeries_1 = __webpack_require__(9);

var DataPoint_1 = __webpack_require__(3);

var EncodingExecutor_1 = __webpack_require__(2);

var Helper = /*#__PURE__*/function () {
  function Helper() {
    _classCallCheck(this, Helper);
  }

  _createClass(Helper, null, [{
    key: "isRawDataFrame",
    value: function isRawDataFrame(d) {
      return Array.isArray(d) && Helper.isRawDataSeries(d[0]);
    }
  }, {
    key: "isRawDataSeries",
    value: function isRawDataSeries(d) {
      return Array.isArray(d) && !EncodingExecutor_1.default.isObject(d[0]);
    }
  }, {
    key: "isRawDataPoint",
    value: function isRawDataPoint(d) {
      return !EncodingExecutor_1.default.isObject(d);
    }
  }, {
    key: "dataPrimitiveFromRaw",
    value: function dataPrimitiveFromRaw(d) {
      if (Helper.isRawDataFrame(d)) {
        return DataFrame_1.DataFrame.fromRaw(d);
      } else if (Helper.isRawDataSeries(d)) {
        return DataSeries_1.DataSeries.fromRaw(d);
      } else if (Helper.isRawDataPoint(d)) {
        return DataPoint_1.DataPoint.fromRaw(d);
      } else {
        throw new Error("raw value does not resemble DataFrame, DataSeries, or DataPoint");
      }
    }
  }]);

  return Helper;
}();

exports.Helper = Helper;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("chroma-js");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDataPrimitive = void 0;

var DataFrame_1 = __webpack_require__(11);

var DataPoint_1 = __webpack_require__(3);

var DataSeries_1 = __webpack_require__(9);

function isDataPrimitive(o) {
  return DataFrame_1.DataFrame.isDataFrame(o) || DataSeries_1.DataSeries.isDataSeries(o) || DataPoint_1.DataPoint.isDataPoint(o);
}

exports.isDataPrimitive = isDataPrimitive;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/construct");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatterClasses = void 0;

var SetColorChannel_1 = __webpack_require__(28);

var Prefix_1 = __webpack_require__(29);

var MatchValue_1 = __webpack_require__(30);

var RangeValue_1 = __webpack_require__(31);

var Gradient_1 = __webpack_require__(32);

var Pick_1 = __webpack_require__(33);

var Type_1 = __webpack_require__(24);

var FormatByType_1 = __webpack_require__(25);

var Frame_1 = __webpack_require__(34);

var Prepend_1 = __webpack_require__(35);

var Objects_1 = __webpack_require__(36);

var MultiFormat_1 = __webpack_require__(37);

var MaxContrast_1 = __webpack_require__(38);

var RenameSeries_1 = __webpack_require__(39);

exports.formatterClasses = {
  gradient: Gradient_1.Gradient,
  matchValue: MatchValue_1.MatchValue,
  prefix: Prefix_1.Prefix,
  rangeValue: RangeValue_1.RangeValue,
  pick: Pick_1.Pick,
  multiFormat: MultiFormat_1.MultiFormat,
  type: Type_1.Type,
  formatByType: FormatByType_1.FormatByType,
  frame: Frame_1.Frame,
  prepend: Prepend_1.Prepend,
  objects: Objects_1.Objects,
  setColorChannel: SetColorChannel_1.SetColorChannel,
  maxContrast: MaxContrast_1.MaxContrast,
  renameSeries: RenameSeries_1.RenameSeries
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setDefaultValue = void 0;

var types_1 = __webpack_require__(12);
/*
 * @method setDefaultValue
 * @param {DataType} defaultValue
 * @returns {DataType} valid default value
 */


var setDefaultValue = function setDefaultValue(defaultValue) {
  if (types_1.isNumber(defaultValue)) {
    return defaultValue;
  }

  return defaultValue || '';
};

exports.setDefaultValue = setDefaultValue;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DslParser = void 0;

var nearley_1 = __webpack_require__(44);

var grammar = __webpack_require__(45);

var DslParser = /*#__PURE__*/function () {
  function DslParser() {
    _classCallCheck(this, DslParser);
  }

  _createClass(DslParser, null, [{
    key: "parse",
    value: function parse(dsl) {
      var parser = new nearley_1.Parser(grammar);
      parser.feed(dsl);

      if (parser.results.length > 1) {
        console.warn("Ambiguous parse of '".concat(dsl, "'"));
      }

      if (parser.results.length == 0) {
        console.warn("No parsed results for '".concat(dsl, "'"));
      }

      return parser.results[0];
    }
  }]);

  return DslParser;
}();

exports.DslParser = DslParser;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/slicedToArray");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Type = void 0;

var Formatter_1 = __webpack_require__(8);

var TypeSafeValue_1 = __webpack_require__(10);
/**
 * Formatter that returns the DataType for each element within the given DataSeries.
 *
 * ```js
 * <SampleViz
 *     options={{
 *         option1: '> primary | seriesByIndex(0) | type()' // returns ['number', 'number', 'number']
 *         option2: '> primary | seriesByIndex(1) | type()' // returns ['string', 'string', 'string']
 *     }}
 *     dataSources={{
 *         data: {
 *             primary: {
 *                 columns: [[100, 200, 300], ['string1', 'string2', 'string3']]
 *                 fields: [{ name: 'foo' }, { name: 'bar' }]
 *             }
 *         }
 *     }}
 * />
 * ```
 */


var Type = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(Type, _Formatter_1$Abstract);

  var _super = _createSuper(Type);

  function Type() {
    _classCallCheck(this, Type);

    return _super.apply(this, arguments);
  }

  _createClass(Type, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p) {
      return TypeSafeValue_1.TypeSafeValue.fromRaw(TypeSafeValue_1.TypeSafeValue.fromRaw(p.getRawValue()).type);
    }
  }]);

  return Type;
}(Formatter_1.AbstractFormatter);

exports.Type = Type;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormatByType = void 0;

var lodash_1 = __webpack_require__(7); // There is a mismatch between typedefinition of numbro and numbro export.
// eslint-disable-next-line @typescript-eslint/no-var-requires


var numbrofn = __webpack_require__(26);

var moment_1 = __webpack_require__(14);

var Formatter_1 = __webpack_require__(8);

var TypeSafeValue_1 = __webpack_require__(10);

var validUnitPositions = ['before', 'after'];

var formatNumber = function formatNumber(number, config) {
  var mappedConfig = {
    prefix: !lodash_1.isEmpty(config.unit) && config.unitPosition === 'before' ? "".concat(config.unit, " ") : undefined,
    postfix: !lodash_1.isEmpty(config.unit) && config.unitPosition !== 'before' ? " ".concat(config.unit) : undefined,
    mantissa: typeof config.precision === 'number' ? config.precision : undefined
  };
  var c = lodash_1.defaultsDeep({}, lodash_1.omitBy(mappedConfig, lodash_1.isUndefined), lodash_1.omit(config, ['unit', 'unitPosition', 'precision']));
  return numbrofn(number).format(c);
};

var formatString = function formatString(string, config) {
  if (!lodash_1.isEmpty(config.unit)) {
    return config.unitPosition === 'before' ? "".concat(config.unit, " ").concat(string) : "".concat(string, " ").concat(config.unit);
  }

  return "".concat(string);
};

var timeToMoment = function timeToMoment(time) {
  // if splunk time zone is set, create time in splunk timezone and locale
  if (moment_1.default.getDefaultSplunkTimezone()) {
    return moment_1.default.newSplunkTime({
      time: time.toString()
    });
  } // fallback to moment default


  return moment_1.default(time);
};

var formatTime = function formatTime(dateObject, defaultValue, config) {
  if (typeof config.format === 'string' && !lodash_1.isEmpty(config.format)) {
    return timeToMoment(dateObject).format(config.format);
  }

  return defaultValue.toString();
};
/**
 * @class FormatByType
 *
 * Formats the value based on the value type and the provided config. For example
 *
 * ```js
 <Table
    context = {{
        formattedConfig: {
            number: {
                unit: '$',
                unitPosition: 'before',
                precision: 2,
                thousandSeparated: true,
            },
        },
    }}

    options = {{
        columnFormat: {
            formatted: {
                data: '> table | seriesByName("formatted") | formatByType(formattedConfig)',
            },
        },
    }}

    dataSources = {{
        primary: {
            requestParams: { offset: 0, count: 20 },
            data: {
                fields: [
                    { name: 'number' },
                    { name: 'formatted' },
                ],
                columns: [
                    [-927916.96, -924916.9, -654089.75],
                    [-927916.96, -924916.9, -654089.75],
                ],
            },
            meta: { totalCount: 100 },
        },
    }}
 />
 * ```
 *
 *  ## Config Object
 *
 *  ### number
 *
 *  * **unit?**: `string` to be appended or prepended to the value
 *  * **unitPosition?**: `{"before" | "after"}` where should the `unit` be placed. Maps to numbro `prefix` or `postfix`
 *  * **numberPrecision?**: `number` maps to numbro `mantissa`
 *  * **mantissa?**: `number` number of decimal points to show
 *  * **trimMantissa?**: `boolean` ending 0s in decimal points will be trimmed
 *  * **thousandSeparated?**: `boolean` should show `,` for thousands
 *  * **output?**: `"currency" | "percent" | "byte" | "time" | "ordinal" | "number"` value will be converted to one of thse formats
 *  * **base?**: `"decimal" | "binary" | "general"` used for converting value to bytes
 *  * **prefix?**: `string` string to be added in front of the value
 *  * **postfix?**: `string` string to be appended to the value
 *  * **forceAverage?**: `"trillion" | "billion" | "million" | "thousand"` can be used to force one the selected average
 *  * **average?**: `boolean` rounds up the value to the closed average
 *  * **totalLength?**: `number` used only for `average`. The number length to format data in
 *  * **spaceSeparated?**: `boolean` used with `average` to introduce space between number and average
 *  * **abbreviations?**: `{
        thousand?: string;
        million?: string;
        billion?: string;
        trillion?: string;
    }` abbreviation values for averages.
 *  * **negative?**: `"sign" | "parenthesis"` display sign or parenthesis for negative numbers
 *  * **forceSign?**: `boolean` always show + or - sign
 *
 *
 *  * For examples, refer [Numbro](https://numbrojs.com/format.html#format) or [tests](https://cd.splunkdev.com/devplat/vision/-/blob/main/packages/visualization-encoding/src/formatters/FormatByType.test.ts)
 *
 * #### time
 *
 *  * **format**: valid moment format string.  Refer - [moment display](https://momentjs.com/docs/#/displaying/)
 *
 *
 *
 
 */


var FormatByType = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(FormatByType, _Formatter_1$Abstract);

  var _super = _createSuper(FormatByType);

  function FormatByType(config) {
    var _this;

    _classCallCheck(this, FormatByType);

    _this = _super.call(this);
    _this.config = {
      number: {},
      string: {},
      time: {
        format: ''
      }
    };
    _this.config = lodash_1.defaultsDeep({}, config, _this.config);
    return _this;
  }

  _createClass(FormatByType, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p) {
      var _this$config = this.config,
          numberConfig = _this$config.number,
          stringConfig = _this$config.string,
          timeConfig = _this$config.time;
      var value = p.getValue();

      switch (value.type) {
        case 'number':
          return new TypeSafeValue_1.TypeSafeValue('string', formatNumber(p.getRawValue(), numberConfig), true, value.originalValue);

        case 'string':
          return new TypeSafeValue_1.TypeSafeValue('string', formatString(value.value, stringConfig), true, value.originalValue);

        case 'time':
          return new TypeSafeValue_1.TypeSafeValue('string', formatTime(value.value, value.originalValue, timeConfig), true, value.originalValue);

        default:
          return p.getValue();
      }
    }
  }]);

  return FormatByType;
}(Formatter_1.AbstractFormatter);

exports.FormatByType = FormatByType;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("numbro");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Default = void 0;

var Formatter_1 = __webpack_require__(8);

var EncodingExecutor_1 = __webpack_require__(2);

var TypeSafeValue_1 = __webpack_require__(10);

var Default = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(Default, _Formatter_1$Abstract);

  var _super = _createSuper(Default);

  function Default(val) {
    var _this;

    _classCallCheck(this, Default);

    _this = _super.call(this);
    _this.defaultVal = EncodingExecutor_1.default.rawTree(val);
    return _this;
  }

  _createClass(Default, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p, s) {
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var j = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (p.getRawValue() === undefined) {
        return TypeSafeValue_1.TypeSafeValue.fromRaw(this.defaultVal);
      } else {
        return p.getValue();
      }
    }
  }]);

  return Default;
}(Formatter_1.AbstractFormatter);

exports.Default = Default;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetColorChannel = void 0;

var chroma = __webpack_require__(17);

var lodash_1 = __webpack_require__(7);

var Formatter_1 = __webpack_require__(8);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * SetColorChannel can be used to modify a given color.
 *
 * ```js
 * <SampleViz
 *     context={{
 *          rowBGConfig: {
 *              channel: 'hsl.l',
 *              value: '*0.2'
 *          },
 *          headerBackgroundColor: {
 *              channel: 'hsv.v',
 *              value: '*0.66'
 *          }
 *     }}
 *     options={{
 *         backgroundColor: 'orangered',
 *         rowBackgroundColor: '> backgroundColor | setColorChannel(rowBGConfig)',   // #330e00
 *         headerColor: '> backgroundColor | setColorChannel(headerColorConfig)',    // #a82e00
 *     }}
 *     dataSources={{
 *         primary: {
 *             data: {
 *                 fields: [{ name: 'foo' }]
 *                 columns: [[100, 200]]
 *             }
 *         }
 *     }}
 * />
 * ```
 * Leverages [Chromajs.set](https://gka.github.io/chroma.js/#color-set) to change the color
 *
 * ## Config Object
 *  * **channel**: 'string' refers to channel of the color. For ex: 'hsl.l' or 'hsl.s' or 'rgb.b'
 *  * **value**: 'string' or 'number'. Can be used to set absolute. For ex: setColorChannel({channel: 'hsl.h', value: 0}). Can be used as relative. For ex: setColorChannel({channel: 'lab.l', value: '*0.5'})

 *
 */


var SetColorChannel = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(SetColorChannel, _Formatter_1$Abstract);

  var _super = _createSuper(SetColorChannel);

  function SetColorChannel(config) {
    var _this;

    _classCallCheck(this, SetColorChannel);

    _this = _super.call(this);
    _this.config = EncodingExecutor_1.default.rawTree(config);
    return _this;
  }

  _createClass(SetColorChannel, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p) {
      var _p$getValue = p.getValue(),
          value = _p$getValue.value,
          type = _p$getValue.type;

      if (type !== 'color') {
        return {
          type: type,
          value: value
        };
      }

      var channel = lodash_1.get(this, 'config.channel');
      var v = lodash_1.get(this, 'config.value');

      if (!channel || value == null) {
        console.warn('SetColorChannel requires channel (ex: hsv.v, rgb.r) and value configuration to be set. It will return the same color when missing.');
      }

      try {
        return {
          type: 'color',
          value: chroma(value.toString()).set(channel, v).hex()
        };
      } catch (error) {
        console.warn(error);
        return {
          type: 'color',
          value: value
        };
      }
    }
  }]);

  return SetColorChannel;
}(Formatter_1.AbstractFormatter);

exports.SetColorChannel = SetColorChannel;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Prefix = void 0;

var Formatter_1 = __webpack_require__(8);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * Prepends the given prefix (passed as a parameter) to the DataPoint.
 *
 * ```js
 * <SampleViz
 *     options={{
 *         textOption: '> primary | seriesByName("foo") | lastPoint() | prefix("bar")' // returns "bar100"
 *     }}
 *     dataSources={{
 *         primary: {
 *             data: {
 *                 fields: [{ name: 'foo' }]
 *                 columns: [[100, 200]]
 *             }
 *         }
 *     }}
 * />
 * ```
 */


var Prefix = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(Prefix, _Formatter_1$Abstract);

  var _super = _createSuper(Prefix);

  function Prefix(prefix) {
    var _this;

    _classCallCheck(this, Prefix);

    _this = _super.call(this);
    _this.prefix = EncodingExecutor_1.default.rawTree(prefix);
    return _this;
  }

  _createClass(Prefix, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p) {
      var _p$getValue = p.getValue(),
          value = _p$getValue.value;

      var prefixedValue = this.prefix + value.toString();
      return {
        value: prefixedValue,
        type: 'string'
      };
    }
  }]);

  return Prefix;
}(Formatter_1.AbstractFormatter);

exports.Prefix = Prefix;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MatchValue = void 0;

var lodash_1 = __webpack_require__(7);

var lodash_2 = __webpack_require__(7);

var types_1 = __webpack_require__(12);

var formatterUtils_1 = __webpack_require__(21);

var Formatter_1 = __webpack_require__(8);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * Formatter that accepts a the list of potential matches and a defaultValue (if no match is found) as the config.
 *
 * It maps each element in the DataSeries to find a corresponding match valued and returns the matched value if found, or the defaultValue if present.
 * Otherwise if neither are present, it returns the original value.
 *
 * ```js
 * <SampleViz
 *     context={{
 *         colorMatches: [
 *             {
 *                 match: 500,
 *                 value: '#FF0000',
 *             },
 *             {
 *                 match: 750,
 *                 value: '#00FF00',
 *             },
 *         ],
 *     }}
 *     options={{
 *         colorOption: '> primary | seriesByIndex(0) | lastPoint() | matchValues(colorMatches, "#0000FF")' // returns #FF0000
 *         colorOption2: '> primary | seriesByIndex(1) | lastPoint() | matchValues(colorMatches, "#0000FF")' // returns #0000FF
 *     }}
 *     dataSources={{
 *         primary: {
 *             data: {
 *                 columns: [[100, 200, 300, 400, 500], [600, 700, 800, 900, 1000]]
 *                 fields: [{ name: 'foo' }, { name: 'bar' }],
 *             }
 *         }
 *     }}
 * />
 *
 *
 * @extends AbstractFormatter<DataType, DataType>
 */


var MatchValue = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(MatchValue, _Formatter_1$Abstract);

  var _super = _createSuper(MatchValue);

  function MatchValue(matches) {
    var _this;

    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    _classCallCheck(this, MatchValue);

    _this = _super.call(this);
    _this.matches = EncodingExecutor_1.default.rawTree(matches);
    _this.defaultValue = formatterUtils_1.setDefaultValue(defaultValue);
    return _this;
  }

  _createClass(MatchValue, [{
    key: "formatTypedValue",
    value: function formatTypedValue(input) {
      var _input$getValue = input.getValue(),
          value = _input$getValue.value; // if no match present, return defaultValue if present, otherwise return the original value


      var defaultMatchValue = lodash_1.isUndefined(this.defaultValue) ? value : this.defaultValue;
      var matchResult = lodash_2.find(this.matches, function (match) {
        return match.match && match.match === value;
      });
      var updatedValue = lodash_1.isUndefined(matchResult) ? defaultMatchValue : matchResult.value;
      var updatedType = types_1.getDataTypeForPoint(updatedValue);
      return {
        value: updatedValue,
        type: updatedType
      };
    }
  }]);

  return MatchValue;
}(Formatter_1.AbstractFormatter);

exports.MatchValue = MatchValue;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RangeValue = void 0;

var lodash_1 = __webpack_require__(7);

var Formatter_1 = __webpack_require__(8);

var types_1 = __webpack_require__(12);

var formatterUtils_1 = __webpack_require__(21);

var EncodingExecutor_1 = __webpack_require__(2);

var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Formatter function that takes the list of ranges and a defaultValue (if no range is found)
 * and returns a function that takes a value and returns the range value if found, or the defaultValue if present.
 *
 * If neither are present, it returns the original value.
 *
 * The range fitting follows this criteria: `range.from <= value < range.to`
 *
 * A range can be defined as either a closed bound range: `{ from: 10, to: 20, value: 'foo' }`
 * or an open bound range:
 * `{ to: 20, value: 'bar' }` (open lower bound)
 * `{ from: 100, value: 'oof' }` (open upper bound)
 *
 * ```js
 *   <SampleViz
 *      context={{
 *          colorThresholds: [
 *              {
 *                  from: 1321,
 *                  value: '#00FFFF',
 *              },
 *              {
 *                  to: 1321,
 *                  value: '#FF00FF',
 *              },
 *          ],
 *      }}
 *      options={{
 *          valueOption: '> primary | seriesByIndex(0) | lastPoint()', // returns 103
 *          colorOption: '> deltaValue | rangeValue(colorThresholds)', // returns '#FF00FF'
 *      }}
 *      dataSources={{
 *          primary: {
 *              data: {
 *                  columns: [
 *                      ['1', '103'], ['2018-08-19T00:00:00.000+00:00', '2018-08-20T00:00:00.000+00:00'],
 *                  ],
 *                  fields: [{ name: 'foo', }, { name: '_time' }],
 *              }
 *          },
 *      }}
 *  />
 * ```
 * @extends AbstractFormatter<DataType, DataType>
 */

var RangeValue = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(RangeValue, _Formatter_1$Abstract);

  var _super = _createSuper(RangeValue);

  function RangeValue(ranges, defaultValue) {
    var _this;

    _classCallCheck(this, RangeValue);

    _this = _super.call(this);
    _this.ranges = EncodingExecutor_1.default.rawTree(ranges); //insure we can handle ranges that had DSL expressions shoved into them

    _this.defaultValue = formatterUtils_1.setDefaultValue(defaultValue);
    return _this;
  }

  _createClass(RangeValue, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p) {
      var _p$getValue = p.getValue(),
          type = _p$getValue.type,
          value = _p$getValue.value;

      if (type !== 'number') {
        console.warn("type '".concat(type, "' with value '").concat(value, "' is not a valid input to rangeValue"));
      }

      var rangeValueResult; // if no range is found and valid value, return defaultValue if present, otherwise return the original value

      var defaultRangeValue = lodash_1.isUndefined(this.defaultValue) && !types_1.isNumber(value) ? value : this.defaultValue;

      if (types_1.isNumber(value)) {
        var floatValue = parseFloat(value);

        for (var i = 0; i < this.ranges.length; i += 1) {
          if ( // open upper bound: value is bigger than or equal to open upper bound start (from)
          // if there are several 'from'-only ranges, we look at the first one that satisfies the mapping criteria
          // if there is overlap between a 'from'-only range and an inbetween range, this means that the ranges config is semantically invalid
          // TODO: figure out if we want to enforce a semantically valid config by sorting,
          // or by throwing an error if there are multiple 'from'/'to'-only ranges
          hasOwnProperty.call(this.ranges[i], 'from') && !hasOwnProperty.call(this.ranges[i], 'to') && floatValue >= this.ranges[i].from || // inbetween: value falls into from (inclusive) - to (exclusive) range
          floatValue >= this.ranges[i].from && floatValue < this.ranges[i].to || hasOwnProperty.call(this.ranges[i], 'to') && !hasOwnProperty.call(this.ranges[i], 'from') && floatValue < this.ranges[i].to) {
            rangeValueResult = this.ranges[i].value;
            break;
          }
        }
      }

      var updatedValue = lodash_1.isUndefined(rangeValueResult) ? defaultRangeValue : rangeValueResult;
      var updatedType = types_1.getDataTypeForPoint(updatedValue);
      return {
        type: updatedType,
        value: updatedValue
      };
    }
  }]);

  return RangeValue;
}(Formatter_1.AbstractFormatter);

exports.RangeValue = RangeValue;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(13);

var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Gradient = void 0;

var chroma = __webpack_require__(17);

var Formatter_1 = __webpack_require__(8);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * Based on stops and colors, this formatter maps the value to an interpolated color.
 *
 * The `config` follows this criteria: `{ stops: [0, 100, 230], colors: ['red', 'green', 'blue'] }`
 *
 * If no config is specified, the default `colors` are `['rgba(123,86,219,0.4)', 'rgba(123,86,219,1)']`. The default `stops` are dependent on the DataSeries provided.
 * Given a DataSeries with n values, the stops would consist of [min, ...,  max]. The (n - 2) middle values are linearly interpolated via the minimum and maximum values of the series.
 *
 * For example, if 0 < value < 100, the corresponding interpolated color will be between red and green.
 *
 * ```js
 * <SampleViz
 *     context={{
 *         gradientConfig: { stops: [0, 100, 230], colors: ['red', 'green', 'blue'] }
 *     }}
 *     options={{
 *         colorOption: '> primary | seriesByIndex(0) | gradient(gradientConfig)' // it maps [0, 50, 230] to ['#FF0000', '#808000', '#0000FF']
 *     }}
 *     dataSources={{
 *         data: {
 *             primary: {
 *                 columns: [[0, 50, 230], [100, 50, 230]],
 *                 fields: [{ name: 'foo' }, { name: 'bar' }]
 *             }
 *         }
 *     }}
 * />
 * ```
 *
 * @extends AbstractFormatter<DataType, DataType>
 */


var Gradient = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(Gradient, _Formatter_1$Abstract);

  var _super = _createSuper(Gradient);

  function Gradient(config) {
    var _this;

    _classCallCheck(this, Gradient);

    _this = _super.call(this);
    _this.config = EncodingExecutor_1.default.rawTree(config) || {};
    return _this;
  }

  _createClass(Gradient, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p, series) {
      var input = p.getValue();
      var type = input.type,
          value = input.value;

      if (type !== 'number') {
        throw new Error("type '".concat(type, "' with value '").concat(value, "' is not a valid input to gradient"));
      } // set default colors for gradient colors if colors not explicit


      var colors = this.config.colors || ['rgba(123,86,219,0.4)', 'rgba(123,86,219,1)'];
      var stops = this.config.stops || [];

      if (colors.length === 1) {
        colors = ['white'].concat(_toConsumableArray(colors)); // force color bin to have a lower bound color
      } // auto gradient: set default color stops if stops not explicit


      if (!stops.length) {
        // no data values, so just make the range from zero to 1. If we try
        // to gradient format a data point, it will be the case that it has
        // no points
        if (!series || !series.points || !series.points.length) {
          stops = [0, 1];
        } else {
          var min = Number(series.min().getRawValue());
          var max = Number(series.max().getRawValue());
          stops.push(min);

          for (var i = 1; i < colors.length - 1; i += 1) {
            stops.push(min + i * (max - min) / (colors.length - 1));
          }

          stops.push(max);
        } // Could not support auto gradient with more than two colors in gradient config without data.


        if (stops.length !== colors.length) {
          throw new Error('Could not format gradient color. Please provide data or config stops in gradient formatting.');
        }
      } else if (stops.length === 1) {
        stops.push(stops[0]); // force stops to be at least two values
      }

      stops.sort(function (a, b) {
        return a - b;
      }); // force ascending order of color stops

      if (stops.length !== colors.length) {
        throw new Error('gradient stops and colors must have the same number of elements.');
      }

      var interpolateColor;
      var isBeyondUpperBound = value > stops[stops.length - 1];
      var isBeyondLowerBound = value < stops[0];

      if (isBeyondUpperBound || isBeyondLowerBound) {
        var index = isBeyondUpperBound ? stops.length - 1 : 0;
        interpolateColor = chroma(colors[index]).hex().toUpperCase();
        return {
          type: 'color',
          value: interpolateColor
        };
      }

      for (var _i = 1; _i < stops.length; _i += 1) {
        if (isNaN(stops[_i])) {
          // eslint-disable-next-line
          console.warn('Could not format gradient color: stops are required to be numbers. Falling back to first color.');
          interpolateColor = chroma(colors[0]).hex().toUpperCase() || '#000';
          return {
            type: 'color',
            value: interpolateColor
          };
        }

        var upperVal = stops[_i];

        if (value <= upperVal) {
          var lowerVal = stops[_i - 1];
          var tau = 0; // deal with special case when the upper and lower bounds of the colors are equal

          if (upperVal === lowerVal) {
            // user prolly expects lower end of color stops if value is zero
            // otherwise use the upper bound
            tau = value === 0 ? 0 : 1;
          } else {
            tau = (value - lowerVal) / (upperVal - lowerVal);
          }

          interpolateColor = chroma.scale([colors[_i - 1], colors[_i]])(tau).hex().toUpperCase();
          return {
            type: 'color',
            value: interpolateColor
          };
        }
      } // eslint-disable-next-line


      console.warn("Could not format value for gradient: ".concat(value));
      interpolateColor = chroma(colors[0]).hex().toUpperCase() || '#000';
      return {
        type: 'color',
        value: interpolateColor
      };
    }
  }]);

  return Gradient;
}(Formatter_1.AbstractFormatter);

exports.Gradient = Gradient;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pick = void 0;

var Formatter_1 = __webpack_require__(8);

var TypeSafeValue_1 = __webpack_require__(10);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * Formatter which can accept a map or array config.
 *
 * If a map is provided, it will use the DataPoint's field name to pick the corresponding entry in the config.
 *
 * If an array is provided, it cycles through the array of values passed in via the config n times (where n = DataSeries.length) and returns this as the output.
 *
 * For example, if the config contains 2 elements and the DataSeries contains 10 elements, it will loop through the config 5 times, alternating between which element is appended to the output.
 *
 * ```js
 * <SampleViz
 *     context={{
 *         mapConfig: {
 *             bar: 'barLabel',
 *             foo: 'fooLabel',
 *         },
 *         rowBackgroundColors: ['#FF0000', '#00FF00', '#0000FF'],
 *         rowTextColors: ['#110000', '#000011'],
 *     }}
 *     options={{
 *         rowBackgroundColor: '> primary | seriesByIndex(0) | pick(rowBackgroundColors)', // returns ['#FF0000', '#00FF00', '#0000FF', '#FF0000', '#0000FF']
 *         rowTextColor: '> primary | seriesByIndex(0) | pick(rowTextColors)', // returns ['#110000', '#000011', '#110000', '#000011', '#110000']
 *         barOption: '> primary | seriesByIndex(1) | lastPoint() | pick(mapConfig)', // returns 'barLabel'
 *         fooOption: '> primary | seriesByIndex(0) | lastPoint() | pick(mapConfig)', // returns 'fooLabel'
 *     }}
 *     dataSources={{
 *         primary: {
 *             data: {
 *                 columns: [[100, 200, 300, 400, 500], [600, 700, 800, 900, 1000]]
 *                 fields: [{ name: 'foo' }, { name: 'bar' }],
 *             }
 *         }
 *     }}
 * />
 * ```
 */


var Pick = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(Pick, _Formatter_1$Abstract);

  var _super = _createSuper(Pick);

  function Pick(formatConfig) {
    var _this;

    _classCallCheck(this, Pick);

    _this = _super.call(this); //insure that the config is plain old JS objects (does not have DataPrimitives inside it)

    _this.config = EncodingExecutor_1.default.rawTree(formatConfig);
    return _this;
  }

  _createClass(Pick, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p, s) {
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var j = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var val;

      if (Array.isArray(this.config)) {
        val = this.config[j % this.config.length];
      } else {
        val = this.config[s.field];
      }

      return TypeSafeValue_1.TypeSafeValue.fromRaw(val);
    }
  }]);

  return Pick;
}(Formatter_1.AbstractFormatter);

exports.Pick = Pick;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Frame = void 0;

var DataFrame_1 = __webpack_require__(11);

var DataSeries_1 = __webpack_require__(9);

var DataPrimitive_1 = __webpack_require__(18);

var DataPoint_1 = __webpack_require__(3);

var Helper_1 = __webpack_require__(16);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * This formatter returns a new DataFrame made by combining its arguments.
 *
 * Example: frame(series1, series2, frame1). It is also possible to pass
 * DataPoint as argument, in which case the DataPoint is wrapped in DataSeries.
 *
 * ```js
 * <SampleViz
 *     context={{
 *         users: '> primary | seriesByName("users")',
 *         ids: '> primary | seriesByName("ids")'
 *     }}
 *     options={{
 *         frameOption1: '> frame(users, ids)' // returns [['Maurine', 'Jennings', 'Giuseppe'], ['1', '2', '3']]
 *         frameOption2: '> frame(frameOption1, ids)' // returns [['Maurine', 'Jennings', 'Giuseppe'], ['1', '2', '3'], ['1', '2', '3']]
 *     }}
 *     dataSources={{
 *         primary: {
 *             data: {
 *                 columns: [['Maurine', 'Jennings', 'Giuseppe'], ['1', '2', '3']],
 *                 fields: [{ name: 'users' }, { name: 'ids' }]
 *             }
 *         }
 *     }}
 * />
 * ```
 */


var Frame = /*#__PURE__*/function () {
  function Frame() {
    _classCallCheck(this, Frame);

    this.args = []; //frame formatter must also support 'raw' coming form context so we rawTree as needed

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.args = args.map(function (a) {
      return DataPrimitive_1.isDataPrimitive(a) ? a : Helper_1.Helper.dataPrimitiveFromRaw(EncodingExecutor_1.default.rawTree(a));
    });
  }

  _createClass(Frame, [{
    key: "format",
    value: function format(ignored) {
      var series = [];
      this.args.forEach(function (dataPrim) {
        if (DataSeries_1.DataSeries.isDataSeries(dataPrim)) {
          series.push(dataPrim);
        } else if (DataFrame_1.DataFrame.isDataFrame(dataPrim)) {
          series = series.concat(dataPrim.series);
        } else if (DataPoint_1.DataPoint.isDataPoint(dataPrim)) {
          series.push(new DataSeries_1.DataSeries([dataPrim]));
        } else {
          throw new Error("frame formatter args incorrect");
        }
      });
      return new DataFrame_1.DataFrame(series);
    }
  }]);

  return Frame;
}();

exports.Frame = Frame;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(13);

var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Prepend = void 0;

var DataPoint_1 = __webpack_require__(3);

var DataPrimitive_1 = __webpack_require__(18);

var DataSeries_1 = __webpack_require__(9);

var DataFrame_1 = __webpack_require__(11);

var Helper_1 = __webpack_require__(16);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * Formatter that prepends a DataFrame, DataSeries, or DataPoint to a pre-existing DataFrame or DataSeries with compatible types.
 *
 * If prepending a DataFrame to another DataFrame, the DataFrames must have the same number of DataSeries.
 * For example, a DataFrame with 3 series such as `[[1, 2], [3, 4], [5, 6]]` cannot be prepended to a DataFrame with 2 series such as `[[7, 8], [9, 10]]`.
 *
 * Only the same DataPrimitive type or a DataPrimitive's composite DataPrimitives
 * (e.g. DataSeries or DataPoint for DataFrame, or a DataPoint for a DataSeries) can be prepended to the pre-existing DataPrimitive.
 *
 * ```js
 * <SampleViz
 *     context={{
 *         staticUser: 'All users',
 *         staticId: '*',
 *         additionalUsers: ['Andrew', 'Chanelle'],
 *         idsAsNumbers: [1, 2],
 *         users: '> primary | seriesByName("users") | prepend(staticUser)', // returns ['All users', 'Maurine', 'Jennings']
 *         ids: '> primary | seriesByName("ids") | prepend(staticId)' // returns ['*', '1', '2', '3']
 *         pathologicalIds: '> primary | seriesByName("idsAsNumbers") | prepend(staticId)' // throws an error, since `staticId` is a string, while the pre-existing series is composed of numbers
 *     }}
 *     options={{
 *         consolidatedUsers: '> primary | seriesByName("users") | prepend(additionalUsers)', // returns ['Andrew', 'Chanelle', 'Maurine', 'Jennings']
 *         // returns {
 *         //     columns: [['Maurine', 'Jennings', 'Maurine', 'Jennings'], ['1', '2', '1', '2']]
 *         //     fields: [{ name: 'users' }, { name: 'ids' }]
 *         // }
 *         prependingFrames: '> primary | prepend(primary)'
 *     }}
 *     dataSources={{
 *         primary: {
 *             data: {
 *                 columns: [['Maurine', 'Jennings'], ['1', '2']],
 *                 fields: [{ name: 'users' }, { name: 'ids' }]
 *             }
 *         }
 *     }}
 * />
 * ```
 */


var Prepend = /*#__PURE__*/function () {
  function Prepend(d) {
    _classCallCheck(this, Prepend);

    //needs to be able to prepend DataPrimitive and raw
    this.prependMe = DataPrimitive_1.isDataPrimitive(d) ? d : Helper_1.Helper.dataPrimitiveFromRaw(EncodingExecutor_1.default.rawTree(d));
  }

  _createClass(Prepend, [{
    key: "format",
    value: function format(subject) {
      if (DataFrame_1.DataFrame.isDataFrame(subject)) {
        return this.prependToFrame(subject);
      }

      if (DataSeries_1.DataSeries.isDataSeries(subject)) {
        return this.prependToSeries(subject);
      }

      throw new Error("Can only prepend to DataFrame or DataSeries");
    }
  }, {
    key: "prependToFrame",
    value: function prependToFrame(subject) {
      if (DataFrame_1.DataFrame.isDataFrame(this.prependMe)) {
        return this.prependFrameToFrame(subject);
      } else if (DataSeries_1.DataSeries.isDataSeries(this.prependMe)) {
        return this.prependASeriesToEachSeriesOfFrame(subject);
      } else if (DataPoint_1.DataPoint.isDataPoint(this.prependMe)) {
        return this.prependAPointToEachSeriesOfFrame(subject);
      }

      throw new Error("'prepend' formatter only accepts DataFrame, DataSeries, or DataPoint as argument");
    }
  }, {
    key: "prependToSeries",
    value: function prependToSeries(subject) {
      if (DataFrame_1.DataFrame.isDataFrame(this.prependMe)) {
        throw new Error('cannot prepend a DataFrame to a DataSeries');
      } else if (DataSeries_1.DataSeries.isDataSeries(this.prependMe)) {
        return this.prependSeriesToSeries(subject, this.prependMe);
      } else if (DataPoint_1.DataPoint.isDataPoint(this.prependMe)) {
        return this.prependPointToSeries(subject);
      }

      throw new Error("'prepend' to series formatter only DataSeries, or DataPoint as argument");
    }
  }, {
    key: "prependAPointToEachSeriesOfFrame",
    value: function prependAPointToEachSeriesOfFrame(dp) {
      var _this = this;

      return new DataFrame_1.DataFrame(dp.series.map(function (s) {
        return _this.prependPointToSeries(s);
      }));
    }
  }, {
    key: "prependASeriesToEachSeriesOfFrame",
    value: function prependASeriesToEachSeriesOfFrame(frame) {
      var _this2 = this;

      return new DataFrame_1.DataFrame(frame.series.map(function (s) {
        return _this2.prependSeriesToSeries(s, _this2.prependMe);
      }));
    }
  }, {
    key: "prependFrameToFrame",
    value: function prependFrameToFrame(frame) {
      var _this3 = this;

      var numSeries1 = this.prependMe.series.length;
      var numSeries2 = frame.series.length;

      if (numSeries1 !== numSeries2) {
        throw new Error("can't prepend a frame with ".concat(numSeries1, " columns to a field with ").concat(numSeries2, " columns"));
      }

      return new DataFrame_1.DataFrame(frame.series.map(function (s, i) {
        return _this3.prependSeriesToSeries(s, _this3.prependMe.seriesByIndex(i));
      }));
    }
  }, {
    key: "prependSeriesToSeries",
    value: function prependSeriesToSeries(series, prependMe) {
      var field = series.field; //we will use this to insure the prepended series has the same field

      var type1 = series.points.length > 0 ? series.points[0].getValue().type : undefined;
      var type2 = prependMe.points.length > 0 ? prependMe.points[0].getValue().type : undefined;

      if (type1 && type2 && type1 !== type2) {
        throw new Error("cannot prepend ".concat(type2, " to ").concat(type1));
      }

      return new DataSeries_1.DataSeries(prependMe.points.map(function (p) {
        return new DataPoint_1.DataPoint(field, p.getValue());
      }).concat(series.points));
    }
  }, {
    key: "prependPointToSeries",
    value: function prependPointToSeries(s) {
      var field = s.field;
      var typedValue = s.firstPoint().getValue(); // we must use the existing series type for the prepended point

      var type1 = typedValue.type;
      var typedValue2 = this.prependMe.getValue();
      var type2 = typedValue2.type;

      if (type1 !== type2) {
        throw new Error("cannot prepend point of type ".concat(type2, " to series of type ").concat(type1));
      }

      var newPoint = new DataPoint_1.DataPoint(field, typedValue2);
      return new DataSeries_1.DataSeries([newPoint].concat(_toConsumableArray(s.points)));
    }
  }]);

  return Prepend;
}();

exports.Prepend = Prepend;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(41);

var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Objects = void 0;

var DataPoint_1 = __webpack_require__(3);

var DataSeries_1 = __webpack_require__(9);

var DataFrame_1 = __webpack_require__(11);

var lodash_1 = __webpack_require__(7);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * Formatter which converts a DataPrimitive into an array of objects. This is typically used in conjunction with UDF inputs.
 *
 * ```js
 * // UDF inputs
 * {
 *     "inputs": {
 *         "input1": {
 *             "context": {
 *                  "staticOptions": [["All Users"], ["*"]],
 *                  "field1": "> primary | seriesByName(\"users\") | renameSeries(\"label\")",
 *                  "field2": "> primary | seriesByName(\"ids\") | renameSeries(\"value\")"",
 *              },
 *              "type": "input.multiselect",
 *              "options": {
 *                  "items": "> frame(field1, field2) | prepend(staticOptions) | objects()"
 *                      // returns [
 *                      //     { label: 'All users', value: '*' },
 *                      //     { label: 'jane doe', value: 'jdoe' },
 *                      //     { label: 'joe schmo', value: 'jschmo' },
 *                      //     { label: 'jack schmidt', value: 'jschmidt' },
 *                      // ]
 *                  ]
 *              },
 *              "dataSources": {
 *                  "primary": {
 *                      "data": {
 *                          "fields": [{ "name": 'users' } , { "name": "ids" } ],
 *                          "columns": [[ "jane doe", "joe schmo", "jack schmidt"], ["jdoe", "jschmo", "jschmidt"]]
 *                      }
 *                  }
 *             },
 *         }
 *     }
 * }
 * ```
 */


var Objects = /*#__PURE__*/function () {
  function Objects(objectConfig) {
    _classCallCheck(this, Objects);

    this.config = EncodingExecutor_1.default.rawTree(objectConfig);
  }

  _createClass(Objects, [{
    key: "format",
    value: function format(dp) {
      if (DataFrame_1.DataFrame.isDataFrame(dp)) {
        var mergedObjectSeries = this.seriesToObjects(dp.series[0]);

        for (var i = 1; i < dp.series.length; i += 1) {
          var mergeMeIn = this.seriesToObjects(dp.series[i]);

          for (var j = 0; j < mergedObjectSeries.length; j += 1) {
            mergedObjectSeries[j] = lodash_1.merge(mergedObjectSeries[j], mergeMeIn[j]);
          }
        }

        return mergedObjectSeries;
      } else if (DataSeries_1.DataSeries.isDataSeries(dp)) {
        return this.seriesToObjects(dp);
      } else if (DataPoint_1.DataPoint.isDataPoint(dp)) {
        return [_defineProperty({}, dp.field, dp.getRawValue())];
      } else {
        throw new Error("'objects' formatter only allowed on DataFrame, DataPoint, or DataSeries");
      }
    }
  }, {
    key: "seriesToObjects",
    value: function seriesToObjects(s) {
      var _this = this;

      return s.points.reduce(function (acc, pt) {
        var key = pt.field;

        if (_this.config && _this.config.rename) {
          key = _this.config.rename[key] || key;
        }

        acc.push(_defineProperty({}, key, pt.getRawValue()));
        return acc;
      }, []);
    }
  }]);

  return Objects;
}();

exports.Objects = Objects;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiFormat = void 0;

var FormatterPresets_1 = __webpack_require__(20);

var EncodingExecutor_1 = __webpack_require__(2);
/**
 * Formatter which accepts a config object containing a map of field-specific formatters.
 * The field-specific formatter is used to evaluate each fields' corresponding values.
 *
 * The three required fields are as follows:
 *
 * - `nameField`, which denotes the list of keys with custom formatters to be applied against
 *
 * - `valueField`, which denotes the field to derive the values from
 *
 * - `formatter1. which is an object that requires the `type` of formatter and the specific required for the specified formatter.
 *
 * ```js
 *     <ChoroplethSvg
 *         context={{
 *             areaColorsFormat: {
 *                 nameField: 'pathIds',
 *                 valueField: 'values',
 *                 formatters: {
 *                     id1: {
 *                         type: 'matchValue',
 *                         config: [{
 *                             match: 100,
 *                             value: '#FF0000'
 *                         }]
 *                     },
 *                     id2: {
 *                         type: 'rangeValue',
 *                         config: [
 *                             {
 *                                 to: 100,
 *                                 value: '#00FF00'
 *                             }
 *                             {
 *                                 from: 100,
 *                                 value: '#0000FF'
 *                             }
 *                         ]
 *                     }
 *                 }
 *             }
 *         }}
 *         options={{
 *             areaIds: '> primary | seriesByName("pathIds")', // returns ['id1', 'id2']
 *             areaValues: '> primary | seriesByName("values")', // returns [100, 200]
 *             areaColors: '> primary | multiFormat(areaColorsFormat)' // returns ['#FF0000', '#0000FF']
 *         }}
 *         dataSources={{
 *             primary: {
 *                 data: {
 *                     columns: [['id1', 'id2'], [100, 200]]
 *                     fields: [{ name: 'pathIds' }, { name: 'values' }]
 *                 }
 *             }
 *         }}
 *     />
 * ```
 *
 */


var MultiFormat = /*#__PURE__*/function () {
  function MultiFormat(formatConfig) {
    _classCallCheck(this, MultiFormat);

    this.config = EncodingExecutor_1.default.rawTree(formatConfig);
  }

  _createClass(MultiFormat, [{
    key: "format",
    value: function format(f) {
      var _this = this;

      var namesDataSeries = f.seriesByName(this.config.nameField);
      var valuesDataSeries = f.seriesByName(this.config.valueField); // choroplethSVG expects that the names and values are of the same length
      // otherwise there would be no way to map an areaId with an areaValue

      return namesDataSeries.points.map(function (name, i) {
        var _this$config$formatte = _this.config.formatters[name.getRawValue()],
            type = _this$config$formatte.type,
            config = _this$config$formatte.config;

        var formatterClass = FormatterPresets_1.formatterClasses[type];
        var value = valuesDataSeries.pointByIndex(i);

        if (!formatterClass) {
          throw new Error("unknown formatter type \"".concat(type, "\" was specified"));
        }

        return new formatterClass(config).format(value, valuesDataSeries);
      });
    }
  }]);

  return MultiFormat;
}();

exports.MultiFormat = MultiFormat;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MaxContrast = void 0;

var chroma = __webpack_require__(17);

var lodash_1 = __webpack_require__(7);

var Formatter_1 = __webpack_require__(8);

var EncodingExecutor_1 = __webpack_require__(2);

var colorUtils_1 = __webpack_require__(15);
/**
 * MaxContrast can be used to pick the color with maxContrast.
 *
 * ```js
 * <SampleViz
 *     context={{
 *          contrastConfig: {
 *              colors: ['white', 'black']
 *          }
 *     }}
 *     options={{
 *         color1: 'green',
 *         maxContrastOfColor1: '> color1 | maxContrast(contrastConfig)',    // white
 *         color2: 'gray'
 *         maxContrastOfColor2: '> color2 | maxContrast(contrastConfig)',    // black
 *     }}
 *     dataSources={{
 *         primary: {
 *             data: {
 *                 fields: [{ name: 'foo' }]
 *                 columns: [[100, 200]]
 *             }
 *         }
 *     }}
 * />
 * ```
 * Leverages [Chromajs.contrast](https://gka.github.io/chroma.js/#chroma-contrast) to determine contrast between color and values
 *
 * ## Config Object
 *  * **colors**: 'string[]' array of colors to compare contrast against
 *  * **default**: 'string' default color if no colors or the contrast is not found
 *
 */


var MaxContrast = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(MaxContrast, _Formatter_1$Abstract);

  var _super = _createSuper(MaxContrast);

  function MaxContrast(config) {
    var _this;

    _classCallCheck(this, MaxContrast);

    _this = _super.call(this);
    _this.config = EncodingExecutor_1.default.rawTree(config);
    return _this;
  }

  _createClass(MaxContrast, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p) {
      var _p$getValue = p.getValue(),
          value = _p$getValue.value,
          type = _p$getValue.type;

      if (type !== 'color' || !colorUtils_1.isColor(value)) {
        return {
          type: type,
          value: value
        };
      }

      var colorConfig = lodash_1.get(this, 'config.colors');
      var defaultColor = lodash_1.get(this, 'config.default');

      if (!Array.isArray(colorConfig) || colorConfig.length === 0) {
        return colorUtils_1.isColor(defaultColor) ? {
          type: 'color',
          value: defaultColor
        } : {
          type: type,
          value: value
        };
      }

      if (value === 'transparent' && colorUtils_1.isColor(defaultColor)) {
        return {
          type: 'color',
          value: defaultColor
        };
      }

      try {
        return {
          type: 'color',
          value: lodash_1.chain(colorConfig).map(function (c) {
            return {
              color: c,
              contrast: chroma.contrast(value, c)
            };
          }).maxBy('contrast').value().color
        };
      } catch (error) {
        console.warn(error);
        return {
          type: 'color',
          value: defaultColor || value
        };
      }
    }
  }]);

  return MaxContrast;
}(Formatter_1.AbstractFormatter);

exports.MaxContrast = MaxContrast;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _get = __webpack_require__(42);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenameSeries = void 0;

var DataPoint_1 = __webpack_require__(3);

var Default_1 = __webpack_require__(27);
/**
 * This formatter can be used to rename a series name
 *
 * Example: renameSeries("username").
 *
 * ```js
 * <SampleViz
 *     options={{
 *         original: '> primary | getField()'                                                                    // ['users', 'ids']
 *         dataframe: '> primary | renameSeries("username") | getField()'                                        // ['username', 'ids']
 *         dataSeries: '> primary | seriesByName("users") | renameSeries("username") | getField()'               // 'username'
 *         dataPoint: '> primary | seriesByName("users") | lastPoint() | renameSeries("username") | getField()'  // 'username'
 *     }}
 *     dataSources={{
 *         primary: {
 *             data: {
 *                 columns: [['Maurine', 'Jennings', 'Giuseppe'], ['1', '2', '3']],
 *                 fields: [{ name: 'users' }, { name: 'ids' }]
 *             }
 *         }
 *     }}
 * />
 * ```
 * ## Arguments
 *  * **fieldName**: 'string' new field name for the series
 */


var RenameSeries = /*#__PURE__*/function (_Default_1$Default) {
  _inherits(RenameSeries, _Default_1$Default);

  var _super = _createSuper(RenameSeries);

  function RenameSeries(name) {
    var _this;

    _classCallCheck(this, RenameSeries);

    _this = _super.call(this, name);
    _this.newFieldName = name;
    return _this;
  }

  _createClass(RenameSeries, [{
    key: "formatPoint",
    value: function formatPoint(p, s) {
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var j = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      return i === 0 && typeof this.newFieldName === 'string' && this.newFieldName.length > 0 ? new DataPoint_1.DataPoint(this.newFieldName, this.formatTypedValue(p, s, i, j)) : _get(_getPrototypeOf(RenameSeries.prototype), "formatPoint", this).call(this, p, s, i, j);
    }
  }]);

  return RenameSeries;
}(Default_1.Default);

exports.RenameSeries = RenameSeries;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LITERAL_TYPES = void 0;
exports.LITERAL_TYPES = ['number', 'string'];

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/get");

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _construct = __webpack_require__(19);

var _toConsumableArray = __webpack_require__(13);

var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionScopes = void 0;

var lodash_1 = __webpack_require__(7);

var EncodingExecutor_1 = __webpack_require__(2);

var OptionScopes = /*#__PURE__*/function () {
  function OptionScopes(optionsStanza, frames, themeFunc) {
    _classCallCheck(this, OptionScopes);

    this.local = []; // unqualified identifiers can be resolved against local context. This is a stack of scopes.

    this.visitedPaths = new Set(); // Set of object paths we have visited (used for circular reference detection)

    this.context = optionsStanza.context;
    this.executedOptions = optionsStanza.options;
    this.frames = frames;
    this.themeFunc = themeFunc;
    this.local.push(this.executedOptions); // Stack. local starts off pointing to top level options
  }

  _createClass(OptionScopes, [{
    key: "resolve",
    value: function resolve(identifier) {
      var scopeParts = identifier.split('.');
      var scopedValue = null;

      if (OptionScopes.isQualified(scopeParts)) {
        scopedValue = this.resolveQualifiedIdentifier(scopeParts);
      } else {
        scopedValue = this.resolveUnqualifiedIdentifier(scopeParts);
      }

      return lodash_1.cloneDeep(scopedValue); // return defensive copy. Prevents targets of identifiers from getting mutated
    }
  }, {
    key: "resolveUnqualifiedIdentifier",
    value: function resolveUnqualifiedIdentifier(scopeParts) {
      //no qualifier has been given so we create qualified identifiers from all
      //that point to all possible scopes
      var qualifiers = OptionScopes.SCOPES;
      var scopedValue;

      for (var i = 0; i < qualifiers.length; i += 1) {
        var qualifiedIdentifier = [qualifiers[i]].concat(_toConsumableArray(scopeParts));
        scopedValue = this.resolveQualifiedIdentifier(qualifiedIdentifier);

        if (scopedValue.val) {
          break; //found it
        }
      }

      return scopedValue;
    }
  }, {
    key: "resolveQualifiedIdentifier",
    value: function resolveQualifiedIdentifier(scopeParts) {
      var qualifiedTargets = {
        context: this.context,
        options: this.executedOptions,
        datasources: this.frames,
        local: this.local[this.local.length - 1]
      };
      var val = null;
      var location = scopeParts[0];

      if (location === 'themes' && this.themeFunc) {
        //themes must be looked up in themeRegistry
        var themeKey = scopeParts[1];
        val = this.themeFunc(themeKey);
      } else {
        val = lodash_1.get(qualifiedTargets, scopeParts);

        if (val) {
          val = new EncodingExecutor_1.default().eval(val, this, scopeParts);
        }
      }

      return {
        location: location,
        val: val
      };
    }
  }, {
    key: "pushLocalScope",
    value: function pushLocalScope(o) {
      this.local.push(o);
    }
  }, {
    key: "popLocalScope",
    value: function popLocalScope() {
      this.local.pop();
    }
  }, {
    key: "addToVisitedList",
    value: function addToVisitedList(path) {
      var pathStr = path.join('.');

      if (this.visitedPaths.has(pathStr)) {
        throw new Error("Circular reference ".concat(pathStr, ", path history: ").concat(_construct(Array, _toConsumableArray(this.visitedPaths)).toString()));
      }

      this.visitedPaths.add(pathStr);
    }
  }, {
    key: "removeFromVisitedList",
    value: function removeFromVisitedList(path) {
      this.visitedPaths.delete(path.join('.'));
    }
  }], [{
    key: "isQualified",
    value: function isQualified(scopeParts) {
      var firstPart = scopeParts[0];
      return OptionScopes.SCOPES.includes(firstPart);
    }
  }]);

  return OptionScopes;
}();

exports.OptionScopes = OptionScopes;
OptionScopes.SCOPES = ['local', 'context', 'datasources', 'options', 'themes'];

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = require("nearley");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var _toConsumableArray = __webpack_require__(13);

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
} // Generated automatically by nearley, version 2.19.5
// http://github.com/Hardmath123/nearley


(function () {
  function id(x) {
    return x[0];
  }

  var grammar = {
    Lexer: undefined,
    ParserRules: [{
      name: '_$ebnf$1',
      symbols: []
    }, {
      name: '_$ebnf$1',
      symbols: ['_$ebnf$1', 'wschar'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: '_',
      symbols: ['_$ebnf$1'],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: '__$ebnf$1',
      symbols: ['wschar']
    }, {
      name: '__$ebnf$1',
      symbols: ['__$ebnf$1', 'wschar'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: '__',
      symbols: ['__$ebnf$1'],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'wschar',
      symbols: [/[ \t\n\v\f]/],
      postprocess: id
    }, {
      name: 'dqstring$ebnf$1',
      symbols: []
    }, {
      name: 'dqstring$ebnf$1',
      symbols: ['dqstring$ebnf$1', 'dstrchar'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'dqstring',
      symbols: [{
        literal: '"'
      }, 'dqstring$ebnf$1', {
        literal: '"'
      }],
      postprocess: function postprocess(d) {
        return d[1].join('');
      }
    }, {
      name: 'sqstring$ebnf$1',
      symbols: []
    }, {
      name: 'sqstring$ebnf$1',
      symbols: ['sqstring$ebnf$1', 'sstrchar'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'sqstring',
      symbols: [{
        literal: "'"
      }, 'sqstring$ebnf$1', {
        literal: "'"
      }],
      postprocess: function postprocess(d) {
        return d[1].join('');
      }
    }, {
      name: 'btstring$ebnf$1',
      symbols: []
    }, {
      name: 'btstring$ebnf$1',
      symbols: ['btstring$ebnf$1', /[^`]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'btstring',
      symbols: [{
        literal: '`'
      }, 'btstring$ebnf$1', {
        literal: '`'
      }],
      postprocess: function postprocess(d) {
        return d[1].join('');
      }
    }, {
      name: 'dstrchar',
      symbols: [/[^\\"\n]/],
      postprocess: id
    }, {
      name: 'dstrchar',
      symbols: [{
        literal: '\\'
      }, 'strescape'],
      postprocess: function postprocess(d) {
        return JSON.parse('"' + d.join('') + '"');
      }
    }, {
      name: 'sstrchar',
      symbols: [/[^\\'\n]/],
      postprocess: id
    }, {
      name: 'sstrchar',
      symbols: [{
        literal: '\\'
      }, 'strescape'],
      postprocess: function postprocess(d) {
        return JSON.parse('"' + d.join('') + '"');
      }
    }, {
      name: 'sstrchar$string$1',
      symbols: [{
        literal: '\\'
      }, {
        literal: "'"
      }],
      postprocess: function joiner(d) {
        return d.join('');
      }
    }, {
      name: 'sstrchar',
      symbols: ['sstrchar$string$1'],
      postprocess: function postprocess(d) {
        return "'";
      }
    }, {
      name: 'strescape',
      symbols: [/["\\\/bfnrt]/],
      postprocess: id
    }, {
      name: 'strescape',
      symbols: [{
        literal: 'u'
      }, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/],
      postprocess: function postprocess(d) {
        return d.join('');
      }
    }, {
      name: 'unsigned_int$ebnf$1',
      symbols: [/[0-9]/]
    }, {
      name: 'unsigned_int$ebnf$1',
      symbols: ['unsigned_int$ebnf$1', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'unsigned_int',
      symbols: ['unsigned_int$ebnf$1'],
      postprocess: function postprocess(d) {
        return parseInt(d[0].join(''));
      }
    }, {
      name: 'int$ebnf$1$subexpression$1',
      symbols: [{
        literal: '-'
      }]
    }, {
      name: 'int$ebnf$1$subexpression$1',
      symbols: [{
        literal: '+'
      }]
    }, {
      name: 'int$ebnf$1',
      symbols: ['int$ebnf$1$subexpression$1'],
      postprocess: id
    }, {
      name: 'int$ebnf$1',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'int$ebnf$2',
      symbols: [/[0-9]/]
    }, {
      name: 'int$ebnf$2',
      symbols: ['int$ebnf$2', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'int',
      symbols: ['int$ebnf$1', 'int$ebnf$2'],
      postprocess: function postprocess(d) {
        if (d[0]) {
          return parseInt(d[0][0] + d[1].join(''));
        } else {
          return parseInt(d[1].join(''));
        }
      }
    }, {
      name: 'unsigned_decimal$ebnf$1',
      symbols: [/[0-9]/]
    }, {
      name: 'unsigned_decimal$ebnf$1',
      symbols: ['unsigned_decimal$ebnf$1', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'unsigned_decimal$ebnf$2$subexpression$1$ebnf$1',
      symbols: [/[0-9]/]
    }, {
      name: 'unsigned_decimal$ebnf$2$subexpression$1$ebnf$1',
      symbols: ['unsigned_decimal$ebnf$2$subexpression$1$ebnf$1', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'unsigned_decimal$ebnf$2$subexpression$1',
      symbols: [{
        literal: '.'
      }, 'unsigned_decimal$ebnf$2$subexpression$1$ebnf$1']
    }, {
      name: 'unsigned_decimal$ebnf$2',
      symbols: ['unsigned_decimal$ebnf$2$subexpression$1'],
      postprocess: id
    }, {
      name: 'unsigned_decimal$ebnf$2',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'unsigned_decimal',
      symbols: ['unsigned_decimal$ebnf$1', 'unsigned_decimal$ebnf$2'],
      postprocess: function postprocess(d) {
        return parseFloat(d[0].join('') + (d[1] ? '.' + d[1][1].join('') : ''));
      }
    }, {
      name: 'decimal$ebnf$1',
      symbols: [{
        literal: '-'
      }],
      postprocess: id
    }, {
      name: 'decimal$ebnf$1',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'decimal$ebnf$2',
      symbols: [/[0-9]/]
    }, {
      name: 'decimal$ebnf$2',
      symbols: ['decimal$ebnf$2', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'decimal$ebnf$3$subexpression$1$ebnf$1',
      symbols: [/[0-9]/]
    }, {
      name: 'decimal$ebnf$3$subexpression$1$ebnf$1',
      symbols: ['decimal$ebnf$3$subexpression$1$ebnf$1', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'decimal$ebnf$3$subexpression$1',
      symbols: [{
        literal: '.'
      }, 'decimal$ebnf$3$subexpression$1$ebnf$1']
    }, {
      name: 'decimal$ebnf$3',
      symbols: ['decimal$ebnf$3$subexpression$1'],
      postprocess: id
    }, {
      name: 'decimal$ebnf$3',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'decimal',
      symbols: ['decimal$ebnf$1', 'decimal$ebnf$2', 'decimal$ebnf$3'],
      postprocess: function postprocess(d) {
        return parseFloat((d[0] || '') + d[1].join('') + (d[2] ? '.' + d[2][1].join('') : ''));
      }
    }, {
      name: 'percentage',
      symbols: ['decimal', {
        literal: '%'
      }],
      postprocess: function postprocess(d) {
        return d[0] / 100;
      }
    }, {
      name: 'jsonfloat$ebnf$1',
      symbols: [{
        literal: '-'
      }],
      postprocess: id
    }, {
      name: 'jsonfloat$ebnf$1',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'jsonfloat$ebnf$2',
      symbols: [/[0-9]/]
    }, {
      name: 'jsonfloat$ebnf$2',
      symbols: ['jsonfloat$ebnf$2', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'jsonfloat$ebnf$3$subexpression$1$ebnf$1',
      symbols: [/[0-9]/]
    }, {
      name: 'jsonfloat$ebnf$3$subexpression$1$ebnf$1',
      symbols: ['jsonfloat$ebnf$3$subexpression$1$ebnf$1', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'jsonfloat$ebnf$3$subexpression$1',
      symbols: [{
        literal: '.'
      }, 'jsonfloat$ebnf$3$subexpression$1$ebnf$1']
    }, {
      name: 'jsonfloat$ebnf$3',
      symbols: ['jsonfloat$ebnf$3$subexpression$1'],
      postprocess: id
    }, {
      name: 'jsonfloat$ebnf$3',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'jsonfloat$ebnf$4$subexpression$1$ebnf$1',
      symbols: [/[+-]/],
      postprocess: id
    }, {
      name: 'jsonfloat$ebnf$4$subexpression$1$ebnf$1',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'jsonfloat$ebnf$4$subexpression$1$ebnf$2',
      symbols: [/[0-9]/]
    }, {
      name: 'jsonfloat$ebnf$4$subexpression$1$ebnf$2',
      symbols: ['jsonfloat$ebnf$4$subexpression$1$ebnf$2', /[0-9]/],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'jsonfloat$ebnf$4$subexpression$1',
      symbols: [/[eE]/, 'jsonfloat$ebnf$4$subexpression$1$ebnf$1', 'jsonfloat$ebnf$4$subexpression$1$ebnf$2']
    }, {
      name: 'jsonfloat$ebnf$4',
      symbols: ['jsonfloat$ebnf$4$subexpression$1'],
      postprocess: id
    }, {
      name: 'jsonfloat$ebnf$4',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'jsonfloat',
      symbols: ['jsonfloat$ebnf$1', 'jsonfloat$ebnf$2', 'jsonfloat$ebnf$3', 'jsonfloat$ebnf$4'],
      postprocess: function postprocess(d) {
        return parseFloat((d[0] || '') + d[1].join('') + (d[2] ? '.' + d[2][1].join('') : '') + (d[3] ? 'e' + (d[3][1] || '+') + d[3][2].join('') : ''));
      }
    }, {
      name: 'Pipeline$ebnf$1',
      symbols: []
    }, {
      name: 'Pipeline$ebnf$1$subexpression$1',
      symbols: [{
        literal: '|'
      }, 'Expr']
    }, {
      name: 'Pipeline$ebnf$1',
      symbols: ['Pipeline$ebnf$1', 'Pipeline$ebnf$1$subexpression$1'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'Pipeline',
      symbols: ['Expr', 'Pipeline$ebnf$1'],
      postprocess: function postprocess(d) {
        return [d[0]].concat(_toConsumableArray(d[1].map(function (e) {
          return e[1];
        })));
      }
    }, {
      name: 'Expr',
      symbols: ['_', 'Identifier', '_'],
      postprocess: function postprocess(d) {
        return d[1];
      }
    }, {
      name: 'Expr',
      symbols: ['_', 'Method', '_'],
      postprocess: function postprocess(d) {
        return d[1];
      }
    }, {
      name: 'Expr',
      symbols: ['_', 'Literal', '_'],
      postprocess: function postprocess(d) {
        return d[1];
      }
    }, {
      name: 'Method$ebnf$1',
      symbols: ['Arg'],
      postprocess: id
    }, {
      name: 'Method$ebnf$1',
      symbols: [],
      postprocess: function postprocess(d) {
        return null;
      }
    }, {
      name: 'Method$ebnf$2',
      symbols: []
    }, {
      name: 'Method$ebnf$2$subexpression$1',
      symbols: ['_', {
        literal: ','
      }, '_', 'Arg']
    }, {
      name: 'Method$ebnf$2',
      symbols: ['Method$ebnf$2', 'Method$ebnf$2$subexpression$1'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'Method',
      symbols: ['Identifier', {
        literal: '('
      }, '_', 'Method$ebnf$1', 'Method$ebnf$2', '_', {
        literal: ')'
      }],
      postprocess: function postprocess(d) {
        var arg0 = d[3];
        var otherArgs = d[4];
        var args = [];
        arg0 && args.push(arg0);

        if (otherArgs) {
          args = args.concat(otherArgs.map(function (e) {
            return e[3];
          }));
        }

        var r = {
          type: 'method',
          name: d[0].v,
          args: args
        };
        return r;
      }
    }, {
      name: 'Arg',
      symbols: ['Identifier'],
      postprocess: function postprocess(d) {
        return d[0];
      }
    }, {
      name: 'Arg',
      symbols: ['Literal'],
      postprocess: function postprocess(d) {
        return d[0];
      }
    }, {
      name: 'Identifier$ebnf$1',
      symbols: []
    }, {
      name: 'Identifier$ebnf$1$subexpression$1',
      symbols: ['Letter']
    }, {
      name: 'Identifier$ebnf$1$subexpression$1',
      symbols: ['Digit']
    }, {
      name: 'Identifier$ebnf$1',
      symbols: ['Identifier$ebnf$1', 'Identifier$ebnf$1$subexpression$1'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'Identifier',
      symbols: ['Letter', 'Identifier$ebnf$1'],
      postprocess: function postprocess(d) {
        return {
          type: 'identifier',
          v: d[0] + d[1].join('')
        };
      }
    }, {
      name: 'Identifier$ebnf$2',
      symbols: []
    }, {
      name: 'Identifier$ebnf$2$subexpression$1',
      symbols: ['Letter']
    }, {
      name: 'Identifier$ebnf$2$subexpression$1',
      symbols: ['Digit']
    }, {
      name: 'Identifier$ebnf$2',
      symbols: ['Identifier$ebnf$2', 'Identifier$ebnf$2$subexpression$1'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'Identifier$ebnf$3$subexpression$1$ebnf$1',
      symbols: []
    }, {
      name: 'Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1',
      symbols: ['Letter']
    }, {
      name: 'Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1',
      symbols: ['Digit']
    }, {
      name: 'Identifier$ebnf$3$subexpression$1$ebnf$1',
      symbols: ['Identifier$ebnf$3$subexpression$1$ebnf$1', 'Identifier$ebnf$3$subexpression$1$ebnf$1$subexpression$1'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'Identifier$ebnf$3$subexpression$1',
      symbols: ['Dot', 'Letter', 'Identifier$ebnf$3$subexpression$1$ebnf$1']
    }, {
      name: 'Identifier$ebnf$3',
      symbols: ['Identifier$ebnf$3$subexpression$1']
    }, {
      name: 'Identifier$ebnf$3$subexpression$2$ebnf$1',
      symbols: []
    }, {
      name: 'Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1',
      symbols: ['Letter']
    }, {
      name: 'Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1',
      symbols: ['Digit']
    }, {
      name: 'Identifier$ebnf$3$subexpression$2$ebnf$1',
      symbols: ['Identifier$ebnf$3$subexpression$2$ebnf$1', 'Identifier$ebnf$3$subexpression$2$ebnf$1$subexpression$1'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'Identifier$ebnf$3$subexpression$2',
      symbols: ['Dot', 'Letter', 'Identifier$ebnf$3$subexpression$2$ebnf$1']
    }, {
      name: 'Identifier$ebnf$3',
      symbols: ['Identifier$ebnf$3', 'Identifier$ebnf$3$subexpression$2'],
      postprocess: function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      name: 'Identifier',
      symbols: ['Letter', 'Identifier$ebnf$2', 'Identifier$ebnf$3'],
      postprocess: function postprocess(d) {
        function flat(input) {
          var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
          var stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

          var _iterator = _createForOfIteratorHelper(input),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;

              if (item instanceof Array && depth > 0) {
                flat(item, depth - 1, stack);
              } else {
                stack.push(item);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return stack;
        }

        var r = flat(d, Infinity);
        return {
          type: 'identifier',
          v: r.join('')
        };
      }
    }, {
      name: 'Literal',
      symbols: ['jsonfloat'],
      postprocess: function postprocess(d) {
        return {
          type: 'number',
          v: d[0]
        };
      }
    }, {
      name: 'Literal',
      symbols: ['dqstring'],
      postprocess: function postprocess(d) {
        return {
          type: 'string',
          v: d[0]
        };
      }
    }, {
      name: 'Literal',
      symbols: ['sqstring'],
      postprocess: function postprocess(d) {
        return {
          type: 'string',
          v: d[0]
        };
      }
    }, {
      name: 'Literal',
      symbols: ['btstring'],
      postprocess: function postprocess(d) {
        return {
          type: 'string',
          v: d[0]
        };
      }
    }, {
      name: 'Letter',
      symbols: [/[a-zA-Z_]/],
      postprocess: function postprocess(d) {
        return d[0];
      }
    }, {
      name: 'Digit',
      symbols: [/[0-9]/],
      postprocess: function postprocess(d) {
        return d[0];
      }
    }, {
      name: 'Dot',
      symbols: [/[\.]/],
      postprocess: function postprocess(d) {
        return d[0];
      }
    }],
    ParserStart: 'Pipeline'
  };

  if ( true && typeof module.exports !== 'undefined') {
    module.exports = grammar;
  } else {
    window.grammar = grammar;
  }
})();

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var DslParser_1 = __webpack_require__(22);

var EncodingParser = /*#__PURE__*/function () {
  function EncodingParser() {
    _classCallCheck(this, EncodingParser);
  }

  _createClass(EncodingParser, null, [{
    key: "parseOptions",
    value: function parseOptions(optionsStanza) {
      var optionsAST = {
        simpleOptions: {},
        expressions: {},
        context: optionsStanza.context
      }; // context is just passed along

      var options = optionsStanza.options;
      Object.keys(options).forEach(function (k) {
        var v = options[k];

        if (EncodingParser.isDslString(v)) {
          optionsAST.expressions[k] = DslParser_1.DslParser.parse(EncodingParser.withoutArrow(v));
        } else {
          optionsAST.simpleOptions[k] = v; // things that are not expressions just pass through
        }
      });
      return optionsAST;
    }
  }, {
    key: "isDslString",
    value: function isDslString(s) {
      return s ? s.toString().trim().startsWith('>') : false;
    }
  }, {
    key: "withoutArrow",
    value: function withoutArrow(s) {
      return s.toString().match(/\s*>\s*(.+$)/)[1].trim();
    }
  }, {
    key: "parse",
    value: function parse(encoding) {
      var dslFields = encoding.dimensions,
          context = encoding.context;
      var ast = {
        dimensions: {},
        context: context
      }; //this is what we will populate and return

      Object.keys(dslFields).forEach(function (f) {
        var astDimension = {
          value: []
        };
        var value = null;

        if (typeof dslFields[f] === 'string') {
          value = dslFields[f];
        } else {
          var dim = dslFields[f];
          value = dim.value;
        }

        astDimension.value = DslParser_1.DslParser.parse(value);
        ast.dimensions[f] = astDimension;
      });
      return ast;
    }
  }]);

  return EncodingParser;
}();

exports.default = EncodingParser;

/***/ })
/******/ ]);
//# sourceMappingURL=Prefix.js.map